<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="generator" content="Asciidoctor 2.0.10">
<meta name="author" content="Nota de Aula">
<title>Lógica e Programação de Computadores</title>
<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:300,300italic,400,400italic,600,600italic%7CNoto+Serif:400,400italic,700,700italic%7CDroid+Sans+Mono:400,700">
<style>
/* Asciidoctor default stylesheet | MIT License | https://asciidoctor.org */
/* Uncomment @import statement to use as custom stylesheet */
/*@import "https://fonts.googleapis.com/css?family=Open+Sans:300,300italic,400,400italic,600,600italic%7CNoto+Serif:400,400italic,700,700italic%7CDroid+Sans+Mono:400,700";*/
article,aside,details,figcaption,figure,footer,header,hgroup,main,nav,section{display:block}
audio,video{display:inline-block}
audio:not([controls]){display:none;height:0}
html{font-family:sans-serif;-ms-text-size-adjust:100%;-webkit-text-size-adjust:100%}
a{background:none}
a:focus{outline:thin dotted}
a:active,a:hover{outline:0}
h1{font-size:2em;margin:.67em 0}
abbr[title]{border-bottom:1px dotted}
b,strong{font-weight:bold}
dfn{font-style:italic}
hr{-moz-box-sizing:content-box;box-sizing:content-box;height:0}
mark{background:#ff0;color:#000}
code,kbd,pre,samp{font-family:monospace;font-size:1em}
pre{white-space:pre-wrap}
q{quotes:"\201C" "\201D" "\2018" "\2019"}
small{font-size:80%}
sub,sup{font-size:75%;line-height:0;position:relative;vertical-align:baseline}
sup{top:-.5em}
sub{bottom:-.25em}
img{border:0}
svg:not(:root){overflow:hidden}
figure{margin:0}
fieldset{border:1px solid silver;margin:0 2px;padding:.35em .625em .75em}
legend{border:0;padding:0}
button,input,select,textarea{font-family:inherit;font-size:100%;margin:0}
button,input{line-height:normal}
button,select{text-transform:none}
button,html input[type="button"],input[type="reset"],input[type="submit"]{-webkit-appearance:button;cursor:pointer}
button[disabled],html input[disabled]{cursor:default}
input[type="checkbox"],input[type="radio"]{box-sizing:border-box;padding:0}
button::-moz-focus-inner,input::-moz-focus-inner{border:0;padding:0}
textarea{overflow:auto;vertical-align:top}
table{border-collapse:collapse;border-spacing:0}
*,*::before,*::after{-moz-box-sizing:border-box;-webkit-box-sizing:border-box;box-sizing:border-box}
html,body{font-size:100%}
body{background:#fff;color:rgba(0,0,0,.8);padding:0;margin:0;font-family:"Noto Serif","DejaVu Serif",serif;font-weight:400;font-style:normal;line-height:1;position:relative;cursor:auto;tab-size:4;-moz-osx-font-smoothing:grayscale;-webkit-font-smoothing:antialiased}
a:hover{cursor:pointer}
img,object,embed{max-width:100%;height:auto}
object,embed{height:100%}
img{-ms-interpolation-mode:bicubic}
.left{float:left!important}
.right{float:right!important}
.text-left{text-align:left!important}
.text-right{text-align:right!important}
.text-center{text-align:center!important}
.text-justify{text-align:justify!important}
.hide{display:none}
img,object,svg{display:inline-block;vertical-align:middle}
textarea{height:auto;min-height:50px}
select{width:100%}
.center{margin-left:auto;margin-right:auto}
.stretch{width:100%}
.subheader,.admonitionblock td.content>.title,.audioblock>.title,.exampleblock>.title,.imageblock>.title,.listingblock>.title,.literalblock>.title,.stemblock>.title,.openblock>.title,.paragraph>.title,.quoteblock>.title,table.tableblock>.title,.verseblock>.title,.videoblock>.title,.dlist>.title,.olist>.title,.ulist>.title,.qlist>.title,.hdlist>.title{line-height:1.45;color:#7a2518;font-weight:400;margin-top:0;margin-bottom:.25em}
div,dl,dt,dd,ul,ol,li,h1,h2,h3,#toctitle,.sidebarblock>.content>.title,h4,h5,h6,pre,form,p,blockquote,th,td{margin:0;padding:0;direction:ltr}
a{color:#2156a5;text-decoration:underline;line-height:inherit}
a:hover,a:focus{color:#1d4b8f}
a img{border:0}
p{font-family:inherit;font-weight:400;font-size:1em;line-height:1.6;margin-bottom:1.25em;text-rendering:optimizeLegibility}
p aside{font-size:.875em;line-height:1.35;font-style:italic}
h1,h2,h3,#toctitle,.sidebarblock>.content>.title,h4,h5,h6{font-family:"Open Sans","DejaVu Sans",sans-serif;font-weight:300;font-style:normal;color:#ba3925;text-rendering:optimizeLegibility;margin-top:1em;margin-bottom:.5em;line-height:1.0125em}
h1 small,h2 small,h3 small,#toctitle small,.sidebarblock>.content>.title small,h4 small,h5 small,h6 small{font-size:60%;color:#e99b8f;line-height:0}
h1{font-size:2.125em}
h2{font-size:1.6875em}
h3,#toctitle,.sidebarblock>.content>.title{font-size:1.375em}
h4,h5{font-size:1.125em}
h6{font-size:1em}
hr{border:solid #dddddf;border-width:1px 0 0;clear:both;margin:1.25em 0 1.1875em;height:0}
em,i{font-style:italic;line-height:inherit}
strong,b{font-weight:bold;line-height:inherit}
small{font-size:60%;line-height:inherit}
code{font-family:"Droid Sans Mono","DejaVu Sans Mono",monospace;font-weight:400;color:rgba(0,0,0,.9)}
ul,ol,dl{font-size:1em;line-height:1.6;margin-bottom:1.25em;list-style-position:outside;font-family:inherit}
ul,ol{margin-left:1.5em}
ul li ul,ul li ol{margin-left:1.25em;margin-bottom:0;font-size:1em}
ul.square li ul,ul.circle li ul,ul.disc li ul{list-style:inherit}
ul.square{list-style-type:square}
ul.circle{list-style-type:circle}
ul.disc{list-style-type:disc}
ol li ul,ol li ol{margin-left:1.25em;margin-bottom:0}
dl dt{margin-bottom:.3125em;font-weight:bold}
dl dd{margin-bottom:1.25em}
abbr,acronym{text-transform:uppercase;font-size:90%;color:rgba(0,0,0,.8);border-bottom:1px dotted #ddd;cursor:help}
abbr{text-transform:none}
blockquote{margin:0 0 1.25em;padding:.5625em 1.25em 0 1.1875em;border-left:1px solid #ddd}
blockquote cite{display:block;font-size:.9375em;color:rgba(0,0,0,.6)}
blockquote cite::before{content:"\2014 \0020"}
blockquote cite a,blockquote cite a:visited{color:rgba(0,0,0,.6)}
blockquote,blockquote p{line-height:1.6;color:rgba(0,0,0,.85)}
@media screen and (min-width:768px){h1,h2,h3,#toctitle,.sidebarblock>.content>.title,h4,h5,h6{line-height:1.2}
h1{font-size:2.75em}
h2{font-size:2.3125em}
h3,#toctitle,.sidebarblock>.content>.title{font-size:1.6875em}
h4{font-size:1.4375em}}
table{background:#fff;margin-bottom:1.25em;border:solid 1px #dedede}
table thead,table tfoot{background:#f7f8f7}
table thead tr th,table thead tr td,table tfoot tr th,table tfoot tr td{padding:.5em .625em .625em;font-size:inherit;color:rgba(0,0,0,.8);text-align:left}
table tr th,table tr td{padding:.5625em .625em;font-size:inherit;color:rgba(0,0,0,.8)}
table tr.even,table tr.alt{background:#f8f8f7}
table thead tr th,table tfoot tr th,table tbody tr td,table tr td,table tfoot tr td{display:table-cell;line-height:1.6}
h1,h2,h3,#toctitle,.sidebarblock>.content>.title,h4,h5,h6{line-height:1.2;word-spacing:-.05em}
h1 strong,h2 strong,h3 strong,#toctitle strong,.sidebarblock>.content>.title strong,h4 strong,h5 strong,h6 strong{font-weight:400}
.clearfix::before,.clearfix::after,.float-group::before,.float-group::after{content:" ";display:table}
.clearfix::after,.float-group::after{clear:both}
:not(pre):not([class^=L])>code{font-size:.9375em;font-style:normal!important;letter-spacing:0;padding:.1em .5ex;word-spacing:-.15em;background:#f7f7f8;-webkit-border-radius:4px;border-radius:4px;line-height:1.45;text-rendering:optimizeSpeed;word-wrap:break-word}
:not(pre)>code.nobreak{word-wrap:normal}
:not(pre)>code.nowrap{white-space:nowrap}
pre{color:rgba(0,0,0,.9);font-family:"Droid Sans Mono","DejaVu Sans Mono",monospace;line-height:1.45;text-rendering:optimizeSpeed}
pre code,pre pre{color:inherit;font-size:inherit;line-height:inherit}
pre>code{display:block}
pre.nowrap,pre.nowrap pre{white-space:pre;word-wrap:normal}
em em{font-style:normal}
strong strong{font-weight:400}
.keyseq{color:rgba(51,51,51,.8)}
kbd{font-family:"Droid Sans Mono","DejaVu Sans Mono",monospace;display:inline-block;color:rgba(0,0,0,.8);font-size:.65em;line-height:1.45;background:#f7f7f7;border:1px solid #ccc;-webkit-border-radius:3px;border-radius:3px;-webkit-box-shadow:0 1px 0 rgba(0,0,0,.2),0 0 0 .1em white inset;box-shadow:0 1px 0 rgba(0,0,0,.2),0 0 0 .1em #fff inset;margin:0 .15em;padding:.2em .5em;vertical-align:middle;position:relative;top:-.1em;white-space:nowrap}
.keyseq kbd:first-child{margin-left:0}
.keyseq kbd:last-child{margin-right:0}
.menuseq,.menuref{color:#000}
.menuseq b:not(.caret),.menuref{font-weight:inherit}
.menuseq{word-spacing:-.02em}
.menuseq b.caret{font-size:1.25em;line-height:.8}
.menuseq i.caret{font-weight:bold;text-align:center;width:.45em}
b.button::before,b.button::after{position:relative;top:-1px;font-weight:400}
b.button::before{content:"[";padding:0 3px 0 2px}
b.button::after{content:"]";padding:0 2px 0 3px}
p a>code:hover{color:rgba(0,0,0,.9)}
#header,#content,#footnotes,#footer{width:100%;margin-left:auto;margin-right:auto;margin-top:0;margin-bottom:0;max-width:62.5em;*zoom:1;position:relative;padding-left:.9375em;padding-right:.9375em}
#header::before,#header::after,#content::before,#content::after,#footnotes::before,#footnotes::after,#footer::before,#footer::after{content:" ";display:table}
#header::after,#content::after,#footnotes::after,#footer::after{clear:both}
#content{margin-top:1.25em}
#content::before{content:none}
#header>h1:first-child{color:rgba(0,0,0,.85);margin-top:2.25rem;margin-bottom:0}
#header>h1:first-child+#toc{margin-top:8px;border-top:1px solid #dddddf}
#header>h1:only-child,body.toc2 #header>h1:nth-last-child(2){border-bottom:1px solid #dddddf;padding-bottom:8px}
#header .details{border-bottom:1px solid #dddddf;line-height:1.45;padding-top:.25em;padding-bottom:.25em;padding-left:.25em;color:rgba(0,0,0,.6);display:-ms-flexbox;display:-webkit-flex;display:flex;-ms-flex-flow:row wrap;-webkit-flex-flow:row wrap;flex-flow:row wrap}
#header .details span:first-child{margin-left:-.125em}
#header .details span.email a{color:rgba(0,0,0,.85)}
#header .details br{display:none}
#header .details br+span::before{content:"\00a0\2013\00a0"}
#header .details br+span.author::before{content:"\00a0\22c5\00a0";color:rgba(0,0,0,.85)}
#header .details br+span#revremark::before{content:"\00a0|\00a0"}
#header #revnumber{text-transform:capitalize}
#header #revnumber::after{content:"\00a0"}
#content>h1:first-child:not([class]){color:rgba(0,0,0,.85);border-bottom:1px solid #dddddf;padding-bottom:8px;margin-top:0;padding-top:1rem;margin-bottom:1.25rem}
#toc{border-bottom:1px solid #e7e7e9;padding-bottom:.5em}
#toc>ul{margin-left:.125em}
#toc ul.sectlevel0>li>a{font-style:italic}
#toc ul.sectlevel0 ul.sectlevel1{margin:.5em 0}
#toc ul{font-family:"Open Sans","DejaVu Sans",sans-serif;list-style-type:none}
#toc li{line-height:1.3334;margin-top:.3334em}
#toc a{text-decoration:none}
#toc a:active{text-decoration:underline}
#toctitle{color:#7a2518;font-size:1.2em}
@media screen and (min-width:768px){#toctitle{font-size:1.375em}
body.toc2{padding-left:15em;padding-right:0}
#toc.toc2{margin-top:0!important;background:#f8f8f7;position:fixed;width:15em;left:0;top:0;border-right:1px solid #e7e7e9;border-top-width:0!important;border-bottom-width:0!important;z-index:1000;padding:1.25em 1em;height:100%;overflow:auto}
#toc.toc2 #toctitle{margin-top:0;margin-bottom:.8rem;font-size:1.2em}
#toc.toc2>ul{font-size:.9em;margin-bottom:0}
#toc.toc2 ul ul{margin-left:0;padding-left:1em}
#toc.toc2 ul.sectlevel0 ul.sectlevel1{padding-left:0;margin-top:.5em;margin-bottom:.5em}
body.toc2.toc-right{padding-left:0;padding-right:15em}
body.toc2.toc-right #toc.toc2{border-right-width:0;border-left:1px solid #e7e7e9;left:auto;right:0}}
@media screen and (min-width:1280px){body.toc2{padding-left:20em;padding-right:0}
#toc.toc2{width:20em}
#toc.toc2 #toctitle{font-size:1.375em}
#toc.toc2>ul{font-size:.95em}
#toc.toc2 ul ul{padding-left:1.25em}
body.toc2.toc-right{padding-left:0;padding-right:20em}}
#content #toc{border-style:solid;border-width:1px;border-color:#e0e0dc;margin-bottom:1.25em;padding:1.25em;background:#f8f8f7;-webkit-border-radius:4px;border-radius:4px}
#content #toc>:first-child{margin-top:0}
#content #toc>:last-child{margin-bottom:0}
#footer{max-width:100%;background:rgba(0,0,0,.8);padding:1.25em}
#footer-text{color:rgba(255,255,255,.8);line-height:1.44}
#content{margin-bottom:.625em}
.sect1{padding-bottom:.625em}
@media screen and (min-width:768px){#content{margin-bottom:1.25em}
.sect1{padding-bottom:1.25em}}
.sect1:last-child{padding-bottom:0}
.sect1+.sect1{border-top:1px solid #e7e7e9}
#content h1>a.anchor,h2>a.anchor,h3>a.anchor,#toctitle>a.anchor,.sidebarblock>.content>.title>a.anchor,h4>a.anchor,h5>a.anchor,h6>a.anchor{position:absolute;z-index:1001;width:1.5ex;margin-left:-1.5ex;display:block;text-decoration:none!important;visibility:hidden;text-align:center;font-weight:400}
#content h1>a.anchor::before,h2>a.anchor::before,h3>a.anchor::before,#toctitle>a.anchor::before,.sidebarblock>.content>.title>a.anchor::before,h4>a.anchor::before,h5>a.anchor::before,h6>a.anchor::before{content:"\00A7";font-size:.85em;display:block;padding-top:.1em}
#content h1:hover>a.anchor,#content h1>a.anchor:hover,h2:hover>a.anchor,h2>a.anchor:hover,h3:hover>a.anchor,#toctitle:hover>a.anchor,.sidebarblock>.content>.title:hover>a.anchor,h3>a.anchor:hover,#toctitle>a.anchor:hover,.sidebarblock>.content>.title>a.anchor:hover,h4:hover>a.anchor,h4>a.anchor:hover,h5:hover>a.anchor,h5>a.anchor:hover,h6:hover>a.anchor,h6>a.anchor:hover{visibility:visible}
#content h1>a.link,h2>a.link,h3>a.link,#toctitle>a.link,.sidebarblock>.content>.title>a.link,h4>a.link,h5>a.link,h6>a.link{color:#ba3925;text-decoration:none}
#content h1>a.link:hover,h2>a.link:hover,h3>a.link:hover,#toctitle>a.link:hover,.sidebarblock>.content>.title>a.link:hover,h4>a.link:hover,h5>a.link:hover,h6>a.link:hover{color:#a53221}
details,.audioblock,.imageblock,.literalblock,.listingblock,.stemblock,.videoblock{margin-bottom:1.25em}
details>summary:first-of-type{cursor:pointer;display:list-item;outline:none;margin-bottom:.75em}
.admonitionblock td.content>.title,.audioblock>.title,.exampleblock>.title,.imageblock>.title,.listingblock>.title,.literalblock>.title,.stemblock>.title,.openblock>.title,.paragraph>.title,.quoteblock>.title,table.tableblock>.title,.verseblock>.title,.videoblock>.title,.dlist>.title,.olist>.title,.ulist>.title,.qlist>.title,.hdlist>.title{text-rendering:optimizeLegibility;text-align:left;font-family:"Noto Serif","DejaVu Serif",serif;font-size:1rem;font-style:italic}
table.tableblock.fit-content>caption.title{white-space:nowrap;width:0}
.paragraph.lead>p,#preamble>.sectionbody>[class="paragraph"]:first-of-type p{font-size:1.21875em;line-height:1.6;color:rgba(0,0,0,.85)}
table.tableblock #preamble>.sectionbody>[class="paragraph"]:first-of-type p{font-size:inherit}
.admonitionblock>table{border-collapse:separate;border:0;background:none;width:100%}
.admonitionblock>table td.icon{text-align:center;width:80px}
.admonitionblock>table td.icon img{max-width:none}
.admonitionblock>table td.icon .title{font-weight:bold;font-family:"Open Sans","DejaVu Sans",sans-serif;text-transform:uppercase}
.admonitionblock>table td.content{padding-left:1.125em;padding-right:1.25em;border-left:1px solid #dddddf;color:rgba(0,0,0,.6)}
.admonitionblock>table td.content>:last-child>:last-child{margin-bottom:0}
.exampleblock>.content{border-style:solid;border-width:1px;border-color:#e6e6e6;margin-bottom:1.25em;padding:1.25em;background:#fff;-webkit-border-radius:4px;border-radius:4px}
.exampleblock>.content>:first-child{margin-top:0}
.exampleblock>.content>:last-child{margin-bottom:0}
.sidebarblock{border-style:solid;border-width:1px;border-color:#dbdbd6;margin-bottom:1.25em;padding:1.25em;background:#f3f3f2;-webkit-border-radius:4px;border-radius:4px}
.sidebarblock>:first-child{margin-top:0}
.sidebarblock>:last-child{margin-bottom:0}
.sidebarblock>.content>.title{color:#7a2518;margin-top:0;text-align:center}
.exampleblock>.content>:last-child>:last-child,.exampleblock>.content .olist>ol>li:last-child>:last-child,.exampleblock>.content .ulist>ul>li:last-child>:last-child,.exampleblock>.content .qlist>ol>li:last-child>:last-child,.sidebarblock>.content>:last-child>:last-child,.sidebarblock>.content .olist>ol>li:last-child>:last-child,.sidebarblock>.content .ulist>ul>li:last-child>:last-child,.sidebarblock>.content .qlist>ol>li:last-child>:last-child{margin-bottom:0}
.literalblock pre,.listingblock>.content>pre{-webkit-border-radius:4px;border-radius:4px;word-wrap:break-word;overflow-x:auto;padding:1em;font-size:.8125em}
@media screen and (min-width:768px){.literalblock pre,.listingblock>.content>pre{font-size:.90625em}}
@media screen and (min-width:1280px){.literalblock pre,.listingblock>.content>pre{font-size:1em}}
.literalblock pre,.listingblock>.content>pre:not(.highlight),.listingblock>.content>pre[class="highlight"],.listingblock>.content>pre[class^="highlight "]{background:#f7f7f8}
.literalblock.output pre{color:#f7f7f8;background:rgba(0,0,0,.9)}
.listingblock>.content{position:relative}
.listingblock code[data-lang]::before{display:none;content:attr(data-lang);position:absolute;font-size:.75em;top:.425rem;right:.5rem;line-height:1;text-transform:uppercase;color:inherit;opacity:.5}
.listingblock:hover code[data-lang]::before{display:block}
.listingblock.terminal pre .command::before{content:attr(data-prompt);padding-right:.5em;color:inherit;opacity:.5}
.listingblock.terminal pre .command:not([data-prompt])::before{content:"$"}
.listingblock pre.highlightjs{padding:0}
.listingblock pre.highlightjs>code{padding:1em;-webkit-border-radius:4px;border-radius:4px}
.listingblock pre.prettyprint{border-width:0}
.prettyprint{background:#f7f7f8}
pre.prettyprint .linenums{line-height:1.45;margin-left:2em}
pre.prettyprint li{background:none;list-style-type:inherit;padding-left:0}
pre.prettyprint li code[data-lang]::before{opacity:1}
pre.prettyprint li:not(:first-child) code[data-lang]::before{display:none}
table.linenotable{border-collapse:separate;border:0;margin-bottom:0;background:none}
table.linenotable td[class]{color:inherit;vertical-align:top;padding:0;line-height:inherit;white-space:normal}
table.linenotable td.code{padding-left:.75em}
table.linenotable td.linenos{border-right:1px solid currentColor;opacity:.35;padding-right:.5em}
pre.pygments .lineno{border-right:1px solid currentColor;opacity:.35;display:inline-block;margin-right:.75em}
pre.pygments .lineno::before{content:"";margin-right:-.125em}
.quoteblock{margin:0 1em 1.25em 1.5em;display:table}
.quoteblock:not(.excerpt)>.title{margin-left:-1.5em;margin-bottom:.75em}
.quoteblock blockquote,.quoteblock p{color:rgba(0,0,0,.85);font-size:1.15rem;line-height:1.75;word-spacing:.1em;letter-spacing:0;font-style:italic;text-align:justify}
.quoteblock blockquote{margin:0;padding:0;border:0}
.quoteblock blockquote::before{content:"\201c";float:left;font-size:2.75em;font-weight:bold;line-height:.6em;margin-left:-.6em;color:#7a2518;text-shadow:0 1px 2px rgba(0,0,0,.1)}
.quoteblock blockquote>.paragraph:last-child p{margin-bottom:0}
.quoteblock .attribution{margin-top:.75em;margin-right:.5ex;text-align:right}
.verseblock{margin:0 1em 1.25em}
.verseblock pre{font-family:"Open Sans","DejaVu Sans",sans;font-size:1.15rem;color:rgba(0,0,0,.85);font-weight:300;text-rendering:optimizeLegibility}
.verseblock pre strong{font-weight:400}
.verseblock .attribution{margin-top:1.25rem;margin-left:.5ex}
.quoteblock .attribution,.verseblock .attribution{font-size:.9375em;line-height:1.45;font-style:italic}
.quoteblock .attribution br,.verseblock .attribution br{display:none}
.quoteblock .attribution cite,.verseblock .attribution cite{display:block;letter-spacing:-.025em;color:rgba(0,0,0,.6)}
.quoteblock.abstract blockquote::before,.quoteblock.excerpt blockquote::before,.quoteblock .quoteblock blockquote::before{display:none}
.quoteblock.abstract blockquote,.quoteblock.abstract p,.quoteblock.excerpt blockquote,.quoteblock.excerpt p,.quoteblock .quoteblock blockquote,.quoteblock .quoteblock p{line-height:1.6;word-spacing:0}
.quoteblock.abstract{margin:0 1em 1.25em;display:block}
.quoteblock.abstract>.title{margin:0 0 .375em;font-size:1.15em;text-align:center}
.quoteblock.excerpt>blockquote,.quoteblock .quoteblock{padding:0 0 .25em 1em;border-left:.25em solid #dddddf}
.quoteblock.excerpt,.quoteblock .quoteblock{margin-left:0}
.quoteblock.excerpt blockquote,.quoteblock.excerpt p,.quoteblock .quoteblock blockquote,.quoteblock .quoteblock p{color:inherit;font-size:1.0625rem}
.quoteblock.excerpt .attribution,.quoteblock .quoteblock .attribution{color:inherit;text-align:left;margin-right:0}
table.tableblock{max-width:100%;border-collapse:separate}
p.tableblock:last-child{margin-bottom:0}
td.tableblock>.content>:last-child{margin-bottom:-1.25em}
td.tableblock>.content>:last-child.sidebarblock{margin-bottom:0}
table.tableblock,th.tableblock,td.tableblock{border:0 solid #dedede}
table.grid-all>thead>tr>.tableblock,table.grid-all>tbody>tr>.tableblock{border-width:0 1px 1px 0}
table.grid-all>tfoot>tr>.tableblock{border-width:1px 1px 0 0}
table.grid-cols>*>tr>.tableblock{border-width:0 1px 0 0}
table.grid-rows>thead>tr>.tableblock,table.grid-rows>tbody>tr>.tableblock{border-width:0 0 1px}
table.grid-rows>tfoot>tr>.tableblock{border-width:1px 0 0}
table.grid-all>*>tr>.tableblock:last-child,table.grid-cols>*>tr>.tableblock:last-child{border-right-width:0}
table.grid-all>tbody>tr:last-child>.tableblock,table.grid-all>thead:last-child>tr>.tableblock,table.grid-rows>tbody>tr:last-child>.tableblock,table.grid-rows>thead:last-child>tr>.tableblock{border-bottom-width:0}
table.frame-all{border-width:1px}
table.frame-sides{border-width:0 1px}
table.frame-topbot,table.frame-ends{border-width:1px 0}
table.stripes-all tr,table.stripes-odd tr:nth-of-type(odd),table.stripes-even tr:nth-of-type(even),table.stripes-hover tr:hover{background:#f8f8f7}
th.halign-left,td.halign-left{text-align:left}
th.halign-right,td.halign-right{text-align:right}
th.halign-center,td.halign-center{text-align:center}
th.valign-top,td.valign-top{vertical-align:top}
th.valign-bottom,td.valign-bottom{vertical-align:bottom}
th.valign-middle,td.valign-middle{vertical-align:middle}
table thead th,table tfoot th{font-weight:bold}
tbody tr th{display:table-cell;line-height:1.6;background:#f7f8f7}
tbody tr th,tbody tr th p,tfoot tr th,tfoot tr th p{color:rgba(0,0,0,.8);font-weight:bold}
p.tableblock>code:only-child{background:none;padding:0}
p.tableblock{font-size:1em}
ol{margin-left:1.75em}
ul li ol{margin-left:1.5em}
dl dd{margin-left:1.125em}
dl dd:last-child,dl dd:last-child>:last-child{margin-bottom:0}
ol>li p,ul>li p,ul dd,ol dd,.olist .olist,.ulist .ulist,.ulist .olist,.olist .ulist{margin-bottom:.625em}
ul.checklist,ul.none,ol.none,ul.no-bullet,ol.no-bullet,ol.unnumbered,ul.unstyled,ol.unstyled{list-style-type:none}
ul.no-bullet,ol.no-bullet,ol.unnumbered{margin-left:.625em}
ul.unstyled,ol.unstyled{margin-left:0}
ul.checklist{margin-left:.625em}
ul.checklist li>p:first-child>.fa-square-o:first-child,ul.checklist li>p:first-child>.fa-check-square-o:first-child{width:1.25em;font-size:.8em;position:relative;bottom:.125em}
ul.checklist li>p:first-child>input[type="checkbox"]:first-child{margin-right:.25em}
ul.inline{display:-ms-flexbox;display:-webkit-box;display:flex;-ms-flex-flow:row wrap;-webkit-flex-flow:row wrap;flex-flow:row wrap;list-style:none;margin:0 0 .625em -1.25em}
ul.inline>li{margin-left:1.25em}
.unstyled dl dt{font-weight:400;font-style:normal}
ol.arabic{list-style-type:decimal}
ol.decimal{list-style-type:decimal-leading-zero}
ol.loweralpha{list-style-type:lower-alpha}
ol.upperalpha{list-style-type:upper-alpha}
ol.lowerroman{list-style-type:lower-roman}
ol.upperroman{list-style-type:upper-roman}
ol.lowergreek{list-style-type:lower-greek}
.hdlist>table,.colist>table{border:0;background:none}
.hdlist>table>tbody>tr,.colist>table>tbody>tr{background:none}
td.hdlist1,td.hdlist2{vertical-align:top;padding:0 .625em}
td.hdlist1{font-weight:bold;padding-bottom:1.25em}
.literalblock+.colist,.listingblock+.colist{margin-top:-.5em}
.colist td:not([class]):first-child{padding:.4em .75em 0;line-height:1;vertical-align:top}
.colist td:not([class]):first-child img{max-width:none}
.colist td:not([class]):last-child{padding:.25em 0}
.thumb,.th{line-height:0;display:inline-block;border:solid 4px #fff;-webkit-box-shadow:0 0 0 1px #ddd;box-shadow:0 0 0 1px #ddd}
.imageblock.left{margin:.25em .625em 1.25em 0}
.imageblock.right{margin:.25em 0 1.25em .625em}
.imageblock>.title{margin-bottom:0}
.imageblock.thumb,.imageblock.th{border-width:6px}
.imageblock.thumb>.title,.imageblock.th>.title{padding:0 .125em}
.image.left,.image.right{margin-top:.25em;margin-bottom:.25em;display:inline-block;line-height:0}
.image.left{margin-right:.625em}
.image.right{margin-left:.625em}
a.image{text-decoration:none;display:inline-block}
a.image object{pointer-events:none}
sup.footnote,sup.footnoteref{font-size:.875em;position:static;vertical-align:super}
sup.footnote a,sup.footnoteref a{text-decoration:none}
sup.footnote a:active,sup.footnoteref a:active{text-decoration:underline}
#footnotes{padding-top:.75em;padding-bottom:.75em;margin-bottom:.625em}
#footnotes hr{width:20%;min-width:6.25em;margin:-.25em 0 .75em;border-width:1px 0 0}
#footnotes .footnote{padding:0 .375em 0 .225em;line-height:1.3334;font-size:.875em;margin-left:1.2em;margin-bottom:.2em}
#footnotes .footnote a:first-of-type{font-weight:bold;text-decoration:none;margin-left:-1.05em}
#footnotes .footnote:last-of-type{margin-bottom:0}
#content #footnotes{margin-top:-.625em;margin-bottom:0;padding:.75em 0}
.gist .file-data>table{border:0;background:#fff;width:100%;margin-bottom:0}
.gist .file-data>table td.line-data{width:99%}
div.unbreakable{page-break-inside:avoid}
.big{font-size:larger}
.small{font-size:smaller}
.underline{text-decoration:underline}
.overline{text-decoration:overline}
.line-through{text-decoration:line-through}
.aqua{color:#00bfbf}
.aqua-background{background:#00fafa}
.black{color:#000}
.black-background{background:#000}
.blue{color:#0000bf}
.blue-background{background:#0000fa}
.fuchsia{color:#bf00bf}
.fuchsia-background{background:#fa00fa}
.gray{color:#606060}
.gray-background{background:#7d7d7d}
.green{color:#006000}
.green-background{background:#007d00}
.lime{color:#00bf00}
.lime-background{background:#00fa00}
.maroon{color:#600000}
.maroon-background{background:#7d0000}
.navy{color:#000060}
.navy-background{background:#00007d}
.olive{color:#606000}
.olive-background{background:#7d7d00}
.purple{color:#600060}
.purple-background{background:#7d007d}
.red{color:#bf0000}
.red-background{background:#fa0000}
.silver{color:#909090}
.silver-background{background:#bcbcbc}
.teal{color:#006060}
.teal-background{background:#007d7d}
.white{color:#bfbfbf}
.white-background{background:#fafafa}
.yellow{color:#bfbf00}
.yellow-background{background:#fafa00}
span.icon>.fa{cursor:default}
a span.icon>.fa{cursor:inherit}
.admonitionblock td.icon [class^="fa icon-"]{font-size:2.5em;text-shadow:1px 1px 2px rgba(0,0,0,.5);cursor:default}
.admonitionblock td.icon .icon-note::before{content:"\f05a";color:#19407c}
.admonitionblock td.icon .icon-tip::before{content:"\f0eb";text-shadow:1px 1px 2px rgba(155,155,0,.8);color:#111}
.admonitionblock td.icon .icon-warning::before{content:"\f071";color:#bf6900}
.admonitionblock td.icon .icon-caution::before{content:"\f06d";color:#bf3400}
.admonitionblock td.icon .icon-important::before{content:"\f06a";color:#bf0000}
.conum[data-value]{display:inline-block;color:#fff!important;background:rgba(0,0,0,.8);-webkit-border-radius:100px;border-radius:100px;text-align:center;font-size:.75em;width:1.67em;height:1.67em;line-height:1.67em;font-family:"Open Sans","DejaVu Sans",sans-serif;font-style:normal;font-weight:bold}
.conum[data-value] *{color:#fff!important}
.conum[data-value]+b{display:none}
.conum[data-value]::after{content:attr(data-value)}
pre .conum[data-value]{position:relative;top:-.125em}
b.conum *{color:inherit!important}
.conum:not([data-value]):empty{display:none}
dt,th.tableblock,td.content,div.footnote{text-rendering:optimizeLegibility}
h1,h2,p,td.content,span.alt{letter-spacing:-.01em}
p strong,td.content strong,div.footnote strong{letter-spacing:-.005em}
p,blockquote,dt,td.content,span.alt{font-size:1.0625rem}
p{margin-bottom:1.25rem}
.sidebarblock p,.sidebarblock dt,.sidebarblock td.content,p.tableblock{font-size:1em}
.exampleblock>.content{background:#fffef7;border-color:#e0e0dc;-webkit-box-shadow:0 1px 4px #e0e0dc;box-shadow:0 1px 4px #e0e0dc}
.print-only{display:none!important}
@page{margin:1.25cm .75cm}
@media print{*{-webkit-box-shadow:none!important;box-shadow:none!important;text-shadow:none!important}
html{font-size:80%}
a{color:inherit!important;text-decoration:underline!important}
a.bare,a[href^="#"],a[href^="mailto:"]{text-decoration:none!important}
a[href^="http:"]:not(.bare)::after,a[href^="https:"]:not(.bare)::after{content:"(" attr(href) ")";display:inline-block;font-size:.875em;padding-left:.25em}
abbr[title]::after{content:" (" attr(title) ")"}
pre,blockquote,tr,img,object,svg{page-break-inside:avoid}
thead{display:table-header-group}
svg{max-width:100%}
p,blockquote,dt,td.content{font-size:1em;orphans:3;widows:3}
h2,h3,#toctitle,.sidebarblock>.content>.title{page-break-after:avoid}
#toc,.sidebarblock,.exampleblock>.content{background:none!important}
#toc{border-bottom:1px solid #dddddf!important;padding-bottom:0!important}
body.book #header{text-align:center}
body.book #header>h1:first-child{border:0!important;margin:2.5em 0 1em}
body.book #header .details{border:0!important;display:block;padding:0!important}
body.book #header .details span:first-child{margin-left:0!important}
body.book #header .details br{display:block}
body.book #header .details br+span::before{content:none!important}
body.book #toc{border:0!important;text-align:left!important;padding:0!important;margin:0!important}
body.book #toc,body.book #preamble,body.book h1.sect0,body.book .sect1>h2{page-break-before:always}
.listingblock code[data-lang]::before{display:block}
#footer{padding:0 .9375em}
.hide-on-print{display:none!important}
.print-only{display:block!important}
.hide-for-print{display:none!important}
.show-for-print{display:inherit!important}}
@media print,amzn-kf8{#header>h1:first-child{margin-top:1.25rem}
.sect1{padding:0!important}
.sect1+.sect1{border:0}
#footer{background:none}
#footer-text{color:rgba(0,0,0,.6);font-size:.9em}}
@media amzn-kf8{#header,#content,#footnotes,#footer{padding:0}}
</style>
</head>
<body class="article toc2 toc-left">
<div id="header">
<h1>Lógica e Programação de Computadores</h1>
<div class="details">
<span id="author" class="author">Nota de Aula</span><br>
<span id="email" class="email"><a href="mailto:victor.silva@professores.ibmec.edu.br">victor.silva@professores.ibmec.edu.br</a></span><br>
</div>
<div id="toc" class="toc2">
<div id="toctitle">Table of Contents</div>
<ul class="sectlevel1">
<li><a href="#algoritmos">1. Algoritmos</a>
<ul class="sectlevel2">
<li><a href="#apresentacao_algoritmos">1.1. Apresentação dos Algoritmos</a></li>
<li><a href="#recursividade">1.2. Recursividade</a></li>
<li><a href="#complexidade_algoritmos">1.3. Complexidade de Algoritmos</a></li>
<li><a href="#notacao_o">1.4. A Notação O</a></li>
<li><a href="#algoritmos_otimos">1.5. Algoritmos Ótimos</a></li>
</ul>
</li>
<li><a href="#listas_lineares">2. Listas Lineares</a>
<ul class="sectlevel2">
<li><a href="#introducao">2.1. Introdução</a></li>
<li><a href="#alocacao_sequencial">2.2. Alocação Sequencial</a></li>
<li><a href="#listas_aloc_seq">2.3. Listas Lineares em Alocação Sequencial</a></li>
<li><a href="#pilhas_filas">2.4. Pilhas e Filas</a></li>
<li><a href="#alocacao_encadeada">2.5. Alocação encadeada</a></li>
<li><a href="#listas_lin_aloc_enc">2.6. Listas Lineares em Alocação Encadeada</a>
<ul class="sectlevel3">
<li><a href="#listas_sim_enc">2.6.1. Listas simplesmente encadeadas</a></li>
<li><a href="#pilhas_filas_aloc_enc">2.6.2. Pilhas e Filas</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#arvores">3. Árvores</a>
<ul class="sectlevel2">
<li><a href="#_introdução">3.1. Introdução</a></li>
<li><a href="#_definições_e_representações_básicas">3.2. Definições e representações básicas</a></li>
<li><a href="#_árvores_binárias">3.3. Árvores binárias</a>
<ul class="sectlevel3">
<li><a href="#_altura_de_árvores_binárias_completas">3.3.1. Altura de árvores binárias completas</a></li>
<li><a href="#_subárvore_e_subárvore_parcial">3.3.2. Subárvore e subárvore parcial</a></li>
<li><a href="#_árvore_m_ária">3.3.3. Árvore m-ária</a></li>
<li><a href="#_armazenamento_de_árvores">3.3.4. Armazenamento de árvores</a></li>
</ul>
</li>
<li><a href="#_percurso_em_árvores_binárias">3.4. Percurso em árvores binárias</a></li>
</ul>
</li>
</ul>
</div>
</div>
<div id="content">
<div id="preamble">
<div class="sectionbody">
<div style="page-break-after: always;"></div>
</div>
</div>
<div class="sect1">
<h2 id="algoritmos">1. Algoritmos</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Um algoritmo é um processo sistemático para a resolução de um problema. O desenvolvimento de algoritmos é particularmente importante para problemas a serem solucionados em um computador, pela própria natureza do instrumento utilizado.</p>
</div>
<div class="paragraph">
<p>Existem dois aspectos básicos no estudo de algoritmos: a correção e a análise. O primeiro consiste em verificar a exatidão do método empregado, o que é realizado através de uma prova matemática. A análise visa à obtenção de parâmetros que possam avaliar a eficiência do algoritmo em termos de tempo de execução e memória ocupada. A análise é realizada através de um estudo do comportamento do algoritmo.</p>
</div>
<div class="paragraph">
<p>Um algoritmo computa uma saída, o resultado do problema, a partir de uma entrada, as informações inicialmente conhecidas e que permitem encontrar a solução do problema. Durante o processo de computação o algoritmo manipula dados, gerados a partir da sua entrada.</p>
</div>
<div class="paragraph">
<p>Quando os dados são dispostos e manipulados de uma forma homogênea, constituem um tipo abstrato de dados. Este é composto por um modelo matemático acompanhado por um conjunto de operações definido sobre esse modelo. Na representação do modelo matemático emprega-se uma estrutura de dados.</p>
</div>
<div class="paragraph">
<p>O estudo de estruturas de dados não pode ser desvinculado de seus aspectos algorítmicos. A escolha correta da estrutura adequada a cada caso depende diretamente do conhecimento de algoritmos para manipular a estrutura de maneira eficiente.</p>
</div>
<div class="sect2">
<h3 id="apresentacao_algoritmos">1.1. Apresentação dos Algoritmos</h3>
<div class="paragraph">
<p>Ao longo do curso, os algoritmos serão descritos através de uma linguagem de leitura simples. Contudo, para facilitar a sua interpretação será adotado o estilo do livre formato, quando conveniente.</p>
</div>
<div class="paragraph">
<p>As convenções seguintes serão utilizadas com respeito à linguagem:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>O início e o final de cada bloco são determinados por indentação, isto é, pela posição da margem esquerda. Se uma certa linha do algoritmo inicia um bloco, ele se estende até a última linha seguinte, cuja margem esquerda se localiza mais à direita do que a primeira do bloco;</p>
</li>
<li>
<p>A declaração de atribuição é indicada pelo símbolo <code>:=</code>;</p>
</li>
<li>
<p>As declarações seguintes são empregadas com significado semelhante ao usual:</p>
</li>
</ul>
</div>
<div class="listingblock">
<div class="content">
<pre>se... então
se... então... senão
enquanto... faça
para... faça
pare</pre>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p>Variáveis simples, vetores, matrizes e registro são considerados como tradicionalmente em linguagens de programação. Os elementos de vetores e matrizes são identificados por índices entre colchetes. Por exemplo, <code>A[5]</code> e <code>B[i, 3]</code> indicam, respectivamente, o quinto elemento do vetor <code>A</code> e o elemento identificado pelos índices <code>(i, 3)</code> da matriz <code>B</code>. No caso de registros, a notação <code>T.chave</code> indica o campo chave do registro <code>T</code>;</p>
</li>
<li>
<p>A referência a registros pode ser também realizada por meio de ponteiros, que armazenam endereços, com o uso do símbolo \$uarr\$ ou <code><strong></code>. Cada ponteiro é associado a um único tipo de registro. Por essa razão, o nome de registro pode ser omitido. Por exemplo, pt\$uarr\$.info (ou <code>pt</strong>.info</code>) representa o campo info de um registro alocado no endereço contido em <code>pt</code>;</p>
</li>
<li>
<p>São usados procedimentos e funções. A passagem de parâmetros é feita por referência, isto é, o endereço do parâmetro é transmitido para a rotina. Essa forma de transmissão possibilita a alteração do conteúdo da variável utilizada;</p>
</li>
<li>
<p>A sentença imediatamente posterior ao símbolo <code>%</code> deve ser interpretada como comentário.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Como exemplo, seja uma sequência de elementos armazenada no vetor S[i], com \$1 &lt;= i &lt;= n\$. Deseja-se inverter os elementos da sequência no vetor, isto é, considerá-la de trás para frente. Um algoritmo para resolver esse problema é simples. Basta trocar de posição o primeiro com o último elemento, em seguida o segundo com o antepenúltimo, e assim por diante. A formulação seguinte descreve o processo.</p>
</div>
<div id="inv_sequencia" class="listingblock">
<div class="title">Algoritmo 1. Inversão de uma sequência</div>
<div class="content">
<pre>para i := 1, ..., |__n/2__|
    temp := S[i]
    S[i] := S[n - i + 1]
    S[n - i + 1] := temp</pre>
</div>
</div>
<div class="paragraph">
<p>A notação <code>|<em>x</em>|</code>, ou \$|__x__|\$, que aparece no algoritmo, significa <em>piso de x</em> e representa o maior inteiro menor ou igual a <code>x</code>. Analogamente, <code>|<sub>x</sub>|</code> ou \$|~x~|\$ é o <em>teto de x</em> e corresponde ao menor inteiro maior ou igual a x. Assim, \$|__9/2__|=4\$ e \$|~9/2~|=5\$.</p>
</div>
</div>
<div class="sect2">
<h3 id="recursividade">1.2. Recursividade</h3>
<div class="paragraph">
<p>Um tipo especial de procedimento será utilizado, algumas vezes, ao longo do curso. É aquele que contém, em sua descrição, uma ou mais chamadas a si mesmo. Um procedimento dessa natureza é denominado <em>recursivo</em>, e a chamada a si mesmo é dita <em>chamada recursiva</em>. Naturalmente, todo procedimento, recursivo ou não, deve possuir pelo menos uma chamada proveniente de um local exterior a ele. Essa chamada é denominada <em>externa</em>. Um procedimento não recursivo é, pois, aquele em que todas as chamadas são externas.</p>
</div>
<div class="paragraph">
<p>De modo geral, a todo procedimento recursivo corresponde um outro não recursivo que executa, exatamente, a mesma computação. Contudo, a recursividade pode apresentar vantagens concretas. Frequentemente, os procedimentos recursivos são mais concisos do que um não recursivo correspondente. Além disso, muitas vezes é aparente a relação direta entre um procedimento recursivo e uma prova por indução matemática. Nesses casos, a verificação da correção pode se tornar mais simples. Entretanto, muitas vezes há desvantagens no emprego prático da recursividade. Um algoritmo não recursivo equivalente pode ser mais eficiente.</p>
</div>
<div class="paragraph">
<p>O exemplo clássico mais simples de recursividade é o cálculo do fatorial de um inteiro \$n&gt;=0\$. Um algoritmo recursivo para efetuar esse cálculo encontra-se descrito em seguida. A ideia do algoritmo é muito simples. Basta observar que o fatorial de <em>n</em> é <em>n</em> vezes o fatorial de <em>n - 1</em>, para \$n&gt;0\$. Por convenção, sabe-se que \$0!=1\$. No algoritmo a seguir, chamadas recursivas são representadas pela função \$fat\$. A chamada externa é \$fat(n)\$.</p>
</div>
<div id="fat_recursivo" class="listingblock">
<div class="title">Algoritmo 2. Fatorial (recursivo)</div>
<div class="content">
<pre>função fat(i)
    fat(i) := se i &lt;= 1 então 1 senão i * fat(i - 1)</pre>
</div>
</div>
<div class="paragraph">
<p>Para efeito de comparação, o <a href="#fat_nao_recursivo">Algoritmo 3</a> descreve o cálculo do fatorial de <em>n</em> de forma não recursiva. A variável <em>fat</em> representa, agora, um vetor e não mais uma função. O elemento <em>fat[n]</em> contém, no final, o valor do fatorial desejado.</p>
</div>
<div id="fat_nao_recursivo" class="listingblock">
<div class="title">Algoritmo 3. Fatorial (não recursivo)</div>
<div class="content">
<pre>fat[0] := 1
para j := 1, ..., n faça
    fat[j] := j * fat[j - 1]</pre>
</div>
</div>
<div class="paragraph">
<p>Um exemplo conhecido, onde a solução recursiva é natural e intuitiva, é o do <strong>Problema da Torre de Hanói</strong>. Este consiste em três pinos, A, B e C, denominados origem, destino e trabalho, respectivamente, e n discos de diâmetros diferentes. Inicialmente, todos os discos se encontram empilhados no pino-origem, em ordem decrescente de tamanho, de baixo para cima. O objetivo é empilhar todos os discos no pino-destino, atendendo às seguintes restrições: (i) apenas um disco pode ser movido de cada vez, e (ii) qualquer disco não pode ser jamais colocado sobre outro de tamanho menor.</p>
</div>
<div class="paragraph">
<p>A solução do problema é descrita a seguir. Naturalmente, para \$n&gt;1\$, o pino-trabalho deve ser utilizado como área de armazenamento temporário. O raciocínio utilizado para resolver o problema é semelhante ao de uma prova matemática por indução. Suponha que se saiba como resolver o problema até \$n-1\$ discos, \$n&gt;1\$, de forma recursiva. A extensão para <em>n</em> discos pode ser obtida pela realização dos seguintes passos:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Resolver o problema da Torre de Hanói para os \$n-1\$ discos do topo do pino-origem A, supondo que o pino-destino seja C e o trabalho seja B;</p>
</li>
<li>
<p>Mover o n-ésimo pino (maior de todos) de A para B;</p>
</li>
<li>
<p>Resolver o problema da Torre de Hanói para os \$n-1\$ discos localizados no pino C, suposto origem, considerando os pinos A e B como trabalho e destino, respectivamente.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Ao final desses passos, todos os discos se encontram empilhados no pino B e as duas restrições (i) e (ii) foram satisfeitas. O <a href="#torre_hanoi">Algoritmo 4</a> implementa o processo. O procedimento recursivo <code>hanoi</code> é utilizado com quatro parâmetros n, A, B e C, representando, respectivamente, o número de discos, o pino-origem, o destino e o trabalho.</p>
</div>
<div id="torre_hanoi" class="listingblock">
<div class="title">Algoritmo 4. Torre de Hanói</div>
<div class="content">
<pre>procedimento hanoi(n, A, B, C)
se n &gt; 0 então
    hanoi(n - 1, A, C, B)
    mover o disco do topo de A para B
    hanoi(n - 1, C, B, A)</pre>
</div>
</div>
<div class="paragraph">
<p>A <a href="#img_torre_hanoi">Figura 1</a> ilustra os passos efetuados pelo algoritmo. A chamada externa é <code>hanoi(n, A, B, C)</code>.</p>
</div>
<div id="img_torre_hanoi" class="imageblock">
<div class="content">
<img src="img/hanoi.png" alt="hanoi">
</div>
<div class="title">Figura 1. Problema da Torre de Hanói</div>
</div>
</div>
<div class="sect2">
<h3 id="complexidade_algoritmos">1.3. Complexidade de Algoritmos</h3>
<div class="paragraph">
<p>Conforme já mencionado, uma característica muito importante de qualquer algoritmo é o seu tempo de execução. Naturalmente, é possível determiná-lo através de métodos empíricos, isto é, obter o tempo de execução através da execução propriamente dita do algoritmo, considerando-se entradas diversas.</p>
</div>
<div class="paragraph">
<p>Em contrapartida, é possível obter uma ordem de grandeza do tempo de execução através de métodos analíticos. O objetivo desses métodos é determinar uma expressão matemática que traduza o comportamento de tempo de um algoritmo. Ao contrário do método empírico, o analítico visa aferir o tempo de execução de forma independente do computador utilizado, da linguagem e dos compiladores empregados e das condições locais de processamento.</p>
</div>
<div class="paragraph">
<p>As seguintes simplificações serão introduzidas para o modelo proposto:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Suponha que a quantidade de dados a serem manipulados pelo algoritmo seja suficientemente grande. Isto é, algoritmos cujas entradas consistam em uma quantidade reduzida de dados não serão considerados. Somente o comportamento assintótico será avaliado, ou seja, a expressão matemática fornecerá valores de tempo que serão válidos unicamente quando a quantidade de dados correspondente crescer o suficiente.</p>
</li>
<li>
<p>Não serão consideradas constantes aditivas ou multiplicativas na expressão matemática obtida. Isto é, a expressão matemática obtida será válida, a menos de tais constantes.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>É necessário, ainda, definir a variável em relação à qual a expressão matemática avaliará o tempo de execução. O próprio conceito de algoritmo oferece a sugestão. Um algoritmo opera a partir de uma entrada para produzir uma saída, dentro de um tempo que se deseja avaliar. A ideia é exprimir o tempo de execução em função da entrada.</p>
</div>
<div class="paragraph">
<p>O processo de execução de um algoritmo pode ser dividido em etapas elementares, denominadas <em>passos</em>. Cada passo consiste na execução de um número fixo de operações básicas cujos tempos de execução são considerados constantes. A operação básica de maior frequência de execução do algoritmo é denominada <em>operação dominante</em>. Como a expressão do tempo de execução do algoritmo será obtida a menos de constantes aditivas e multiplicativas, o número de passos de um algoritmo pode ser interpretado como sendo o número de execuções da operação dominante.</p>
</div>
<div class="paragraph">
<p>Por exemplo, em diversos algoritmos para ordenar os elementos de uma sequência dada, cada passo corresponde a uma comparação entre dois elementos da sequência. Na realidade, o número de passos de um algoritmo constitui a informação de que se necessita para avaliar o seu comportamento de tempo. Assim, um algoritmo de um único passo possui tempo de execução constante.</p>
</div>
<div class="paragraph">
<p>Portanto, a expressão matemática a ser definida, do tempo de execução de um algoritmo, pode ser apresentada como uma função que fornece o número de passos efetuados pelo algoritmo a partir de uma entrada.</p>
</div>
<div class="paragraph">
<p>Como exemplo, no <a href="#inv_sequencia">Algoritmo 1</a>, de inversão de sequência, cada entrada é uma sequência que se deseja inverter. O algoritmo efetua exatamente as mesmas operações para sequência de mesmo tamanho <em>n</em>. Cada passo corresponde à troca de posição entre dois elementos da sequência. Ou seja, à execução das três instruções de atribuição dentro do bloco <strong>para</strong> do algoritmo. O número de passos é, pois, igual ao número de execuções do bloco <strong>para</strong>, ou \$|__n/2__|\$, \$n&gt;1\$.</p>
</div>
<div class="paragraph">
<p>Como exemplos adicionais, considere os problemas de determinar as matrizes soma C e produto D de duas matrizes dadas, \$A=(a_ij)\$ e \$B=(b_ij)\$, ambas n x n. Nesse caso, C e D também possuem dimensão n x n e seus elementos \$c_ij\$ e \$d_ij\$ podem ser calculados, respectivamente, por:</p>
</div>
<div class="stemblock">
<div class="content">
\$c_ij=a_ij+b_ij\$<br>
\$d_ij=sum_(1&lt;=&lt;=n)(a_ij)*b_kj\$
</div>
</div>
<div class="paragraph">
<p>O <a href="#soma_matrizes">Algoritmo 5</a> descreve a computação da matriz soma de duas matrizes, enquanto o <a href="#produto_matrizes">Algoritmo 6</a> fornece o produto.</p>
</div>
<div id="soma_matrizes" class="listingblock">
<div class="title">Algoritmo 5. Soma de matrizes</div>
<div class="content">
<pre>para i := 1, ..., n faça
    para j := 1, ..., n faça
        C[i][j] := A[i][j] + B[i][j]</pre>
</div>
</div>
<div id="produto_matrizes" class="listingblock">
<div class="title">Algoritmo 6. Produto de matrizes</div>
<div class="content">
<pre>para i:= 1, ..., n faça
    para j := 1, ..., n faça
        C[i][j] := 0
        para k := 1, ..., n faça
            C[i][j] := C[i][j] + A[i][k] * B[k][j]</pre>
</div>
</div>
<div class="paragraph">
<p>Como no caso do <a href="#inv_sequencia">Algoritmo 1</a>, ambos os algoritmos de soma e produto efetuam as mesmas operações, respectivamente, sempre que A, B forem matrizes de mesma dimensão n x n. A variável independente é o parâmetro <em>n</em>. Cada passo do <a href="#soma_matrizes">Algoritmo 5</a> corresponde à execução de uma soma \$a_ij+b_ij\$, enquanto, no <a href="#produto_matrizes">Algoritmo 6</a>, corresponde ao produto \$a_ik*b_kj\$. O número total de passos é, pois, igual ao número total de somas \$a_ij+b_ij\$ e produtos \$a_ik*b_kj\$, respectivamente, para cada caso. Ou seja, o <a href="#soma_matrizes">Algoritmo 5</a> efetua n² passos, enquanto o <a href="#produto_matrizes">Algoritmo 6</a> efetua n³.</p>
</div>
<div class="paragraph">
<p>A noção de complexidade de tempo é descrita a seguir.</p>
</div>
<div class="paragraph">
<p>Seja A um algoritmo, \${E_1, ..., E_m}\$, o conjunto de todas as entradas possíveis de A. Denote por \$t_i\$ o número de passos efetuados por A, quando a entrada for \$E_i\$. Definem-se, com \$p_i\$ sendo a probabilidade de ocorrência da entrada \$E_i\$:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Complexidade do pior caso: \$max_(E_iinE){t_i}\$;</p>
</li>
<li>
<p>Complexidade do melhor caso: \$min_(E_iinE){t_i}\$;</p>
</li>
<li>
<p>Complexidade do caso médio: \$sum_(1&lt;=i&lt;=m)(p_i*t_i)\$.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>De forma análoga, podem ser definidas complexidades de espaço de um algoritmo.</p>
</div>
<div class="paragraph">
<p>As complexidades têm por objetivo avaliar a eficiência de tempo ou espaço. A complexidade de tempo de pior caso corresponde ao número de passos que o algoritmo efetua no seu pior caso de execução, isto é, para a entrada mais desfavorável. De certa forma, a complexidade de pior caso é a mais importante das três mencionadas. Ela fornece um limite superior para o número de passos que o algoritmo pode efetuar, em qualquer caso. Deste modo, o termo <em>complexidade</em> será empregado com o significado de complexidade de pior caso.</p>
</div>
</div>
<div class="sect2">
<h3 id="notacao_o">1.4. A Notação O</h3>
<div class="paragraph">
<p>Observe que as definições de complexidade da seção anterior implicam o atendimento das duas simplificações mencionadas no início do parágrafo. Em consequência, quando se considera o número de passos efetuados por um algoritmo, podem-se desprezar constantes aditivas ou multiplicativas. Por exemplo, um valor de número de passos igual a 3n será aproximado para n. Além disso, como o interesse é restrito a valores assintóticos, termos de menor grau também podem ser desprezados. Assim, um valor de número de passos igual a \$n^2+n\$ será aproximado para \$n^2\$. O valor \$6n^3 + 4n - 9\$ será transformado em \$n^3\$.</p>
</div>
<div class="paragraph">
<p>Torna-se útil, portanto, descrever operadores matemáticos que sejam capazes de representar situações como essas. As notações O, \$Omega\$ e \$Theta\$ serão utilizadas com essa finalidade.</p>
</div>
<div class="paragraph">
<p>Sejam f, h funções reais positivas de variável inteira n. Diz-se que f é \$O(h)\$, escrevendo-se \$f=O(h)\$, quando existir uma constante \$c&gt;0\$ e um valor inteiro \$n_o\$, tal que:</p>
</div>
<div class="stemblock">
<div class="content">
\$n&gt;n_o=&gt;f(n)&lt;=c*h(n)\$
</div>
</div>
<div class="paragraph">
<p>Ou seja, a função h atua como um limite superior para valores assintóticos da função f. Em seguida são apresentados alguns exemplos da notação O.</p>
</div>
<div class="stemblock">
<div class="content">
\$f=n^2-1=&gt;f=O(n^2)\$<br>
\$f=n^3-1=&gt;f=O(n^3)\$<br>
\$f=403=&gt;f=O(1)\$<br>
\$f=5+2logn+3log^2n=&gt;f=O(log^2n)\$
</div>
</div>
<div class="paragraph">
<p>As seguintes propriedades são úteis para manipular expressões em notação O. Elas decorrem diretamente da definição.</p>
</div>
<div class="paragraph">
<p>Sejam g, h funções reais positivas e k uma constante Então:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>\$O(g+h)=O(g)+O(h)\$;</p>
</li>
<li>
<p>\$O(k*g)=k*O(g)=O(g)\$.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Essas duas propriedades foram empregadas, implicitamente, nos exemplos anteriores.</p>
</div>
<div class="paragraph">
<p>A notação O será utilizada, ao longo deste curso, para exprimir complexidades. Por exemplo, seja determinar as complexidades de pior, melhor e caso médio dos algoritmos já apresentados neste capítulo. Todos eles apresentam a proprieda de o número de passos manter-se o mesmo quando aplicados a entradas diferentes do mesmo tamanho. Ou seja, para um mesmo valor de n o número de passos mantém-se constante. Como a variável independente é o valor n, conclui-se que as complexidades de pior, melhor e caso médio são todas iguais entre si para cada algoritmo. O <a href="#inv_sequencia">Algoritmo 1</a> efetua sempre \$|__n/2__|\$ passos. Logo, a complexidade é O(n). No <a href="#fat_nao_recursivo">Algoritmo 3</a>, o número de passos é igual ao número de produtos \$j*fat(j-1)\$, isto é, n. Sua complexidade, portanto, é O(n). Da mesma forma, verifica-se de imediato que as complexidades do <a href="#soma_matrizes">Algoritmo 5</a> e do <a href="#produto_matrizes">Algoritmo 6</a> são iguais a \$O(n^2)\$ e \$O(n^3)\$, respectivamente.</p>
</div>
<div class="paragraph">
<p>Para encontrar a complexidade de procedimentos recursivos, pode-se aplicar a seguinte técnica. Determina-se o número total de chamadas ao procedimento recursivo. Em seguida, calcula-se a complexidade da execução correspondente a uma única chamada, sem que se considerem as chamadas recursivas encontradas. A complexidade total será o produto do número de chamadas pela complexidade da computação de uma chamada isolada. Por exemplo, para calcular o fatorial de \$n&gt;0\$, de forma recursiva, o <a href="#fat_recursivo">Algoritmo 2</a> efetua um total de <em>n</em> chamadas ao procedimento <em>fat</em>. A complexidade da computação correspondente a uma chamada é constante, isto é, \$O(1)\$. De fato, para \$n&gt;1\$, apenas um produto é efetuado e, quando \$n&lt;=1\$, apenas uma atribuição é executada. Logo, a complexidade final do algoritmo é \$O(n)\$. A complexidade do <a href="#torre_hanoi">Algoritmo 4</a>, para resolver o problema da Torre de Hanói, é \$O(2^pi)\$.</p>
</div>
<div class="paragraph">
<p>A notação \$Theta\$, descrita a seguir, é útil para exprimir limites superiores justos. Sejam f, g funções reais positivas da variável inteira n. Diz-se que f é \$Theta(g)\$, escrevendo-se \$f=Theta(g)\$, quando ambas as condições \$f=O(g)\$ e \$g=O(f)\$ forem verificadas. A notação \$Theta\$ exprime o fato de que duas funções possuem a mesma ordem de grandeza assintótica. Por exemplo, se \$f=n^2-1\$, \$g=n^2\$ e \$h=n^3\$, então f é O(g), f é O(h), mas h não é O(f). Consequentemente, f é \$Theta(g)\$, mas f não é \$Theta(h)\$.</p>
</div>
<div class="paragraph">
<p>Assim como a notação O é útil para descrever limites superiores assintóticos, a notação \$Omega\$, definida a seguir, é empregada para limites inferiores assintóticos.</p>
</div>
<div class="paragraph">
<p>Sejam f, h funções reais positivas da variável inteira <em>n</em>. Diz-se que f é \$Omega(h)\$, escrevendo-se \$f=Omega(h)\$ quando existir uma constante \$c&gt;0\$ e um valor inteiro \$n_o\$ tal que:</p>
</div>
<div class="stemblock">
<div class="content">
\$n&gt;n_o=&gt;f(n)&gt;=c*h(n)\$
</div>
</div>
<div class="paragraph">
<p>Por exemplo, se \$f=n^2-1\$, então são válidas as igualdades \$f=Omega(n^2)\$, \$f=Omega(n)\$ e \$f=Omega(1)\$, mas não vale \$f=Omega(n^3)\$.</p>
</div>
</div>
<div class="sect2">
<h3 id="algoritmos_otimos">1.5. Algoritmos Ótimos</h3>
<div class="paragraph">
<p>A noção de complexidade está relacionada a um dado algoritmo. Ela visa determinar o número de passos efetuados por um algoritmo específico, sem levar em consideração a possível existência de outros algoritmos para o mesmo problema. Essa questão mais abrangente será abordada nessa seção.</p>
</div>
<div class="paragraph">
<p>Seja P um problema. Um <em>limite inferior para P</em> é uma função <em>l</em>, tal que a complexidade de pior caso de qualquer algoritmo que resolva P é \$Omega(l)\$. Isto é, todo algoritmo que resolve P efetua, pelo menos, \$Omega(l)\$ passos. Se existir um algoritmo A, cuja complexidade seja O(l), então A é denominado <strong>algoritmo ótimo</strong> para P. Nesse caso, o limite \$Omega(l)\$ é o melhor (maior) possível.</p>
</div>
<div class="paragraph">
<p>Intuitivamente, um algoritmo ótimo é aquele que apresenta a menor complexidade dentre todos os possíveis algoritmos para resolver o mesmo problema. Assim como a notação O é conveniente para exprimir complexidades, a notação \$Omega\$ é utilizada para limites inferiores.</p>
</div>
<div class="paragraph">
<p>Existem limites inferiores naturais, como, por exemplo, o tamanho da entrada. Todo possível algoritmo para o problema considerado deverá, necessariamente, efetuar a leitura da entrada. Assim, por exemplo, a entrada do <a href="#inv_sequencia">Algoritmo 1</a>,  de inversão de sequência, consiste em uma sequência de n elementos. Qualquer possível algoritmo para inverter a sequência deverá efetuar a sua leitura. Isto é, um limite inferior para o problema de inversão de sequência é \$Omega(n)\$. A complexidade do <a href="#inv_sequencia">Algoritmo 1</a> é O(n). Conclui-se, então, que ele é um algoritmo ótimo.</p>
</div>
<div style="page-break-after: always;"></div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="listas_lineares">2. Listas Lineares</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="introducao">2.1. Introdução</h3>
<div class="paragraph">
<p>Dentre as estruturas de dados não primitivas, as listas lineares são as de manipulação mais simples. Neste capítulo, são discutidos seus algoritmos e estruturas de armazenamento.</p>
</div>
<div class="paragraph">
<p>Uma lista linear agrupa informações referentes a um conjunto de elementos que, de alguma forma, se relacionam entre si. Ela pode se constituir, por exemplo, de informações sobre os funcionários de uma empresa, sobre notas de compras, itens de estoque, notas de alunos, etc. Na realidade, são inúmeros os tipos de dados que podem ser descritos por listas lineares.</p>
</div>
<div class="paragraph">
<p>Uma <em>lista linear</em>, ou <em>tabela</em>, é então um conjunto de \$n&gt;=0\$ nós L[1], L[2], &#8230;&#8203;, L[n] tais que suas propriedades estruturais decorrem, unicamente, da posição relativa dos nós dentro da sequência linear. Tem-se:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Se \$n&gt;0\$, L[1] é o primeiro nó;</p>
</li>
<li>
<p>Para \$1&lt;k&lt;=n\$, o nó L[k] é precedido por L[k - 1].</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>As operações mais frequentes em listas são a <em>busca</em>, a <em>inclusão</em> e a <em>remoção</em> de um determinado elemento, o que, aliás, ocorre na maioria das estruturas de dados. Tais operações podem ser consideradas como básicas e, por essa razão, é necessário que os algoritmos que as implementem sejam eficientes. Outras operações, também importantes, podem ser mencionadas: a alteração de um elemento da lista, a combinação de duas ou mais listas lineares em uma única, a ordenação dos nós segundo determinado campo, a determinação do primeiro (ou do último) nó da lista, a determinação da cardinalidade da lista e muitas outras, dependendo do problema em estudo.</p>
</div>
<div class="paragraph">
<p>Casos particulares de listas são de especial interesse. Se as inserções e remoções são permitidas apenas nas extremidades da lista, ela recebe o nome de <strong>deque</strong> (uma abreviatura do inglês <em>double ended queue</em>). Se as inserções e as remoções são realizadas somente em um extremo, a lista é denominada <strong>pilha</strong>, sendo denominada <strong>fila</strong> no caso em que as inserções são realizadas em um extremo e remoções em outro. Operações referentes a esses casos particulares serão analisadas individualmente.</p>
</div>
<div class="paragraph">
<p>O tipo de armazenamento de uma lista linear pode ser classificado de acordo com a posição relativa (sempre contígua ou não) na memória de dois nós consecutivos na lista. O primeiro caso corresponde à <em>alocação sequencial de memória</em>, enquanto o segundo é conhecido como <em>alocação encadeada</em>. A escolha de um ou outro tipo depende essencialmente das operações que serão executadas sobre a lista, do número de listas envolvidas na operação, bem como das características particulares dessas listas. Nas seções que se seguem, tais alocações e suas características serão discutidas.</p>
</div>
</div>
<div class="sect2">
<h3 id="alocacao_sequencial">2.2. Alocação Sequencial</h3>
<div class="paragraph">
<p>A maneira mais simples de se manter uma lista linear na memória do computador é colocar seus nós em posições contíguas. Nesse caso, o endereço real do (j + 1)-ésimo nó da lista se encontra \$c\$ unidades adiante daquele correspondente ao j-ésimo. A constante \$c\$ é o número de palavras de memória que cada nó ocupa. A correspondência entre o índice da tabela e o endereço real é feita automaticamente pela linguagem de programação quando da tradução do programa.</p>
</div>
<div class="paragraph">
<p>Como a implementação da alocação sequencial em linguagens de alto nível é geralmente realizada com a reserva prévia de memória para cada estrutura utilizada, a inserção e a remoção de nós não ocorrem de fato. Em vez disso utiliza-se algum tipo de simulação para essas operações (por exemplo, variáveis indicando os limites da memória realmente utilizada). Por essa razão, pode-se considerar tal alocação como uma <em>alocação estática</em>.</p>
</div>
<div class="paragraph">
<p>O armazenamento sequencial é particularmente atraente no caso de filas e pilhas porque, nessas estruturas, as operações básicas podem ser implementadas de forma bastante eficiente. Esse tratamento pode, contudo, se tornar oneroso em termos de memória quando se empregam diversas estruturas simultaneamente. Nesse caso, a utilização ou não do armazenamento sequencial dependeria de um estudo cuidadoso das opções existentes.</p>
</div>
<div class="paragraph">
<p>De início serão apresentadas as operações para listas genéricas.</p>
</div>
</div>
<div class="sect2">
<h3 id="listas_aloc_seq">2.3. Listas Lineares em Alocação Sequencial</h3>
<div class="paragraph">
<p>Seja uma lista linear. Cada nó é formado por <em>campos</em>, que armazenam as características distintas dos elementos da lista. Além disso, cada nó da lista possui, geralmente, um identificador, denominado <em>chave</em>. A chave, quando presente, se constitui em um dos campos do nó. Os nós podem se encontrar ordenados, ou não, segundo os valores de suas chaves. No primeiro caso a lista é denominada <em>ordenada</em>, e <em>não ordenada</em> no caso contrário.</p>
</div>
<div class="paragraph">
<p>Suponha uma lista linear, de nome <strong>L</strong>, que possui \$n\$ elementos. Um exemplo da constituição dessa tabela é apresentado na <a href="#exemplo_no">Figura 2</a>.</p>
</div>
<div id="exemplo_no" class="imageblock">
<div class="content">
<img src="img/exemplo_no.png" alt="exemplo no">
</div>
<div class="title">Figura 2. Exemplo de um nó</div>
</div>
<div class="paragraph">
<p>O <a href="#busca_elem_lista">Algoritmo 7</a> apresenta a busca de um nó na lista L, conhecendo-se sua chave. A variável \$x\$ corresponde à chave do nó procurado. A função <code>busca1</code> informa, ao final, o índice do nó que se deseja buscar; se este não for encontrado, o índice é nulo.</p>
</div>
<div id="busca_elem_lista" class="listingblock">
<div class="title">Algoritmo 7. Busca de um elemento na lista L</div>
<div class="content">
<pre>função busca1(x)
    i := 1
    busca1 := 0
    enquanto i &lt;= n faça
        se L[i].chave = x então
            % chave encontrada
            busca1 := i
            i := n + 1
        senão
            % pesquisa prossegue
            i:= i + 1</pre>
</div>
</div>
<div class="paragraph">
<p>Observe que, para cada elemento da tabela referenciado na busca, o algoritmo realiza dois testes: <code>i &#8656; n</code> e <code>L[i].chave = x</code>. Muitas vezes um pequeno artifício pode contribuir para a melhoria do processo. Por exemplo, o <a href="#busca_elem_lista2">Algoritmo 8</a> se propõe a efetuar a mesma busca que o <a href="#busca_elem_lista">Algoritmo 7</a>. A diferença entre os dois é a criação de um novo nó, que possui o valor procurado no campo chave, na posição <code>n + 1</code>. Dessa forma, o algoritmo sempre encontra um nó da tabela com as características desejadas, evitando o teste de fim de tabela.</p>
</div>
<div id="busca_elem_lista2" class="listingblock">
<div class="title">Algoritmo 8. Busca de um elemento na lista L</div>
<div class="content">
<pre>função busca(x)
    L[n + 1].chave := x
    i := 1
    enquanto L[i].chave != x faça
        i := i + 1
    se i != n + 1 então
        % elemento encontrado
        busca := i
    senão
        % elemento não encontrado
        busca := 0</pre>
</div>
</div>
<div class="paragraph">
<p>A complexidade de pior caso do <a href="#busca_elem_lista">Algoritmo 7</a> e do <a href="#busca_elem_lista2">Algoritmo 8</a> é \$O(n)\$. Entretanto, o segundo é de execução mais rápida, pois a cada iteração correspondem dois testes no <a href="#busca_elem_lista">Algoritmo 7</a> e apenas um no <a href="#busca_elem_lista2">Algoritmo 8</a>.</p>
</div>
<div class="paragraph">
<p>Quando a lista está ordenada, pode-se tirar proveito desse fato. Se o número procurado não pertence à lista, não há necessidade de percorrê-la até o final. A exemplo do <a href="#busca_elem_lista2">Algoritmo 8</a>, a dupla comparação no bloco principal do algoritmo também pode ser evitada por meio da criação de um novo nó. O <a href="#busca_elem_lista_ord">Algoritmo 9</a> mostra essa busca.</p>
</div>
<div id="busca_elem_lista_ord" class="listingblock">
<div class="title">Algoritmo 9. Busca de um elemento na lista L, ordenada</div>
<div class="content">
<pre>função busca-ord(x)
    L[n + 1].chave := x
    i := 1
    enquanto L[i].chave &lt; x faça
        i := i + 1
    se i = n + 1 ou L[i].chave != x então
        busca-ord := 0
    senão
        busca-ord := i</pre>
</div>
</div>
<div class="paragraph">
<p>Ainda no caso das listas ordenadas, um algoritmo diverso e bem mais eficiente pode ser apresentado: a <em>busca binária</em>. Em tabelas, o primeiro nó pesquisado é o que se encontra no meio; se a comparação não é positiva, metade da tabela pode ser abandonada na busca, uma vez que o valor procurado se encontra ou na metade inferior (se for menor), ou na metade superior (se for maior). Esse procedimento, aplicado recursivamente, esgota a tabela. O <a href="#busca_binaria">Algoritmo 10</a> apresenta a busca.</p>
</div>
<div id="busca_binaria" class="listingblock">
<div class="title">Algoritmo 10. Busca binária</div>
<div class="content">
<pre>função busca-bin(x)
    inf := 1
    sup := n
    busca-bin := 0
    enquanto inf &lt;= sup faça
        % índice a ser buscado
        meio := |__(inf + sup) / 2__|
        se L[meio].chave = x então
            % elemento encontrado
            busca-bin := meio
            inf := sup + 1
        senão se L[meio].chave &lt; x então
            inf := meio + 1
        senão
            sup := meio - 1</pre>
</div>
</div>
<div class="paragraph">
<p>A complexidade do algoritmo pode ser avaliada da seguinte forma. O pior caso ocorre quando o elemento procurado é o último a ser encontrado, ou mesmo não é encontrado. Na primeira iteração, a dimensão da tabela é <code>n</code>, e algumas operações são realizadas para situar o valor procurado. Na segunda, a dimensão se reduz a \$|__n/2__|\$, e assim sucessivamente. Ora, ao final, a dimensão da tabela é 1 (observe o teste <code>inf &#8656; sup</code>). Então, no pior caso:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>1ª iteração: a dimensão da tabela é <code>n</code>;</p>
</li>
<li>
<p>2ª iteração: a dimensão da tabela é <code>|<em>n / 2</em>|</code>;</p>
</li>
<li>
<p>3ª iteração: a dimensão da tabela é <code>|<em>(|</em>n / 2<em>|) / 2</em>|</code>;
&#8230;&#8203;</p>
</li>
<li>
<p>mª iteração: a dimensão da tabela é 1.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Ou seja, o número de iterações é, no máximo, \$1+|__log_2n__|\$. O tempo consumido pelas operações em cada iteração é constante. Logo, a complexidade da busca binária é \$O(logn)\$.</p>
</div>
<div class="paragraph">
<p>Ambas as operações de inserção e remoção utilizam o procedimento de busca. No primeiro caso, o objetivo é evitar chaves repetidas e, no segundo, a necessidade de localizar o elemento a ser removido. A construção desses algoritmos implica tarefas complementares, uma vez que a ação de um é o inverso da ação do outro. A implementação dessas operações deve, naturalmente, respeitar tal fato.</p>
</div>
<div class="paragraph">
<p>O <a href="#insercao_no">Algoritmo 11</a> apresenta a inserção de um nó contido na variável <code>novo</code> de chave <code>x</code>. O <a href="#remocao_no">Algoritmo 12</a> efetua a remoção de um nó sendo conhecido um de seus campos, no caso a chave <code>x</code>. Ambos os algoritmos consideram tabelas não ordenadas. A memória pressuposta disponível tem <code>M</code> posições (na realidade <code>M + 1</code>, porque é necessária uma posição extra para o procedimento de busca). Devem-se levar em conta as hipóteses de se tentar fazer inserções numa lista que já ocupa <code>M</code> posições (situação conhecida como <em>overflow</em>), bem como a tentativa de remoção de um elemento de uma lista vazia (<em>underflow</em>). A atitude a ser tomada em cada um desses casos depende do problema tratado. Por essa razão, os procedimentos de <em>overflow</em> e <em>underflow</em> são apenas indicados.</p>
</div>
<div class="paragraph">
<p>Como pode ser observado, o procedimento de inserção propriamente dito é bem simples, porém depende da busca que tem complexidade de \$O(n)\$. O algoritmo de remoção, além da busca, em geral efetua movimentação de nós, o que o torna ainda mais lento, se bem que também de complexidade \$O(n)\$.</p>
</div>
<div id="insercao_no" class="listingblock">
<div class="title">Algoritmo 11. Inserção de um nó na lista L</div>
<div class="content">
<pre>se n &lt; M então
    se busca(x) = 0 então
        L[n + 1] := novo-valor
        n := n + 1
    senão
        "elemento já existe na tabela"
senão
    "overflow"</pre>
</div>
</div>
<div id="remocao_no" class="listingblock">
<div class="title">Algoritmo 12. Remoção de um nó na lista L</div>
<div class="content">
<pre>se n != 0 então
    indice := busca(x)
    se indice != 0 então
        valor-recuperado := L[indice]
        para i := indice, n - 1 faça
            L[i] := L[i + 1]
        n := n - 1
    senão "elemento não se encontra na tabela"
senão
    "underflow"</pre>
</div>
</div>
<div class="paragraph">
<p>No caso de tabelas ordenadas, o algoritmo de remoção não se modifica. O algoritmo de inserção, entretanto, precisa ser refeito, uma vez que, nesse caso, a posição do nó se torna relevante. Isso implica movimentar parte da tabela, para permitir a inserção na posição correta, de maneira análoga à efetuada na remoção em listas não ordenadas (<a href="#remocao_no">Algoritmo 12</a>). A complexidade de ambos os algoritmos (inserção e remoção) é, então, O(n).</p>
</div>
<div class="paragraph">
<p>Observe que a utilização da busca binária diminui a complexidade da busca, mas não a da inserção ou da remoção. A complexidade dessas últimas operações é determinada pela movimentação dos nós.</p>
</div>
</div>
<div class="sect2">
<h3 id="pilhas_filas">2.4. Pilhas e Filas</h3>
<div class="paragraph">
<p>Em geral, o armazenamento sequencial de listas é empregado quando as estruturas, ao longo do tempo, sofrem poucas remoções e inserções. Em caso particulares de listas, esse armazenamento também é empregado. Nesse caso, a situação favorável é aquela em que inserções e remoções não acarretam movimentação de nós, o que ocorre se os elementos a serem inseridos e removidos estão em posições especiais, como a primeira ou a última posição. Deques, pilhas e filas satisfazem tais condições.</p>
</div>
<div class="paragraph">
<p>Na alocação sequencial de listas genéricas, considera-se sempre a primeira posição da lista no endereço 1 da memória disponível. Uma alternativa a essa estratégia consiste na utilização de indicadores especiais, denominados <em>ponteiros</em>, para o acesso a posições selecionadas. No caso da pilha, apenas um ponteiro precisa ser considerado, o ponteiro <em>topo</em>, pois as inserções e remoções são executadas na mesma estremidade da lista. A <a href="#operacoes_pilha">Figura 3</a> mostra uma sequência de operações realizadas numa pilha e o resultado de tais operações no ponteiro <em>topo</em>. Em seguida, o <a href="#insercao_pilha">Algoritmo 13</a> e o <a href="#remocao_pilha">Algoritmo 14</a> implementam a inserção e a remoção em uma pilha P, considerando-se a memória disponível de <code>M</code> posições. Os algoritmos levam em consideração as hipóteses de <em>overflow</em> e <em>underflow</em>. A pilha vazia tem <em>topo</em> nulo.</p>
</div>
<div id="operacoes_pilha" class="imageblock">
<div class="content">
<img src="img/operacoes_pilha.png" alt="operacoes pilha">
</div>
<div class="title">Figura 3. Operações em uma pilha</div>
</div>
<div id="insercao_pilha" class="listingblock">
<div class="title">Algoritmo 13. Inserção na pilha P</div>
<div class="content">
<pre>se topo != M então
    topo := topo + 1
    P[topo] := novo-valor
senão
    "overflow"</pre>
</div>
</div>
<div id="remocao_pilha" class="listingblock">
<div class="title">Algoritmo 14. Remoção da pilha P</div>
<div class="content">
<pre>Se topo != 0 então
    valor-recuperado := P[topo]
    topo := topo - 1
senão
    "underflow"</pre>
</div>
</div>
<div class="paragraph">
<p>A complexidade das operações apresentadas é constante, \$O(1)\$.</p>
</div>
<div class="paragraph">
<p>As filas exigem uma implementação um pouco mais elaborada. São necessários dois ponteiros:início de fila (<code>f</code>) e retaguarda (<code>r</code>). Para a adição de um elemento, move-se o ponteiro <code>r</code>; para a retirada, move-se o ponteiro <code>f</code>. A situação da fila vazia é representada por <code>f = r = 0</code>. Observe, na <a href="#operacoes_fila">Figura 4</a>, algumas operações realizadas em uma fila F.</p>
</div>
<div class="paragraph">
<p>Note que, após qualquer operação, deve-se sempre ter o ponteiro <code>f</code> indicando o início da fila, e <code>r</code>, a retaguarda. Isso implica, como já foi dito, movimentar o ponteiro <code>r</code> quando de uma inserção e o ponteiro <code>f</code> quando de uma remoção. Ora, pode-se observar na <a href="#operacoes_fila">Figura 4</a> que, à medida que os ponteiros são incrementados na memória disponível, a fila "se move", o que pode dar origem à false impressão de memória esgotada. Para eliminar esse problema, consideram-se os <code>M</code> nós alocados como se estivessem em círculo, onde <code>F[1]</code> segue <code>F[M]</code>. No algoritmo de inserção, a variável <code>prov</code> armazena provisoriamente a posição de memória calculada de forma a respeitar a circularidade, só sendo movimentado o ponteiro <code>r</code> se a operação for possível. A inicialização dos ponteiros <code>f</code> e <code>r</code> é <code>f = r = 0</code>.</p>
</div>
<div id="operacoes_fila" class="imageblock">
<div class="content">
<img src="img/operacoes_fila.png" alt="operacoes fila">
</div>
<div class="title">Figura 4. Operações em uma fila</div>
</div>
<div id="insercao_fila" class="listingblock">
<div class="title">Algoritmo 15. Inserção na fila F</div>
<div class="content">
<pre>prov := r mod M + 1
se prov != f então
    r := prov
    F[r] := novo-valor
    se f = 0 então
        f := 1
senão
    "overflow"</pre>
</div>
</div>
<div id="remocao_fila" class="listingblock">
<div class="title">Algoritmo 16. Remoção da fila F</div>
<div class="content">
<pre>se f != 0 então
    valor-recuperado := F[f]
    se f = r então
        f := 0
        r := 0
    senão
        f := f mod M + 1
senão
    "underflow"</pre>
</div>
</div>
<div class="paragraph">
<p>Também nesse caso a complexidade das operações é constante.</p>
</div>
</div>
<div class="sect2">
<h3 id="alocacao_encadeada">2.5. Alocação encadeada</h3>
<div class="paragraph">
<p>Já foi observado que o desempenho dos algoritmos que implementam operações realizadas em listas com alocação sequencial, mesmo sendo estes muito simples, pode ser bastante fraco. E mais, quando está prevista a utilização concomitante de mais de duas listas a gerência de memória se torna mais complexa. Nesses casos se justifica a utilização da alocação encadeada, também conhecida por alocação dinâmica, uma vez que posições de memórias são alocadas (ou desalocadas) na medida em que são necessárias (ou dispensadas). Os nós de uma lista encontram-se então aleatoriamente dispostos na memória e são interligados por ponteiros, que indicam a posição do próximo elemento da tabela. É necessário o acréscimo de um campo a cada nó, justamente o que indica o endereço do próximo nó da lista. A <a href="#aloc_seq_enc">Figura 5</a> apresenta uma lista linear em suas representações sequencial e encadeada.</p>
</div>
<div id="aloc_seq_enc" class="imageblock">
<div class="content">
<img src="img/aloc_seq_enc.png" alt="aloc seq enc">
</div>
<div class="title">Figura 5. Alocação sequencial e alocação encadeada</div>
</div>
<div class="paragraph">
<p>Há vantagens e desvantagens associadas a cada tipo de alocação. Estas, entretanto, só podem ser precisamente medidas ao se conhecerem as operações envolvidas na aplicação desejada. De maneira geral pode-se afirmar que a alocação encadeada, a despeito de um gasto de memória maior em virtude da necessidade de um novo campo no nó (o campo do ponteiro), é mais conveniente quando o problema inclui o tratamento de mais de uma lista. Isso se aplica tanto à gerência do armazenamento quanto às operações propriamente ditas envolvidas, como juntar listas, separar listas em sublistas, etc. Por outro lado, o acesso ao k-ésimo elemento da lista é imediato na alocação sequencial, enquanto na alocação encadeada obriga ao percurso na lista até o elemento desejado.</p>
</div>
<div class="paragraph">
<p>Como já foi visto, na alocação encadeada os nós de uma lista se encontram em posições não obrigatoriamente contíguas de memória. Se nessa lista são feitas inserções e remoções, há necessidade de encontrar novas posições de memória para armazenamento e liberar outras que possam ser reutilizadas posteriormente. Um algoritmo para gerenciar as posições de memória disponíveis é então imprescindível. Para tal é criada uma lista especial, chamada <strong>Lista de Espaço Disponível (LED)</strong>, que contém posições de memória ainda não utilizadas ou dispensadas após sua utilização. Note que a organização dessas posições disponíveis independe completamente da estrutura empregada na solução do problema em estudo. Entretanto, deve-se observar que a LED e as estruturas estão compartilhando a memória disponível.</p>
</div>
<div class="paragraph">
<p>As linguagens de progrmação geralmente possuem um módulo de gerência de memória disponível ao usuário, bastanto apenas que este se refira às rotinas internas de ocupação e devolução de nós da lista de espaço disponível. Em Pascal, por exemplo, as rotinas <code>new(pt)</code> e <code>dispose(pt)</code> executam essa tarefa. Nesse caso, uma notação diferente é utilizada nos algoritmos. Obviamente o nó na memória é o mesmo considerado até agora; a indicação do endereço desse nó, feita por um ponteiro, é que será representada pelo símbolo \$uarr\$ ou <code>*</code>. Cada ponteiro utilizado é associado a um único tipo de nó. Assim, por exemplo, <code>pt*.info</code> representa o campo <code>info</code> do nó apontado por <code>pt</code>. Um conjunto de nós encadeados forma uma tabela. A associação do ponteiro <code>pt</code> ao tipo de nó é definida previamente na declaração das variáveis.</p>
</div>
</div>
<div class="sect2">
<h3 id="listas_lin_aloc_enc">2.6. Listas Lineares em Alocação Encadeada</h3>
<div class="sect3">
<h4 id="listas_sim_enc">2.6.1. Listas simplesmente encadeadas</h4>
<div class="paragraph">
<p>Qualquer estrutura, inclusive listas, que seja armazenada em alocação encadeada requer o uso de um ponteiro que indique o endereço de seu primeiro nó. O percurso de uma lista é feito então a partir desse ponteiro. A ideia consiste em seguir consecutivamente pelos endereços existentes no campo que indica o próximo nó, da mesma forma que na alocação sequencial se acrescentava uma unidade ao índice do percurso. O <a href="#imp_lista">Algoritmo 17</a> apresenta o percurso para impressão do campo <code>info</code> de uma lista, sendo <code>ptlista</code> o ponteiro para o primeiro nó.</p>
</div>
<div id="imp_lista" class="listingblock">
<div class="title">Algoritmo 17. Impressão da lista apontada por ptlista</div>
<div class="content">
<pre>pont := ptlista
enquanto pont != lambda faça
    imprimir(pont*.info)
    pont := pont*.prox</pre>
</div>
</div>
<div class="paragraph">
<p>Como já foi mencionado na seção <a href="#listas_aloc_seq">Section 2.3</a>, o algoritmo de busca, por ser utilizado em inserções, remoções e outras operações, deve ser muito eficiente. Na alocação encadeada, essa necessidade persiste. E mais, surgem novos problemas: por exemplo, a existência de um ponteiro indicando o primeiro nó da lista obriga os algoritmos de inserção e remoção a apresentarem testes especiais para verificar se o nó desejado é o primeiro da lista. Isto pode ser resolvido por uma pequena variação na estrutura de armazenamento: a criação de um nó especial, chamado <em>nó-cabeça</em>, nunca removido, que passa a ser o nó indicado pelo ponteiro de início de lista. Esse nó especial não deve conter informações relacionadas à tabela propriamente dita. Algumas vezes, entretanto, pode ser aproveitado para conter dados pertinentes ao algoritmo implementado. A <a href="#no_cabeca">Figura 6</a> mostra a representação gráfica da lista encadeada com nó-cabeça, em sua situação inicial (vazia), e depois de algumas inserções.</p>
</div>
<div id="no_cabeca" class="imageblock">
<div class="content">
<img src="img/lista_enc_no_cabeca.png" alt="lista enc no cabeca">
</div>
<div class="title">Figura 6. Lista encadeada com nó cabeça</div>
</div>
<div class="paragraph">
<p>O <a href="#busca_enc">Algoritmo 18</a> implementa a busca em uma tabela ordenada, em alocação encadeada, de maneira simples. No caso aqui considerado, o nó-cabeça da tabela é apontado por <code>ptlista</code>. O parâmetro <code>x</code> fornece a chave procurada. O parâmetro <code>pont</code> retorna apontando para o elemento procurado, e <code>ant</code> para o elemento anterior ao procurado. Caso este não seja encontrado, <code>pont</code> aponta para <code>lambda</code> e <code>ant</code> indica ainda o elemento anterior ao último pesquisado. Deve-se notar que o parâmetro <code>ant</code>, apesar de aparentemente inútil, é importante para os algoritmos de inserção e remoção, que serão vistos a seguir. Como o algoritmo estabelece um percurso pela tabela, sua complexidade é \$O(n)\$, sendo <code>n</code> o número de nós da lista.</p>
</div>
<div id="busca_enc" class="listingblock">
<div class="title">Algoritmo 18. Busca em uma lista ordenada</div>
<div class="content">
<pre>procedimento busca-enc(x, ant, pont)
    ant := ptlista
    pont := lambda
    % ponteiro de percurso
    ptr := ptlista*.prox
    enquanto ptr != lambda faça
        se ptr*.chave &lt; x então
            % atualiza ant e ptr
            ant := ptr
            ptr := ptr*.prox
        senão se ptr*.chave = x então
            % chave encontrada
            pont := ptr
            ptr := lambda</pre>
</div>
</div>
<div class="paragraph">
<p>Após a realização da busca, as operações de inserção e remoção em uma lista encadeada são triviais. Há três fases a serem cumpridas: a comunicação com a LED, o acesso ao campo de informações do nó e o acerto de estrutura. As operações de inserção e remoção realizam essas fases em ordem inversa. A <a href="#insercao_enc">Figura 7</a> e o <a href="#insercao_enc_alg">Algoritmo 19</a> mostram a inserção do nó contido na variável <code>novo</code>, após o nó apontado por <code>ant</code>. No algoritmo, as três fases se encontram assinaladas pelos comentários.</p>
</div>
<div id="insercao_enc" class="imageblock">
<div class="content">
<img src="img/insercao_enc.png" alt="insercao enc">
</div>
<div class="title">Figura 7. Inserção de um nó</div>
</div>
<div id="insercao_enc_alg" class="listingblock">
<div class="title">Algoritmo 19. Inserção de um nó após o nó apontado por busca-enc(x, ant, pont)</div>
<div class="content">
<pre>se pont = lambda então
    % solicitar nó
    ocupar(pt)
    % inicializar nó
    pt*.info := novo-valor
    % acertar lista
    pt*.chave := x
    pt*.prox := ant*.prox
    ant*.prox := pt
senão
    "elemento já está na tabela"</pre>
</div>
</div>
<div class="paragraph">
<p>A remoção do nó apontado por <code>pont</code> é apresentado na <a href="#remocao_enc">Figura 8</a> e no <a href="#remocao_enc_alg">Algoritmo 20</a>. Observe as fases mencionadas nos comentários do algoritmo. A complexidade dessas operações é, em virtude da busca, \$O(n)\$.</p>
</div>
<div id="remocao_enc" class="imageblock">
<div class="content">
<img src="img/remocao_enc.png" alt="remocao enc">
</div>
<div class="title">Figura 8. Remoção de um nó</div>
</div>
<div id="remocao_enc_alg" class="listingblock">
<div class="title">Algoritmo 20. Remoção do nó apontado por pont na lista</div>
<div class="content">
<pre>busca-enc(x, ant, pont)
se pont != lambda então
    % acertar lista
    ant*.prox := pont*.prox
    % utilizar nó
    valor-recuperado := pont*.info
    % devolver nó
    desocupar(pont)
senão
    "nó não se encontra na tabela"</pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="pilhas_filas_aloc_enc">2.6.2. Pilhas e Filas</h4>
<div class="paragraph">
<p>Como casos particulares, algumas modificações são necessárias para implementar operações eficientes em pilhas e filas. No caso de pilhas, as operações são muito simples. Considerando-se listas simplesmente encadeadas (sem nó-cabeça), o topo da pilha é o primeiro nó da lista, apontado por uma variável ponteiro <code>topo</code>. Se a pilha estiver vazia então <code>topo = lambda</code>. Filas exigem duas variáveis do tipo ponteiro: <code>inicio</code>, que aponta para o primeiro nó da lista, e <code>fim</code>, que aponta para o último. Na fila vazia, ambos apontam para \$lambda\$. Os algoritmos que se seguem implementam essas operações.</p>
</div>
<div id="insercao_pilha_enc" class="listingblock">
<div class="title">Algoritmo 21. Inserção na pilha</div>
<div class="content">
<pre>% solicitar nó
ocupar(pt)
% inicializar nó
pt*.info := novo-valor
pt*.prox := topo
% acertar pilha
topo := pt</pre>
</div>
</div>
<div id="remocao_pilha_enc" class="listingblock">
<div class="title">Algoritmo 22. Remoção da pilha</div>
<div class="content">
<pre>se topo != lambda então
    % acertar pilha
    pt := topo
    topo := topo*.prox
    % utilizar nó
    valor-recuperado := pt*.info
    % devolver nó
    desocupar(pt)
senão
    "underflow"</pre>
</div>
</div>
<div id="insercao_fila_enc" class="listingblock">
<div class="title">Algoritmo 23. Inserção na fila</div>
<div class="content">
<pre>% solicitar nó
ocupar(pt)
% inicializar nó
pt*.info := novo-valor
pt*.prox := lambda
% acertar fila
se fim != lambda então
    fim*.prox := pt
senão inicio := pt
fim := pt</pre>
</div>
</div>
<div id="remocao_fila_enc" class="listingblock">
<div class="title">Algoritmo 24. Remoção da fila</div>
<div class="content">
<pre>se inicio != lambda então
    pt := inicio
    % acertar fila
    inicio := inicio*.prox
    se inicio = lambda então
        fim := lambda
    % utilizar nó
    valor-recuperado := pt*.info
    % devolver nó
    desocupar(pt)
senão
    "underflow"</pre>
</div>
</div>
<div class="paragraph">
<p>As complexidades dos algoritmos de manipulação de filas e pilhas são constantes, ou seja, \$O(1)\$, uma vez que buscas não são empregadas.</p>
</div>
<div style="page-break-after: always;"></div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="arvores">3. Árvores</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_introdução">3.1. Introdução</h3>
<div class="paragraph">
<p>Em diversas aplicações necessita-se de estruturas mais complexas do que as puramente sequenciais, examinadas no capítulo anterior. Entre essas, destacam-se as árvores, por existirem inúmeros problemas práticos que podem ser modelados através delas. Além disso, as árvores, em geral, admitem um tratamento computacional simples e eficiente. Isso não pode ser dito de estruturas mais gerais do que as árvores, como os grafos, por exemplo.</p>
</div>
<div class="paragraph">
<p>Neste capítulo são apresentados os conceitos iniciais relativos às árvores, bem como os algoritmos para sua manipulação computacional básica.</p>
</div>
</div>
<div class="sect2">
<h3 id="_definições_e_representações_básicas">3.2. Definições e representações básicas</h3>
<div class="paragraph">
<p>Uma <strong>árvore enraizada T</strong>, ou simplesmente <strong>árvore</strong>, é um conjunto finito de elementos denominados <em>nós</em> ou <em>vértices</em> tais que:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>\$T=O/\$, e a árvore é dita <em>vazia</em>; ou</p>
</li>
<li>
<p>Existe um nó especial chamado <em>raiz</em> de \$T(r(T))\$; os restantes constituem um único conjunto vazio ou são divididos em \$m&gt;=1\$ conjuntos disjuntos não vazios, as subárvores de \$r(T)\$, ou simplesmente <strong>subárvores</strong>, cada qual, por sua vez, uma árvore.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Uma floresta é um conjunto de árvores. Se <em>v</em> é um nó de <em>T</em>, a notação \$T(v)\$ indica a subárvore de <em>T</em> com raiz <em>v</em>.</p>
</div>
<div class="paragraph">
<p>Para visualizar esse conceito, pode-se representá-lo graficamente. Há formas diferentes de representações gráficas de uma árvore. Em todas elas cada nó poderá ser associado a um identificador, denominado <em>rótulo</em>. Observa-se, contudo, que o estudo das árvores pode prescindir do uso desse identificador e basear-se unicamente na posição relativa de seus nós na estrutura.</p>
</div>
<div class="paragraph">
<p>A representação mais próxima da definição é o diagrama de inclusão, apresentado na <a href="#diagrama_inclusao">Figura 9</a>, representação tradicionalmente utilizada para conjuntos. Na figura, a raiz de T é o nó A, o qual possui duas subárvores: a formada pelo único nó B e aquela cuja raiz é C e que contém todos os demais nós, e assim por diante. Os rótulos dos nós são A, B, &#8230;&#8203;, H, respectivamente.</p>
</div>
<div id="diagrama_inclusao" class="imageblock">
<div class="content">
<img src="img/diagrama_inclusao.png" alt="diagrama inclusao">
</div>
<div class="title">Figura 9. Diagrama de inclusão</div>
</div>
<div class="paragraph">
<p>A forma mais comum de representar graficamente uma árvore é através de sua representação hierárquica, semelhante à utilizada para descrever organogramas de uma empresa. A <a href="#representacoes_hierárquicas">[representacoes_hierárquicas]</a>, figura (a), ilustra uma tal representação que descreve a mesma árvore da <a href="#diagrama_inclusao">Figura 9</a>. Nessa representação existe uma linha unindo cada nó às raízes de suas subárvores, quando não vazias, as quais se encontram sempre abaixo (acima) desse nó. Conforme a escolha dessa posição, abaixo ou acima, tem-se as representações da <a href="#representacoes_hierarquicas">Figura 10</a>. A representação herárquica é, de longe, a mais utilizada para visualizar uma árvore, pela forma clara como exibe as relações existentes entre os nós da estrutura. Além disso, do ponto de vista computacional, essa representação já sugere uma forma adequada de dispor os dados no computador, como se verá mais adiante.</p>
</div>
<div id="representacoes_hierarquicas" class="imageblock">
<div class="content">
<img src="img/representacoes_hierarquicas.png" alt="representacoes hierarquicas">
</div>
<div class="title">Figura 10. Representações hierárquicas</div>
</div>
<div class="paragraph">
<p>Seja v o nó raiz da subárvore T(v) de T. Os nós raízes w1, w2, &#8230;&#8203;, wj das subárvores de T(v) são chamados filhos de v; v é chamado pai de w1, w2, &#8230;&#8203;, wj. Os nós w1, w2, &#8230;&#8203;, wj são irmãos. Se z é filho de w1, então w2 é tio de z e v é avô de z. O número de filhos de um nó é chamado de grau de saída desse nó. Se x pertence à subárvore T(v), x é descendente de v, e v é ancestral de x. Nesse caso, sendo x diferente de v, x é descendente próprio de v, e v é ancestral próprio de x.</p>
</div>
<div class="paragraph">
<p>Um nó que não possui descendentes próprios é chamado de folha. Toda árvore com \$n&gt;1\$ nós possui no mínimo 1 e no máximo \$n-1\$ folhas. Um nó não folha é dito interior.</p>
</div>
<div class="paragraph">
<p>Uma sequência de nós distintos v1, v2, &#8230;&#8203;, vk, tal que existe sempre entre nós consecutivos (v1 e v2, v2 e v3, &#8230;&#8203;, vk-1 e vk) a relação "é filho de" ou "é pai de", é denominada caminho da árvore. Diz-se que v1 alcança vk e vice-versa. Um caminho de k vértices é obtido pela sequência de \$k-1\$ pares da relação. O valor \$k-1\$ é o comprimento do caminho. Nível de um nó v é o número de nós do caminho da raiz até o nó v. O nível da raiz é, portanto, igual a 1. A altura de um nó v é o número de nós do maior caminho de v até um de seus descendentes. As folhas têm altura 1. A altura da árvore T é igual ao nível máximo de seus nós. Representa-se a altura de T por h(T), enquanto h(v) é a altura da subárvore de raiz v.</p>
</div>
<div class="paragraph">
<p>Uma árvore ordenada é aquela na qual os filhos de cada nó estão ordenados. Assume-se que tal ordenação se desenvolva da esquerda para a direita. Assim, as árvores da figura <a href="#isomorfismo">Figura 11</a> são distintas se consideradas como ordenadas. Contudo, elas podem se tornar coincidentes mediante uma reordenação de nós irmãos.</p>
</div>
<div id="isomorfismo" class="imageblock">
<div class="content">
<img src="img/isomorfismo.png" alt="isomorfismo">
</div>
<div class="title">Figura 11. Exemplo de isomorfismo</div>
</div>
<div class="paragraph">
<p>De modo geral, duas árvores não ordenadas são isomorfas quando puderem se tornar coincidentes através de uma permutação na ordem das subárvores de seus nós. As árvores da <a href="#isomorfismo">Figura 11</a> são, então, isomorfas. Por outro lado, duas árvores ordenadas são isomorfas quando forem coincidentes, segundo a ordenação existente entre os seus nós.</p>
</div>
</div>
<div class="sect2">
<h3 id="_árvores_binárias">3.3. Árvores binárias</h3>
<div class="paragraph">
<p>Conforme já mencionado, as árvores constituem as estruturas não sequenciais com maior aplicação em computação. Dentre as árvores, as binárias são, sem dúvida, as mais comuns.</p>
</div>
<div class="paragraph">
<p>Uma <em>árvore binária T</em> é um conjunto finito de elementos denominados nós ou vértices, tal que:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>\$T=O/\$, e a árvore é dita <em>vazia</em>; ou</p>
</li>
<li>
<p>Existe um nó especial chamado <em>raiz</em> de \$T(r(T))\$; e os restantes podem ser divididos em dois subconjuntos disjuntos, \$T_E(r(T))\$ e \$T_D(r(T))\$, a subárvore esquerda e a direita da raiz, respectivamente, as quais são também árvores binárias.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>A raiz da subárvore esquerda (direita) de um nó v, se existir, é denominada filho esquerdo (direito) de v. Naturalmente, o esquerdo pode existir sem o direito e vice-versa. Analogamente à seção anterior, a notação T(v) indica a (sub) árvore binária, cuja raiz é v e cujas subárvores esquerda e direita de T são \$T_E(v)\$ e \$T_D(v)\$, respectivamente.</p>
</div>
<div class="paragraph">
<p>A <a href="#arvore_binaria_a">Figura 12</a> ilustra um exemplo de árvore binária T. O nó A é raiz de T, enquanto \$T_E(A)\$ e \$T_D(A)\$ são as árvores binárias de T com raízes em B e C, respectivamente. O filho esquerdo de A é o nó B e o direito é C. O nó B possui D como filho esquerdo, mas não possui filho direito.</p>
</div>
<div id="arvore_binaria_a" class="imageblock">
<div class="content">
<img src="img/arvore_binaria_a.png" alt="arvore binaria a">
</div>
<div class="title">Figura 12. Árvore binária</div>
</div>
<div id="arvore_binaria_b" class="imageblock">
<div class="content">
<img src="img/arvore_binaria_b.png" alt="arvore binaria b">
</div>
<div class="title">Figura 13. Árvore binária</div>
</div>
<div class="paragraph">
<p>Observando atentamente as definições apresentadas, verifica-se que a árvore binária não obedece rigidamente à definição de árvore. Por exemplo, uma árvore binária pode ter duas subárvores vazias (a esquerda e a direita), enquando o mesmo não ocorre com árvores gerais. Devem-se, portanto, considerar árvores binárias como uma extensão do caso geral. Observe as figuras anteriores. As estruturas são idênticas (isomorfas) se consideradas como árvores, mesmo se forem ordenadas, porém são distintas como árvores binárias.</p>
</div>
<div class="paragraph">
<p>Toda árvore binária com n nós possui exatamente \$n+1\$ subárvores vazias entre suas subárvores esquerdas e direitas. Por exemplo, a árvore da <a href="#arvore_binaria_a">Figura 12</a> possui 9 nós e 10 subárvores vazias: as subárvores esquerda e direita dos nós F, G, H, I e as subárvores direitas de B e D.</p>
</div>
<div class="paragraph">
<p>Em seguida, são introduzidos alguns tipos especiais de árvores binárias, bastante utilizadas, e que serão mencionadas nos próximos capítulos.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Uma <em>árvore estritamente binária</em> é uma árvore binária em que cada nó possui 0 ou 2 filhos;</p>
</li>
<li>
<p>Uma <em>árvore binária completa</em> é aquela que apresenta a seguinte propriedade: se v é um nó tal que alguma subárvore de v é vazia, então v se localiza ou no último (maior) ou no penúltimo nível da árvore;</p>
</li>
<li>
<p>Uma <em>árvore binária cheia</em> é aquela em que, se v é um nó com alguma de suas subárvores vazias, então v se localiza no último nível. Segue-se que toda árvore binária cheia é completa e estritamente binária.</p>
</li>
</ul>
</div>
<div id="exemplos_arvores" class="imageblock">
<div class="content">
<img src="img/exemplos_arvores.png" alt="exemplos arvores">
</div>
<div class="title">Figura 14. Árvores estritamente binária (esq.), binária completa (meio) e cheia</div>
</div>
<div class="paragraph">
<p>A relação entre a altura de uma árvore binária e o seu número de nós é um dado importante para várias aplicações. Para um valor fixo de n, indagar-se-ia quais são as árvore binárias que possuem altura h máxima e mínima. A resposta ao primeiro problema é imediata. A árvore binária que possui altura máxima é aquela cujos nós interiores possuem exatamente uma subárvore vazia. Essas árvores são denominadas <em>zigue-zague</em> e encontram-se ilustradas na <a href="#zigue-zague">Figura 15</a>. Naturalmente, a altura de uma árvore zigue-zague é igual a n. Por outro lado, uma árvore completa sempre apresenta altura mínima, conforme é visto a seguir.</p>
</div>
<div id="zigue-zague" class="imageblock">
<div class="content">
<img src="img/zigue-zague.png" alt="zigue zague">
</div>
<div class="title">Figura 15. Árvores zigue-zague</div>
</div>
<div class="sect3">
<h4 id="_altura_de_árvores_binárias_completas">3.3.1. Altura de árvores binárias completas</h4>
<div class="paragraph">
<p>Seja T uma árvore binária completa com \$n&gt;0\$ nós. Então T possui altura h mínima. Além disso, \$h=1+|__logn__|\$.</p>
</div>
<div class="paragraph">
<p><strong>Demonstração:</strong> Seja T' uma árvore binária de alturma mínima com n nós. Se T' é também completa, então T e T' possuem a mesma altura, isto é, T possui altura mínima. Se T' não é completa, efetua-se a seguinte operação: retirar uma folha w de seu último nível e tornar w o filho de algum nó v que possui alguma de suas subárvores vazias, localizado em algum nível acima do penúltimo. Repete-se a operação até que não seja mais possível realizá-la, isto é, até que a árvore T'', resultante da transformação, seja completa. T'' não pode ter altura inferior a T', pois T' é mínima. T'' não pode ter altura superior a T', pois nenhum nó foi movido para baixo. Então as alturas de T' e T'' são iguais. Como T' é completa, conclui-se que as alturas de T e T'' também coincidem. Isto é, T possui altura mínima.</p>
</div>
<div class="paragraph">
<p>Para mostrar que \$h=1+|__logn__|\$, recorre-se à indução. Se \$n=1\$, então \$h=1+|__logn__| = 1\$, correto. Quando \$n&gt;1\$, suponha o resultado verdadeiro para todas as árvores binárias completas com até \$n-1\$ nós. Seja T' a árvore obtida de T pela remoção de todos os nós, em número de k, do último nível. Logo, T' é uma árvore cheia com \$n'=n-k\$ nós. Pela hipótese de indução, \$h(T')=1+|__logn'__|\$. Como T' é cheia, \$n'=2^m-1\$, para algum inteiro \$m&gt;0\$. Isto é, \$h(T') = m\$. Além disso, \$1&lt;=k&lt;=n'+1\$. Assim:</p>
</div>
<div class="stemblock">
<div class="content">
\$h(T)=1+h(T')=1+m=1+log(n'+1)=1+|__log(n'+k)__|=1+|__logn__|\$
</div>
</div>
</div>
<div class="sect3">
<h4 id="_subárvore_e_subárvore_parcial">3.3.2. Subárvore e subárvore parcial</h4>
<div class="paragraph">
<p>Seja T uma árvore (ou uma árvore binária) e v um nó de T. Seja T(v) a subárvore de T de raiz v, e S um conjunto de nós T(v) tal que T(v) - S é uma árvore. A árvore T' = T(v) - S é chamada <em>subárvore parcial</em> de raiz v. Observe, por exemplo, a árvore T da <a href="#subarvore">Figura 16</a>, à esquerda. A árvore da imagem, ao centro, é subárvore de T de raiz E, enquanto a árvore à direita é uma subárvore parcial de T de raiz E, porém não é subárvore de T. Observe que a diferença entre uma subárvore de raiz v e uma subárvore parcial de raiz v é que a primeira contém obrigatoriamente todos os descendentes de v, enquanto a segunda, não necessariamente.</p>
</div>
<div id="subarvore" class="imageblock">
<div class="content">
<img src="img/subarvore.png" alt="subarvore">
</div>
<div class="title">Figura 16. Subárvore e subárvore parcial</div>
</div>
</div>
<div class="sect3">
<h4 id="_árvore_m_ária">3.3.3. Árvore m-ária</h4>
<div class="paragraph">
<p>Uma <em>árvore m-ária T</em>, \$m&gt;=2\$, é um conjunto finito de elementos, denominados nós ou vértices, tais que:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>\$T=O/\$, e a árvore é dita <em>vazia</em>; ou</p>
</li>
<li>
<p>Existe um nó especial chamado <em>raiz</em> de \$T(r(T))\$; e os restantes podem ser divididos em m subconjuntos disjuntos, as <em>i-ésimas</em> subárvores de r(T), \$1&lt;=i&lt;=m\$, as quais são também árvores m-árias.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>A raiz da i-ésima subárvore de um nó v de T, se existir, é denominada i-ésimo filho de v. Naturalmente, a árvore m-ária é uma generalização da árvore binária em que cada nó possui m subárvores. A árvore m-ária possui uma ordenação implícita nas subárvores de cada nó, mesmo que algumas ou todas essas subárvores sejam vazias.</p>
</div>
<div class="paragraph">
<p>Analogamente ao caso binário, podem-se definir <em>árvore estritamente m-ária</em>, <em>árvore m-ária completa</em> e <em>cheia</em>.</p>
</div>
<div class="paragraph">
<p>A importância das árvores m-árias de um modo geral e, em especial, da árvore binária decorre do número constante de subárvores de cada nó e de sua ordenação implícita. Quando surge o problema de como representar uma árvore internamente no computador, observa-se o fato de que este estabelece, necessariamente, uma ordem implícita nos dados, por características de construção. Assim sendo, pode-se aproveitar a compatibilidade entre essas duas ordenações e eleger a árvore m-ária para representá-la na memória de um computador. Além disso, o número constante de subárvores de cada nó em muito simplifica a representação. Os detalhes são apresentados a seguir.</p>
</div>
</div>
<div class="sect3">
<h4 id="_armazenamento_de_árvores">3.3.4. Armazenamento de árvores</h4>
<div class="paragraph">
<p>O armazenamento de árvores pode utilizar alocação sequencial ou encadeada. As vantagens e desvantagens de uma e outra já foram mencionadas no capítulo anterior. Sendo a árvore uma estrutura mais complexa do que listas lineares, as vantagens na utilização da alocação encadeada prevalecem.</p>
</div>
<div class="paragraph">
<p>Não é difícil observar que a estrutura de armazenamento para árvores deve conter, em cada nó, ponteiros para seus filhos. A disposição mais econômica consiste em limitar o número de filhos a dois, exatamente o caso de árvores binárias. Note que o número de subárvores vazias cresce com o aumento do parâmetro m das árvores m-árias. Para um dado valor de n, a árvore binária é aquela que minimiza o número de ponteiros necessários.</p>
</div>
<div class="paragraph">
<p>O armazenamento de uma árvore binária surge naturalmente de sua definição. Cada nó deve possuir dois campos de ponteiros, <em>esq</em> e <em>dir</em>, que apontam para as suas subárvores esquerda e direita, respectivamente. O ponteiro <em>ptraiz</em> indica a raiz da árvore. Da mesma forma que na alocação encadeada de listas lineares, a memória é inicialmente considerada uma lista de espaço disponível. Os campos do nó da árvore que contém as informações pertinentes ao problema serão aqui representados como um só campo de nome <em>info</em>. Excetuando-se este último, necessita-se, então de \$2n+1\$ unidades de memória para representar uma árvore binária com n nós.</p>
</div>
<div class="paragraph">
<p>A <a href="#arm_arv_binaria">Figura 17</a> ilustra a estrutura de ponteiros usada no armazenamento de uma árvore binária.</p>
</div>
<div id="arm_arv_binaria" class="imageblock">
<div class="content">
<img src="img/armazenamento_arv_binaria.png" alt="armazenamento arv binaria">
</div>
<div class="title">Figura 17. Armazenamento de uma árvore binária</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_percurso_em_árvores_binárias">3.4. Percurso em árvores binárias</h3>
<div class="paragraph">
<p>Nesta seção são apresentados algoritmos para efetuar um <em>percurso</em> em uma árvore binária. Por percurso entende-se uma visita sistemática a cada um de seus nós; esta é uma das operações básicas relativas à manipulação de árvores. Uma árvore é, essencialmente, uma estrutura não sequencial. Por isso mesmo, ela pode ser utilizada em aplicações que demandem acesso direto. Contudo, mesmo nesse tipo de aplicação é imprescindível conhecer métodos eficientes para percorrer toda a estrutura. Por exemplo, para listar o conteúdo de um arquivo é necessário utilizar algoritmos para percurso.</p>
</div>
<div class="paragraph">
<p>Para percorrer uma árvore deve-se, então, visitar cada um de seus nós. O conceito de visita, nesse caso, possui um caráter bem específico. Visitar um nó significa operar, de alguma forma, com a informação a ele relativa. Por exemplo, imprimir, atualizar suas informações, etc. Em geral, percorrer uma árvore significa visitar seus nós exatamente uma vez. Contudo, no processo de percorrer a árvore pode ser necessário passar várias vezes por alguns de seus nós sem visitá-los. A seguir são discutidas as ideias principais nas quais se baseiam alguns dos algoritmos de percurso em árvore.</p>
</div>
<div class="paragraph">
<p>Um dos passos de qualquer algoritmo de percurso é visitar a raiz v de cada subárvore da árvore T. Além disso, pode-se assumir que o algoritmo opere de tal forma que o percurso de T seja uma composição de percursos de suas subárvores. Nesse caso, poder-se-iam se identificar, no percurso de T, os percursos de suas subárvores em forma contígua. Esses percursos correspondem, no algoritmo, às operações de <em>percorrer subárvores esquerda</em> e <em>direita</em> de v, para cada nó v de T. Essas três operações (visitar e percorrer subárvores esquerda e direita) compõem um algoritmo. Resta definir em que ordem essas operações serão realizadas em cada caso. Por exemplo, pode-se pressupor que as ordens serão as mesmas para todos os nós. Ainda assim, obtêm-se percursos diferentes, dependendo da ordem relativa dessas operações. Cada um desses percursos pode ser mais ou menos adequado a um problema de aplicação dado. São apresentados a seguir três percursos diversos.</p>
</div>
<div class="paragraph">
<p>O <em>percurso em pré-ordem</em> segue recursivamente os seguintes passos, para cada subárvore da árvore:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Visitar a raiz;</p>
</li>
<li>
<p>Percorrer sua subárvore esquerda, em pré-ordem;</p>
</li>
<li>
<p>Percorrer sua subárvore direita, em pré-ordem.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Para a árvore da <a href="#arm_arv_binaria">Figura 17</a>, o percurso em pré-ordem para impressão de nós fornece a seguinte saída: A B D G C E H I F.</p>
</div>
<div class="paragraph">
<p>O <a href="#percurso_pre-ordem">Algoritmo 25</a>, um algoritmo recursivo para o percurso em pré-ordem, é muito simples. A variável <em>pt</em>, parâmetro do procedimento, é um ponteiro que indica a raiz da subárvore que está sendo considerada na chamada ativa. Em cada chamada, somente esse nó é analisado. Após a visita a esse nó, a existência de subárvore esquerda é testada. Caso a resposta seja afirmativa, a chamada recursiva fará com que se percorra toda essa subárvore antes que a subárvore direita seja analisada.</p>
</div>
<div class="paragraph">
<p>A versão não recursiva deve então manter sempre atualizados os caminhos percorridos a partir da raiz da árvore. Uma forma conveniente para se implementar tal procedimento consiste na utilização de uma pilha. O nó é visitado ao ser colocado na pilha, enquanto a retirada da pilha indica o final da visita à subárvore cuja raiz é o nó considerado. Além do caminho percorrido na árvore, deve ser armazenada a direção do percurso, isto é, se o caminho tomado a partir de cada nó é referente à sua subárvore esquerda ou direita. Isto ocorre porque o nó só é retirado da pilha após ambos os percursos serem realizados. Essa versão, um pouco mais trabalhosa do que a apresentada aqui, é deixada ao leitor.</p>
</div>
<div id="percurso_pre-ordem" class="listingblock">
<div class="title">Algoritmo 25. Percurso em pré-ordem</div>
<div class="content">
<pre>procedimento pre(pt)
    visita(pt)
    se pt*.esq != lambda então pre(pt*.esq)
    se pt*.dir != lambda então pre(pt*.dir)

se prtaiz != lambda então pre(ptraiz)</pre>
</div>
</div>
<div class="paragraph">
<p>O <em>percurso em ordem simétrica</em> é muito utilizado para árvores binárias de busca, um dos assuntos do próximo capítulo. Os passos que o compõem são os seguintes, para cada uma de suas subárvores:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Percorrer sua subárvore esquerda, em ordem simétrica;</p>
</li>
<li>
<p>Visitar a raiz;</p>
</li>
<li>
<p>Percorrer sua subárvore direita, em ordem simétrica.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>O <a href="#percurso_simetrica">Algoritmo 26</a>, que mostra o procedimento recursivo que implementa esse percurso, é semelhante ao <a href="#percurso_pre-ordem">Algoritmo 25</a>. A única diferença decorre da própria definição, uma vez que a visita ao nó apontado por <em>pt</em> é feita após a chamada recursiva que estabelece o percurso da subárvore esquerda.</p>
</div>
<div id="percurso_simetrica" class="listingblock">
<div class="title">Algoritmo 26. Percurso em ordem simétrica</div>
<div class="content">
<pre>procedimento simet(pt)
    se pt*.esq != lambda então simet(pt*.esq)
    visita(pt)
    se pt*.dir != lambda então simet(pt*.dir)

se prtaiz != lambda então simet(ptraiz)</pre>
</div>
</div>
<div class="paragraph">
<p>O <a href="#percurso_simetrica">Algoritmo 26</a>, aplicado à árvore da <a href="#arm_arv_binaria">Figura 17</a> para impressão de seus nós, fornece o seguinte resultado: D G B A H E I C F.</p>
</div>
<div class="paragraph">
<p>Finalmente, de uma terceira alternativa de percurso, o <em>percurso em pós-ordem</em>, constam os seguintes passos:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Percorrer sua subárvore esquerda, em pós-ordem;</p>
</li>
<li>
<p>Percorrer sua subárvore direita, em pós-ordem;</p>
</li>
<li>
<p>Visitar a raiz.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>A implementação recursiva do percurso em pós-ordem, apresentada no <a href="#percurso_pos-ordem">Algoritmo 27</a>, introduz poucas variações em relação aos algoritmos anteriores. A implementação não recursiva é também deixada ao leitor.</p>
</div>
<div id="percurso_pos-ordem" class="listingblock">
<div class="title">Algoritmo 27. Percurso em pós-ordem</div>
<div class="content">
<pre>procedimento pos(pt)
    se pt*.esq != lambda então pos(pt*.esq)
    se pt*.dir != lambda então pos(pt*.dir)
    visita(pt)

se prtaiz != lambda então pos(ptraiz)</pre>
</div>
</div>
<div class="paragraph">
<p>O percurso em pós-ordem na árvore da <a href="#arm_arv_binaria">Figura 17</a> fornece o resultado G D B H I E F C A.</p>
</div>
<div class="paragraph">
<p>Em qualquer um dos três percursos apresentados, o procedimento correspondente é chamado recursivamente tantas vezes quantos são os nós da árvore.</p>
</div>
<div class="paragraph">
<p>Sendo n esse valor, a complexidade dos percursos, considerando-se o procedimento <em>visita</em> de complexidade constante, é \$O(n)\$.</p>
</div>
<div class="paragraph">
<p>O cálculo da altura de todos os nós de uma árvore binária é uma aplicação do percurso em pós-ordem. A altura das folhas, pela própria definição, é um. Para os outros nós, por exemplo v, é necessário conhecer o comprimento do maior caminho de v até um de seus descendentes. Isto equivale dizer que a altura de v deve ser calculada após a visita a seus descendentes. O <a href="#altura_binaria">Algoritmo 28</a> mostra a implementação do procedimento <em>visita(pt)</em>, que executa a tarefa de determinar a altura do nó apontado por <em>pt</em>. Considera-se <em>altura</em> um campo do nó da árvore. As variáveis auxiliares <em>alt1</em> e <em>alt2</em> armazenam, respectivamente, as alturas das subárvores esquerda e direita do nó em questão. A altura desejada corresponderá à maior altura dentre as de suas duas subárvores incrementada de um.</p>
</div>
<div id="altura_binaria" class="listingblock">
<div class="title">Algoritmo 28. Cálculo da altura de um nó da árvore binária</div>
<div class="content">
<pre>procedimento visita(pt)
    se pt*.esq != lambda então
        alt1 := (pt*.esq)*.altura
    senão alt1 := 0

    se pt*.dir != lambda então
        alt2 := (pt*.dir)*.altura
    senão alt2 := 0

    se alt1 &gt; alt2 então
        pt*.altura := alt1 + 1
    senão pt*.altura := alt2 + 1</pre>
</div>
</div>
<div class="paragraph">
<p>Existem outras formas de percorrer uma árvore binária além das três aqui estudadas. Por exemplo, o <em>percurso em nível</em> é aquele em que os nós são dispostos em ordem não decrescente de seus níveis. Esse percurso é único quando se define a ordem em que os nós do mesmo nível são visitados, por exemplo, da esquerda para a direita. O percurso em nível, segundo esse critério, para a árvore da <a href="#arm_arv_binaria">Figura 17</a> fornece a sequência A B C D E F G H I.</p>
</div>
<div class="paragraph">
<p>Observe que um percurso em nível difere, em sua essência, dos percursos em pré-ordem, ordem simétrica e pós-ordem. Enquanto nesses últimos o percurso da árvore pode ser decomposto em percursos (contíguos) de suas subárvores, o mesmo não acontece com o percurso em nível. Por esse motivo, o percurso em nível é de caráter não recursivo, isto é, um algoritmo para obter um percurso em nível não deve ser recursivo. De forma equivalente, o algoritmo não deve usar a pilha como estrutura de dados auxiliar. Na realidade, tal algoritmo pode ser facilmente descrito através do uso de uma fila.</p>
</div>
<div class="paragraph">
<p>Até o presente momento, considerou-se unicamente o percurso em árvores binárias. Não há dificuldade em generalizar esse conceito para árvores. Basta considerar que cada nó possui, agora, um número qualquer de subárvores e realizar o percurso em cada uma dessas subárvores.</p>
</div>
<div class="paragraph">
<p>Dessa forma, pode-se definir o percurso em pré-ordem de uma árvore qualquer da seguinte maneira. Para cada uma de suas subárvores, é preciso efetuar, recursivamente, os passos:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Visitar a raiz;</p>
</li>
<li>
<p>Percorrer a primeira subárvore em pré-ordem;</p>
</li>
<li>
<p>Percorrer a segunda subárvore em pré-ordem;</p>
</li>
<li>
<p>&#8230;&#8203;</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Por exemplo, o percurso em pré-ordem da árvore à direita da <a href="#isomorfismo">Figura 11</a> é A C D G H F I E B. Observe que a definição assume, implicitamente, uma ordenação das subárvores.</p>
</div>
<div class="paragraph">
<p>De maneira análoga, pode-se definir o percurso em pós-ordem de uma árvore qualquer. A definição de percurso em nível é igual e abrange também árvores não binárias.</p>
</div>
<div class="paragraph">
<p>Os algoritmos para percorrer árvores quaisquer devem supor, de início, a árvore representada internamente no computador de alguma forma. Esse assunto será abordado na próxima seção.</p>
</div>
</div>
</div>
</div>
</div>
<div id="footer">
<div id="footer-text">
Last updated 2020-09-20 13:31:42 -0300
</div>
</div>
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  messageStyle: "none",
  tex2jax: {
    inlineMath: [["\\(", "\\)"]],
    displayMath: [["\\[", "\\]"]],
    ignoreClass: "nostem|nolatexmath"
  },
  asciimath2jax: {
    delimiters: [["\\$", "\\$"]],
    ignoreClass: "nostem|noasciimath"
  },
  TeX: { equationNumbers: { autoNumber: "none" } }
})
MathJax.Hub.Register.StartupHook("AsciiMath Jax Ready", function () {
  MathJax.InputJax.AsciiMath.postfilterHooks.Add(function (data, node) {
    if ((node = data.script.parentNode) && (node = node.parentNode) && node.classList.contains('stemblock')) {
      data.math.root.display = "block"
    }
    return data
  })
})
</script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_HTMLorMML"></script>
</body>
</html>