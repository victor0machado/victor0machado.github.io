<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="generator" content="Asciidoctor 2.0.10">
<meta name="author" content="Nota de Aula">
<title>Lógica e Programação de Computadores</title>
<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:300,300italic,400,400italic,600,600italic%7CNoto+Serif:400,400italic,700,700italic%7CDroid+Sans+Mono:400,700">
<style>
/* Asciidoctor default stylesheet | MIT License | https://asciidoctor.org */
/* Uncomment @import statement to use as custom stylesheet */
/*@import "https://fonts.googleapis.com/css?family=Open+Sans:300,300italic,400,400italic,600,600italic%7CNoto+Serif:400,400italic,700,700italic%7CDroid+Sans+Mono:400,700";*/
article,aside,details,figcaption,figure,footer,header,hgroup,main,nav,section{display:block}
audio,video{display:inline-block}
audio:not([controls]){display:none;height:0}
html{font-family:sans-serif;-ms-text-size-adjust:100%;-webkit-text-size-adjust:100%}
a{background:none}
a:focus{outline:thin dotted}
a:active,a:hover{outline:0}
h1{font-size:2em;margin:.67em 0}
abbr[title]{border-bottom:1px dotted}
b,strong{font-weight:bold}
dfn{font-style:italic}
hr{-moz-box-sizing:content-box;box-sizing:content-box;height:0}
mark{background:#ff0;color:#000}
code,kbd,pre,samp{font-family:monospace;font-size:1em}
pre{white-space:pre-wrap}
q{quotes:"\201C" "\201D" "\2018" "\2019"}
small{font-size:80%}
sub,sup{font-size:75%;line-height:0;position:relative;vertical-align:baseline}
sup{top:-.5em}
sub{bottom:-.25em}
img{border:0}
svg:not(:root){overflow:hidden}
figure{margin:0}
fieldset{border:1px solid silver;margin:0 2px;padding:.35em .625em .75em}
legend{border:0;padding:0}
button,input,select,textarea{font-family:inherit;font-size:100%;margin:0}
button,input{line-height:normal}
button,select{text-transform:none}
button,html input[type="button"],input[type="reset"],input[type="submit"]{-webkit-appearance:button;cursor:pointer}
button[disabled],html input[disabled]{cursor:default}
input[type="checkbox"],input[type="radio"]{box-sizing:border-box;padding:0}
button::-moz-focus-inner,input::-moz-focus-inner{border:0;padding:0}
textarea{overflow:auto;vertical-align:top}
table{border-collapse:collapse;border-spacing:0}
*,*::before,*::after{-moz-box-sizing:border-box;-webkit-box-sizing:border-box;box-sizing:border-box}
html,body{font-size:100%}
body{background:#fff;color:rgba(0,0,0,.8);padding:0;margin:0;font-family:"Noto Serif","DejaVu Serif",serif;font-weight:400;font-style:normal;line-height:1;position:relative;cursor:auto;tab-size:4;-moz-osx-font-smoothing:grayscale;-webkit-font-smoothing:antialiased}
a:hover{cursor:pointer}
img,object,embed{max-width:100%;height:auto}
object,embed{height:100%}
img{-ms-interpolation-mode:bicubic}
.left{float:left!important}
.right{float:right!important}
.text-left{text-align:left!important}
.text-right{text-align:right!important}
.text-center{text-align:center!important}
.text-justify{text-align:justify!important}
.hide{display:none}
img,object,svg{display:inline-block;vertical-align:middle}
textarea{height:auto;min-height:50px}
select{width:100%}
.center{margin-left:auto;margin-right:auto}
.stretch{width:100%}
.subheader,.admonitionblock td.content>.title,.audioblock>.title,.exampleblock>.title,.imageblock>.title,.listingblock>.title,.literalblock>.title,.stemblock>.title,.openblock>.title,.paragraph>.title,.quoteblock>.title,table.tableblock>.title,.verseblock>.title,.videoblock>.title,.dlist>.title,.olist>.title,.ulist>.title,.qlist>.title,.hdlist>.title{line-height:1.45;color:#7a2518;font-weight:400;margin-top:0;margin-bottom:.25em}
div,dl,dt,dd,ul,ol,li,h1,h2,h3,#toctitle,.sidebarblock>.content>.title,h4,h5,h6,pre,form,p,blockquote,th,td{margin:0;padding:0;direction:ltr}
a{color:#2156a5;text-decoration:underline;line-height:inherit}
a:hover,a:focus{color:#1d4b8f}
a img{border:0}
p{font-family:inherit;font-weight:400;font-size:1em;line-height:1.6;margin-bottom:1.25em;text-rendering:optimizeLegibility}
p aside{font-size:.875em;line-height:1.35;font-style:italic}
h1,h2,h3,#toctitle,.sidebarblock>.content>.title,h4,h5,h6{font-family:"Open Sans","DejaVu Sans",sans-serif;font-weight:300;font-style:normal;color:#ba3925;text-rendering:optimizeLegibility;margin-top:1em;margin-bottom:.5em;line-height:1.0125em}
h1 small,h2 small,h3 small,#toctitle small,.sidebarblock>.content>.title small,h4 small,h5 small,h6 small{font-size:60%;color:#e99b8f;line-height:0}
h1{font-size:2.125em}
h2{font-size:1.6875em}
h3,#toctitle,.sidebarblock>.content>.title{font-size:1.375em}
h4,h5{font-size:1.125em}
h6{font-size:1em}
hr{border:solid #dddddf;border-width:1px 0 0;clear:both;margin:1.25em 0 1.1875em;height:0}
em,i{font-style:italic;line-height:inherit}
strong,b{font-weight:bold;line-height:inherit}
small{font-size:60%;line-height:inherit}
code{font-family:"Droid Sans Mono","DejaVu Sans Mono",monospace;font-weight:400;color:rgba(0,0,0,.9)}
ul,ol,dl{font-size:1em;line-height:1.6;margin-bottom:1.25em;list-style-position:outside;font-family:inherit}
ul,ol{margin-left:1.5em}
ul li ul,ul li ol{margin-left:1.25em;margin-bottom:0;font-size:1em}
ul.square li ul,ul.circle li ul,ul.disc li ul{list-style:inherit}
ul.square{list-style-type:square}
ul.circle{list-style-type:circle}
ul.disc{list-style-type:disc}
ol li ul,ol li ol{margin-left:1.25em;margin-bottom:0}
dl dt{margin-bottom:.3125em;font-weight:bold}
dl dd{margin-bottom:1.25em}
abbr,acronym{text-transform:uppercase;font-size:90%;color:rgba(0,0,0,.8);border-bottom:1px dotted #ddd;cursor:help}
abbr{text-transform:none}
blockquote{margin:0 0 1.25em;padding:.5625em 1.25em 0 1.1875em;border-left:1px solid #ddd}
blockquote cite{display:block;font-size:.9375em;color:rgba(0,0,0,.6)}
blockquote cite::before{content:"\2014 \0020"}
blockquote cite a,blockquote cite a:visited{color:rgba(0,0,0,.6)}
blockquote,blockquote p{line-height:1.6;color:rgba(0,0,0,.85)}
@media screen and (min-width:768px){h1,h2,h3,#toctitle,.sidebarblock>.content>.title,h4,h5,h6{line-height:1.2}
h1{font-size:2.75em}
h2{font-size:2.3125em}
h3,#toctitle,.sidebarblock>.content>.title{font-size:1.6875em}
h4{font-size:1.4375em}}
table{background:#fff;margin-bottom:1.25em;border:solid 1px #dedede}
table thead,table tfoot{background:#f7f8f7}
table thead tr th,table thead tr td,table tfoot tr th,table tfoot tr td{padding:.5em .625em .625em;font-size:inherit;color:rgba(0,0,0,.8);text-align:left}
table tr th,table tr td{padding:.5625em .625em;font-size:inherit;color:rgba(0,0,0,.8)}
table tr.even,table tr.alt{background:#f8f8f7}
table thead tr th,table tfoot tr th,table tbody tr td,table tr td,table tfoot tr td{display:table-cell;line-height:1.6}
h1,h2,h3,#toctitle,.sidebarblock>.content>.title,h4,h5,h6{line-height:1.2;word-spacing:-.05em}
h1 strong,h2 strong,h3 strong,#toctitle strong,.sidebarblock>.content>.title strong,h4 strong,h5 strong,h6 strong{font-weight:400}
.clearfix::before,.clearfix::after,.float-group::before,.float-group::after{content:" ";display:table}
.clearfix::after,.float-group::after{clear:both}
:not(pre):not([class^=L])>code{font-size:.9375em;font-style:normal!important;letter-spacing:0;padding:.1em .5ex;word-spacing:-.15em;background:#f7f7f8;-webkit-border-radius:4px;border-radius:4px;line-height:1.45;text-rendering:optimizeSpeed;word-wrap:break-word}
:not(pre)>code.nobreak{word-wrap:normal}
:not(pre)>code.nowrap{white-space:nowrap}
pre{color:rgba(0,0,0,.9);font-family:"Droid Sans Mono","DejaVu Sans Mono",monospace;line-height:1.45;text-rendering:optimizeSpeed}
pre code,pre pre{color:inherit;font-size:inherit;line-height:inherit}
pre>code{display:block}
pre.nowrap,pre.nowrap pre{white-space:pre;word-wrap:normal}
em em{font-style:normal}
strong strong{font-weight:400}
.keyseq{color:rgba(51,51,51,.8)}
kbd{font-family:"Droid Sans Mono","DejaVu Sans Mono",monospace;display:inline-block;color:rgba(0,0,0,.8);font-size:.65em;line-height:1.45;background:#f7f7f7;border:1px solid #ccc;-webkit-border-radius:3px;border-radius:3px;-webkit-box-shadow:0 1px 0 rgba(0,0,0,.2),0 0 0 .1em white inset;box-shadow:0 1px 0 rgba(0,0,0,.2),0 0 0 .1em #fff inset;margin:0 .15em;padding:.2em .5em;vertical-align:middle;position:relative;top:-.1em;white-space:nowrap}
.keyseq kbd:first-child{margin-left:0}
.keyseq kbd:last-child{margin-right:0}
.menuseq,.menuref{color:#000}
.menuseq b:not(.caret),.menuref{font-weight:inherit}
.menuseq{word-spacing:-.02em}
.menuseq b.caret{font-size:1.25em;line-height:.8}
.menuseq i.caret{font-weight:bold;text-align:center;width:.45em}
b.button::before,b.button::after{position:relative;top:-1px;font-weight:400}
b.button::before{content:"[";padding:0 3px 0 2px}
b.button::after{content:"]";padding:0 2px 0 3px}
p a>code:hover{color:rgba(0,0,0,.9)}
#header,#content,#footnotes,#footer{width:100%;margin-left:auto;margin-right:auto;margin-top:0;margin-bottom:0;max-width:62.5em;*zoom:1;position:relative;padding-left:.9375em;padding-right:.9375em}
#header::before,#header::after,#content::before,#content::after,#footnotes::before,#footnotes::after,#footer::before,#footer::after{content:" ";display:table}
#header::after,#content::after,#footnotes::after,#footer::after{clear:both}
#content{margin-top:1.25em}
#content::before{content:none}
#header>h1:first-child{color:rgba(0,0,0,.85);margin-top:2.25rem;margin-bottom:0}
#header>h1:first-child+#toc{margin-top:8px;border-top:1px solid #dddddf}
#header>h1:only-child,body.toc2 #header>h1:nth-last-child(2){border-bottom:1px solid #dddddf;padding-bottom:8px}
#header .details{border-bottom:1px solid #dddddf;line-height:1.45;padding-top:.25em;padding-bottom:.25em;padding-left:.25em;color:rgba(0,0,0,.6);display:-ms-flexbox;display:-webkit-flex;display:flex;-ms-flex-flow:row wrap;-webkit-flex-flow:row wrap;flex-flow:row wrap}
#header .details span:first-child{margin-left:-.125em}
#header .details span.email a{color:rgba(0,0,0,.85)}
#header .details br{display:none}
#header .details br+span::before{content:"\00a0\2013\00a0"}
#header .details br+span.author::before{content:"\00a0\22c5\00a0";color:rgba(0,0,0,.85)}
#header .details br+span#revremark::before{content:"\00a0|\00a0"}
#header #revnumber{text-transform:capitalize}
#header #revnumber::after{content:"\00a0"}
#content>h1:first-child:not([class]){color:rgba(0,0,0,.85);border-bottom:1px solid #dddddf;padding-bottom:8px;margin-top:0;padding-top:1rem;margin-bottom:1.25rem}
#toc{border-bottom:1px solid #e7e7e9;padding-bottom:.5em}
#toc>ul{margin-left:.125em}
#toc ul.sectlevel0>li>a{font-style:italic}
#toc ul.sectlevel0 ul.sectlevel1{margin:.5em 0}
#toc ul{font-family:"Open Sans","DejaVu Sans",sans-serif;list-style-type:none}
#toc li{line-height:1.3334;margin-top:.3334em}
#toc a{text-decoration:none}
#toc a:active{text-decoration:underline}
#toctitle{color:#7a2518;font-size:1.2em}
@media screen and (min-width:768px){#toctitle{font-size:1.375em}
body.toc2{padding-left:15em;padding-right:0}
#toc.toc2{margin-top:0!important;background:#f8f8f7;position:fixed;width:15em;left:0;top:0;border-right:1px solid #e7e7e9;border-top-width:0!important;border-bottom-width:0!important;z-index:1000;padding:1.25em 1em;height:100%;overflow:auto}
#toc.toc2 #toctitle{margin-top:0;margin-bottom:.8rem;font-size:1.2em}
#toc.toc2>ul{font-size:.9em;margin-bottom:0}
#toc.toc2 ul ul{margin-left:0;padding-left:1em}
#toc.toc2 ul.sectlevel0 ul.sectlevel1{padding-left:0;margin-top:.5em;margin-bottom:.5em}
body.toc2.toc-right{padding-left:0;padding-right:15em}
body.toc2.toc-right #toc.toc2{border-right-width:0;border-left:1px solid #e7e7e9;left:auto;right:0}}
@media screen and (min-width:1280px){body.toc2{padding-left:20em;padding-right:0}
#toc.toc2{width:20em}
#toc.toc2 #toctitle{font-size:1.375em}
#toc.toc2>ul{font-size:.95em}
#toc.toc2 ul ul{padding-left:1.25em}
body.toc2.toc-right{padding-left:0;padding-right:20em}}
#content #toc{border-style:solid;border-width:1px;border-color:#e0e0dc;margin-bottom:1.25em;padding:1.25em;background:#f8f8f7;-webkit-border-radius:4px;border-radius:4px}
#content #toc>:first-child{margin-top:0}
#content #toc>:last-child{margin-bottom:0}
#footer{max-width:100%;background:rgba(0,0,0,.8);padding:1.25em}
#footer-text{color:rgba(255,255,255,.8);line-height:1.44}
#content{margin-bottom:.625em}
.sect1{padding-bottom:.625em}
@media screen and (min-width:768px){#content{margin-bottom:1.25em}
.sect1{padding-bottom:1.25em}}
.sect1:last-child{padding-bottom:0}
.sect1+.sect1{border-top:1px solid #e7e7e9}
#content h1>a.anchor,h2>a.anchor,h3>a.anchor,#toctitle>a.anchor,.sidebarblock>.content>.title>a.anchor,h4>a.anchor,h5>a.anchor,h6>a.anchor{position:absolute;z-index:1001;width:1.5ex;margin-left:-1.5ex;display:block;text-decoration:none!important;visibility:hidden;text-align:center;font-weight:400}
#content h1>a.anchor::before,h2>a.anchor::before,h3>a.anchor::before,#toctitle>a.anchor::before,.sidebarblock>.content>.title>a.anchor::before,h4>a.anchor::before,h5>a.anchor::before,h6>a.anchor::before{content:"\00A7";font-size:.85em;display:block;padding-top:.1em}
#content h1:hover>a.anchor,#content h1>a.anchor:hover,h2:hover>a.anchor,h2>a.anchor:hover,h3:hover>a.anchor,#toctitle:hover>a.anchor,.sidebarblock>.content>.title:hover>a.anchor,h3>a.anchor:hover,#toctitle>a.anchor:hover,.sidebarblock>.content>.title>a.anchor:hover,h4:hover>a.anchor,h4>a.anchor:hover,h5:hover>a.anchor,h5>a.anchor:hover,h6:hover>a.anchor,h6>a.anchor:hover{visibility:visible}
#content h1>a.link,h2>a.link,h3>a.link,#toctitle>a.link,.sidebarblock>.content>.title>a.link,h4>a.link,h5>a.link,h6>a.link{color:#ba3925;text-decoration:none}
#content h1>a.link:hover,h2>a.link:hover,h3>a.link:hover,#toctitle>a.link:hover,.sidebarblock>.content>.title>a.link:hover,h4>a.link:hover,h5>a.link:hover,h6>a.link:hover{color:#a53221}
details,.audioblock,.imageblock,.literalblock,.listingblock,.stemblock,.videoblock{margin-bottom:1.25em}
details>summary:first-of-type{cursor:pointer;display:list-item;outline:none;margin-bottom:.75em}
.admonitionblock td.content>.title,.audioblock>.title,.exampleblock>.title,.imageblock>.title,.listingblock>.title,.literalblock>.title,.stemblock>.title,.openblock>.title,.paragraph>.title,.quoteblock>.title,table.tableblock>.title,.verseblock>.title,.videoblock>.title,.dlist>.title,.olist>.title,.ulist>.title,.qlist>.title,.hdlist>.title{text-rendering:optimizeLegibility;text-align:left;font-family:"Noto Serif","DejaVu Serif",serif;font-size:1rem;font-style:italic}
table.tableblock.fit-content>caption.title{white-space:nowrap;width:0}
.paragraph.lead>p,#preamble>.sectionbody>[class="paragraph"]:first-of-type p{font-size:1.21875em;line-height:1.6;color:rgba(0,0,0,.85)}
table.tableblock #preamble>.sectionbody>[class="paragraph"]:first-of-type p{font-size:inherit}
.admonitionblock>table{border-collapse:separate;border:0;background:none;width:100%}
.admonitionblock>table td.icon{text-align:center;width:80px}
.admonitionblock>table td.icon img{max-width:none}
.admonitionblock>table td.icon .title{font-weight:bold;font-family:"Open Sans","DejaVu Sans",sans-serif;text-transform:uppercase}
.admonitionblock>table td.content{padding-left:1.125em;padding-right:1.25em;border-left:1px solid #dddddf;color:rgba(0,0,0,.6)}
.admonitionblock>table td.content>:last-child>:last-child{margin-bottom:0}
.exampleblock>.content{border-style:solid;border-width:1px;border-color:#e6e6e6;margin-bottom:1.25em;padding:1.25em;background:#fff;-webkit-border-radius:4px;border-radius:4px}
.exampleblock>.content>:first-child{margin-top:0}
.exampleblock>.content>:last-child{margin-bottom:0}
.sidebarblock{border-style:solid;border-width:1px;border-color:#dbdbd6;margin-bottom:1.25em;padding:1.25em;background:#f3f3f2;-webkit-border-radius:4px;border-radius:4px}
.sidebarblock>:first-child{margin-top:0}
.sidebarblock>:last-child{margin-bottom:0}
.sidebarblock>.content>.title{color:#7a2518;margin-top:0;text-align:center}
.exampleblock>.content>:last-child>:last-child,.exampleblock>.content .olist>ol>li:last-child>:last-child,.exampleblock>.content .ulist>ul>li:last-child>:last-child,.exampleblock>.content .qlist>ol>li:last-child>:last-child,.sidebarblock>.content>:last-child>:last-child,.sidebarblock>.content .olist>ol>li:last-child>:last-child,.sidebarblock>.content .ulist>ul>li:last-child>:last-child,.sidebarblock>.content .qlist>ol>li:last-child>:last-child{margin-bottom:0}
.literalblock pre,.listingblock>.content>pre{-webkit-border-radius:4px;border-radius:4px;word-wrap:break-word;overflow-x:auto;padding:1em;font-size:.8125em}
@media screen and (min-width:768px){.literalblock pre,.listingblock>.content>pre{font-size:.90625em}}
@media screen and (min-width:1280px){.literalblock pre,.listingblock>.content>pre{font-size:1em}}
.literalblock pre,.listingblock>.content>pre:not(.highlight),.listingblock>.content>pre[class="highlight"],.listingblock>.content>pre[class^="highlight "]{background:#f7f7f8}
.literalblock.output pre{color:#f7f7f8;background:rgba(0,0,0,.9)}
.listingblock>.content{position:relative}
.listingblock code[data-lang]::before{display:none;content:attr(data-lang);position:absolute;font-size:.75em;top:.425rem;right:.5rem;line-height:1;text-transform:uppercase;color:inherit;opacity:.5}
.listingblock:hover code[data-lang]::before{display:block}
.listingblock.terminal pre .command::before{content:attr(data-prompt);padding-right:.5em;color:inherit;opacity:.5}
.listingblock.terminal pre .command:not([data-prompt])::before{content:"$"}
.listingblock pre.highlightjs{padding:0}
.listingblock pre.highlightjs>code{padding:1em;-webkit-border-radius:4px;border-radius:4px}
.listingblock pre.prettyprint{border-width:0}
.prettyprint{background:#f7f7f8}
pre.prettyprint .linenums{line-height:1.45;margin-left:2em}
pre.prettyprint li{background:none;list-style-type:inherit;padding-left:0}
pre.prettyprint li code[data-lang]::before{opacity:1}
pre.prettyprint li:not(:first-child) code[data-lang]::before{display:none}
table.linenotable{border-collapse:separate;border:0;margin-bottom:0;background:none}
table.linenotable td[class]{color:inherit;vertical-align:top;padding:0;line-height:inherit;white-space:normal}
table.linenotable td.code{padding-left:.75em}
table.linenotable td.linenos{border-right:1px solid currentColor;opacity:.35;padding-right:.5em}
pre.pygments .lineno{border-right:1px solid currentColor;opacity:.35;display:inline-block;margin-right:.75em}
pre.pygments .lineno::before{content:"";margin-right:-.125em}
.quoteblock{margin:0 1em 1.25em 1.5em;display:table}
.quoteblock:not(.excerpt)>.title{margin-left:-1.5em;margin-bottom:.75em}
.quoteblock blockquote,.quoteblock p{color:rgba(0,0,0,.85);font-size:1.15rem;line-height:1.75;word-spacing:.1em;letter-spacing:0;font-style:italic;text-align:justify}
.quoteblock blockquote{margin:0;padding:0;border:0}
.quoteblock blockquote::before{content:"\201c";float:left;font-size:2.75em;font-weight:bold;line-height:.6em;margin-left:-.6em;color:#7a2518;text-shadow:0 1px 2px rgba(0,0,0,.1)}
.quoteblock blockquote>.paragraph:last-child p{margin-bottom:0}
.quoteblock .attribution{margin-top:.75em;margin-right:.5ex;text-align:right}
.verseblock{margin:0 1em 1.25em}
.verseblock pre{font-family:"Open Sans","DejaVu Sans",sans;font-size:1.15rem;color:rgba(0,0,0,.85);font-weight:300;text-rendering:optimizeLegibility}
.verseblock pre strong{font-weight:400}
.verseblock .attribution{margin-top:1.25rem;margin-left:.5ex}
.quoteblock .attribution,.verseblock .attribution{font-size:.9375em;line-height:1.45;font-style:italic}
.quoteblock .attribution br,.verseblock .attribution br{display:none}
.quoteblock .attribution cite,.verseblock .attribution cite{display:block;letter-spacing:-.025em;color:rgba(0,0,0,.6)}
.quoteblock.abstract blockquote::before,.quoteblock.excerpt blockquote::before,.quoteblock .quoteblock blockquote::before{display:none}
.quoteblock.abstract blockquote,.quoteblock.abstract p,.quoteblock.excerpt blockquote,.quoteblock.excerpt p,.quoteblock .quoteblock blockquote,.quoteblock .quoteblock p{line-height:1.6;word-spacing:0}
.quoteblock.abstract{margin:0 1em 1.25em;display:block}
.quoteblock.abstract>.title{margin:0 0 .375em;font-size:1.15em;text-align:center}
.quoteblock.excerpt>blockquote,.quoteblock .quoteblock{padding:0 0 .25em 1em;border-left:.25em solid #dddddf}
.quoteblock.excerpt,.quoteblock .quoteblock{margin-left:0}
.quoteblock.excerpt blockquote,.quoteblock.excerpt p,.quoteblock .quoteblock blockquote,.quoteblock .quoteblock p{color:inherit;font-size:1.0625rem}
.quoteblock.excerpt .attribution,.quoteblock .quoteblock .attribution{color:inherit;text-align:left;margin-right:0}
table.tableblock{max-width:100%;border-collapse:separate}
p.tableblock:last-child{margin-bottom:0}
td.tableblock>.content>:last-child{margin-bottom:-1.25em}
td.tableblock>.content>:last-child.sidebarblock{margin-bottom:0}
table.tableblock,th.tableblock,td.tableblock{border:0 solid #dedede}
table.grid-all>thead>tr>.tableblock,table.grid-all>tbody>tr>.tableblock{border-width:0 1px 1px 0}
table.grid-all>tfoot>tr>.tableblock{border-width:1px 1px 0 0}
table.grid-cols>*>tr>.tableblock{border-width:0 1px 0 0}
table.grid-rows>thead>tr>.tableblock,table.grid-rows>tbody>tr>.tableblock{border-width:0 0 1px}
table.grid-rows>tfoot>tr>.tableblock{border-width:1px 0 0}
table.grid-all>*>tr>.tableblock:last-child,table.grid-cols>*>tr>.tableblock:last-child{border-right-width:0}
table.grid-all>tbody>tr:last-child>.tableblock,table.grid-all>thead:last-child>tr>.tableblock,table.grid-rows>tbody>tr:last-child>.tableblock,table.grid-rows>thead:last-child>tr>.tableblock{border-bottom-width:0}
table.frame-all{border-width:1px}
table.frame-sides{border-width:0 1px}
table.frame-topbot,table.frame-ends{border-width:1px 0}
table.stripes-all tr,table.stripes-odd tr:nth-of-type(odd),table.stripes-even tr:nth-of-type(even),table.stripes-hover tr:hover{background:#f8f8f7}
th.halign-left,td.halign-left{text-align:left}
th.halign-right,td.halign-right{text-align:right}
th.halign-center,td.halign-center{text-align:center}
th.valign-top,td.valign-top{vertical-align:top}
th.valign-bottom,td.valign-bottom{vertical-align:bottom}
th.valign-middle,td.valign-middle{vertical-align:middle}
table thead th,table tfoot th{font-weight:bold}
tbody tr th{display:table-cell;line-height:1.6;background:#f7f8f7}
tbody tr th,tbody tr th p,tfoot tr th,tfoot tr th p{color:rgba(0,0,0,.8);font-weight:bold}
p.tableblock>code:only-child{background:none;padding:0}
p.tableblock{font-size:1em}
ol{margin-left:1.75em}
ul li ol{margin-left:1.5em}
dl dd{margin-left:1.125em}
dl dd:last-child,dl dd:last-child>:last-child{margin-bottom:0}
ol>li p,ul>li p,ul dd,ol dd,.olist .olist,.ulist .ulist,.ulist .olist,.olist .ulist{margin-bottom:.625em}
ul.checklist,ul.none,ol.none,ul.no-bullet,ol.no-bullet,ol.unnumbered,ul.unstyled,ol.unstyled{list-style-type:none}
ul.no-bullet,ol.no-bullet,ol.unnumbered{margin-left:.625em}
ul.unstyled,ol.unstyled{margin-left:0}
ul.checklist{margin-left:.625em}
ul.checklist li>p:first-child>.fa-square-o:first-child,ul.checklist li>p:first-child>.fa-check-square-o:first-child{width:1.25em;font-size:.8em;position:relative;bottom:.125em}
ul.checklist li>p:first-child>input[type="checkbox"]:first-child{margin-right:.25em}
ul.inline{display:-ms-flexbox;display:-webkit-box;display:flex;-ms-flex-flow:row wrap;-webkit-flex-flow:row wrap;flex-flow:row wrap;list-style:none;margin:0 0 .625em -1.25em}
ul.inline>li{margin-left:1.25em}
.unstyled dl dt{font-weight:400;font-style:normal}
ol.arabic{list-style-type:decimal}
ol.decimal{list-style-type:decimal-leading-zero}
ol.loweralpha{list-style-type:lower-alpha}
ol.upperalpha{list-style-type:upper-alpha}
ol.lowerroman{list-style-type:lower-roman}
ol.upperroman{list-style-type:upper-roman}
ol.lowergreek{list-style-type:lower-greek}
.hdlist>table,.colist>table{border:0;background:none}
.hdlist>table>tbody>tr,.colist>table>tbody>tr{background:none}
td.hdlist1,td.hdlist2{vertical-align:top;padding:0 .625em}
td.hdlist1{font-weight:bold;padding-bottom:1.25em}
.literalblock+.colist,.listingblock+.colist{margin-top:-.5em}
.colist td:not([class]):first-child{padding:.4em .75em 0;line-height:1;vertical-align:top}
.colist td:not([class]):first-child img{max-width:none}
.colist td:not([class]):last-child{padding:.25em 0}
.thumb,.th{line-height:0;display:inline-block;border:solid 4px #fff;-webkit-box-shadow:0 0 0 1px #ddd;box-shadow:0 0 0 1px #ddd}
.imageblock.left{margin:.25em .625em 1.25em 0}
.imageblock.right{margin:.25em 0 1.25em .625em}
.imageblock>.title{margin-bottom:0}
.imageblock.thumb,.imageblock.th{border-width:6px}
.imageblock.thumb>.title,.imageblock.th>.title{padding:0 .125em}
.image.left,.image.right{margin-top:.25em;margin-bottom:.25em;display:inline-block;line-height:0}
.image.left{margin-right:.625em}
.image.right{margin-left:.625em}
a.image{text-decoration:none;display:inline-block}
a.image object{pointer-events:none}
sup.footnote,sup.footnoteref{font-size:.875em;position:static;vertical-align:super}
sup.footnote a,sup.footnoteref a{text-decoration:none}
sup.footnote a:active,sup.footnoteref a:active{text-decoration:underline}
#footnotes{padding-top:.75em;padding-bottom:.75em;margin-bottom:.625em}
#footnotes hr{width:20%;min-width:6.25em;margin:-.25em 0 .75em;border-width:1px 0 0}
#footnotes .footnote{padding:0 .375em 0 .225em;line-height:1.3334;font-size:.875em;margin-left:1.2em;margin-bottom:.2em}
#footnotes .footnote a:first-of-type{font-weight:bold;text-decoration:none;margin-left:-1.05em}
#footnotes .footnote:last-of-type{margin-bottom:0}
#content #footnotes{margin-top:-.625em;margin-bottom:0;padding:.75em 0}
.gist .file-data>table{border:0;background:#fff;width:100%;margin-bottom:0}
.gist .file-data>table td.line-data{width:99%}
div.unbreakable{page-break-inside:avoid}
.big{font-size:larger}
.small{font-size:smaller}
.underline{text-decoration:underline}
.overline{text-decoration:overline}
.line-through{text-decoration:line-through}
.aqua{color:#00bfbf}
.aqua-background{background:#00fafa}
.black{color:#000}
.black-background{background:#000}
.blue{color:#0000bf}
.blue-background{background:#0000fa}
.fuchsia{color:#bf00bf}
.fuchsia-background{background:#fa00fa}
.gray{color:#606060}
.gray-background{background:#7d7d7d}
.green{color:#006000}
.green-background{background:#007d00}
.lime{color:#00bf00}
.lime-background{background:#00fa00}
.maroon{color:#600000}
.maroon-background{background:#7d0000}
.navy{color:#000060}
.navy-background{background:#00007d}
.olive{color:#606000}
.olive-background{background:#7d7d00}
.purple{color:#600060}
.purple-background{background:#7d007d}
.red{color:#bf0000}
.red-background{background:#fa0000}
.silver{color:#909090}
.silver-background{background:#bcbcbc}
.teal{color:#006060}
.teal-background{background:#007d7d}
.white{color:#bfbfbf}
.white-background{background:#fafafa}
.yellow{color:#bfbf00}
.yellow-background{background:#fafa00}
span.icon>.fa{cursor:default}
a span.icon>.fa{cursor:inherit}
.admonitionblock td.icon [class^="fa icon-"]{font-size:2.5em;text-shadow:1px 1px 2px rgba(0,0,0,.5);cursor:default}
.admonitionblock td.icon .icon-note::before{content:"\f05a";color:#19407c}
.admonitionblock td.icon .icon-tip::before{content:"\f0eb";text-shadow:1px 1px 2px rgba(155,155,0,.8);color:#111}
.admonitionblock td.icon .icon-warning::before{content:"\f071";color:#bf6900}
.admonitionblock td.icon .icon-caution::before{content:"\f06d";color:#bf3400}
.admonitionblock td.icon .icon-important::before{content:"\f06a";color:#bf0000}
.conum[data-value]{display:inline-block;color:#fff!important;background:rgba(0,0,0,.8);-webkit-border-radius:100px;border-radius:100px;text-align:center;font-size:.75em;width:1.67em;height:1.67em;line-height:1.67em;font-family:"Open Sans","DejaVu Sans",sans-serif;font-style:normal;font-weight:bold}
.conum[data-value] *{color:#fff!important}
.conum[data-value]+b{display:none}
.conum[data-value]::after{content:attr(data-value)}
pre .conum[data-value]{position:relative;top:-.125em}
b.conum *{color:inherit!important}
.conum:not([data-value]):empty{display:none}
dt,th.tableblock,td.content,div.footnote{text-rendering:optimizeLegibility}
h1,h2,p,td.content,span.alt{letter-spacing:-.01em}
p strong,td.content strong,div.footnote strong{letter-spacing:-.005em}
p,blockquote,dt,td.content,span.alt{font-size:1.0625rem}
p{margin-bottom:1.25rem}
.sidebarblock p,.sidebarblock dt,.sidebarblock td.content,p.tableblock{font-size:1em}
.exampleblock>.content{background:#fffef7;border-color:#e0e0dc;-webkit-box-shadow:0 1px 4px #e0e0dc;box-shadow:0 1px 4px #e0e0dc}
.print-only{display:none!important}
@page{margin:1.25cm .75cm}
@media print{*{-webkit-box-shadow:none!important;box-shadow:none!important;text-shadow:none!important}
html{font-size:80%}
a{color:inherit!important;text-decoration:underline!important}
a.bare,a[href^="#"],a[href^="mailto:"]{text-decoration:none!important}
a[href^="http:"]:not(.bare)::after,a[href^="https:"]:not(.bare)::after{content:"(" attr(href) ")";display:inline-block;font-size:.875em;padding-left:.25em}
abbr[title]::after{content:" (" attr(title) ")"}
pre,blockquote,tr,img,object,svg{page-break-inside:avoid}
thead{display:table-header-group}
svg{max-width:100%}
p,blockquote,dt,td.content{font-size:1em;orphans:3;widows:3}
h2,h3,#toctitle,.sidebarblock>.content>.title{page-break-after:avoid}
#toc,.sidebarblock,.exampleblock>.content{background:none!important}
#toc{border-bottom:1px solid #dddddf!important;padding-bottom:0!important}
body.book #header{text-align:center}
body.book #header>h1:first-child{border:0!important;margin:2.5em 0 1em}
body.book #header .details{border:0!important;display:block;padding:0!important}
body.book #header .details span:first-child{margin-left:0!important}
body.book #header .details br{display:block}
body.book #header .details br+span::before{content:none!important}
body.book #toc{border:0!important;text-align:left!important;padding:0!important;margin:0!important}
body.book #toc,body.book #preamble,body.book h1.sect0,body.book .sect1>h2{page-break-before:always}
.listingblock code[data-lang]::before{display:block}
#footer{padding:0 .9375em}
.hide-on-print{display:none!important}
.print-only{display:block!important}
.hide-for-print{display:none!important}
.show-for-print{display:inherit!important}}
@media print,amzn-kf8{#header>h1:first-child{margin-top:1.25rem}
.sect1{padding:0!important}
.sect1+.sect1{border:0}
#footer{background:none}
#footer-text{color:rgba(0,0,0,.6);font-size:.9em}}
@media amzn-kf8{#header,#content,#footnotes,#footer{padding:0}}
</style>
</head>
<body class="article toc2 toc-left">
<div id="header">
<h1>Lógica e Programação de Computadores</h1>
<div class="details">
<span id="author" class="author">Nota de Aula</span><br>
<span id="email" class="email"><a href="mailto:victor.silva@professores.ibmec.edu.br">victor.silva@professores.ibmec.edu.br</a></span><br>
</div>
<div id="toc" class="toc2">
<div id="toctitle">Table of Contents</div>
<ul class="sectlevel1">
<li><a href="#algoritmos">1. Algoritmos</a>
<ul class="sectlevel2">
<li><a href="#apresentacao_algoritmos">1.1. Apresentação dos Algoritmos</a></li>
<li><a href="#recursividade">1.2. Recursividade</a></li>
<li><a href="#complexidade_algoritmos">1.3. Complexidade de Algoritmos</a></li>
<li><a href="#notacao_o">1.4. A Notação O</a></li>
<li><a href="#algoritmos_otimos">1.5. Algoritmos Ótimos</a></li>
</ul>
</li>
<li><a href="#listas_lineares">2. Listas Lineares</a>
<ul class="sectlevel2">
<li><a href="#introducao">2.1. Introdução</a></li>
<li><a href="#alocacao_sequencial">2.2. Alocação Sequencial</a></li>
<li><a href="#listas_aloc_seq">2.3. Listas Lineares em Alocação Sequencial</a></li>
<li><a href="#pilhas_filas">2.4. Pilhas e Filas</a></li>
<li><a href="#alocacao_encadeada">2.5. Alocação encadeada</a></li>
<li><a href="#listas_lin_aloc_enc">2.6. Listas Lineares em Alocação Encadeada</a>
<ul class="sectlevel3">
<li><a href="#listas_sim_enc">2.6.1. Listas simplesmente encadeadas</a></li>
<li><a href="#pilhas_filas_aloc_enc">2.6.2. Pilhas e Filas</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#arvores">3. Árvores</a>
<ul class="sectlevel2">
<li><a href="#_introdução">3.1. Introdução</a></li>
<li><a href="#_definições_e_representações_básicas">3.2. Definições e representações básicas</a></li>
<li><a href="#_árvores_binárias">3.3. Árvores binárias</a>
<ul class="sectlevel3">
<li><a href="#_altura_de_árvores_binárias_completas">3.3.1. Altura de árvores binárias completas</a></li>
<li><a href="#_subárvore_e_subárvore_parcial">3.3.2. Subárvore e subárvore parcial</a></li>
<li><a href="#_árvore_m_ária">3.3.3. Árvore m-ária</a></li>
<li><a href="#_armazenamento_de_árvores">3.3.4. Armazenamento de árvores</a></li>
</ul>
</li>
<li><a href="#_percurso_em_árvores_binárias">3.4. Percurso em árvores binárias</a></li>
</ul>
</li>
<li><a href="#arvores_bin_busca">4. Árvores Binárias de Busca</a>
<ul class="sectlevel2">
<li><a href="#_introdução_2">4.1. Introdução</a></li>
<li><a href="#_conceitos_básicos">4.2. Conceitos básicos</a></li>
<li><a href="#_busca">4.3. Busca</a></li>
<li><a href="#_inserção">4.4. Inserção</a></li>
</ul>
</li>
<li><a href="#arvores_balanceadas">5. Árvores Balanceadas</a>
<ul class="sectlevel2">
<li><a href="#_introdução_3">5.1. Introdução</a></li>
<li><a href="#_o_conceito_de_balanceamento">5.2. O Conceito de Balanceamento</a></li>
<li><a href="#_árvores_avl">5.3. Árvores AVL</a>
<ul class="sectlevel3">
<li><a href="#_inclusão_em_árvores_avl">5.3.1. Inclusão em Árvores AVL</a></li>
<li><a href="#_implementação_da_inclusão">5.3.2. Implementação da Inclusão</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#alg_ordenacao">6. Algoritmos de Ordenação</a>
<ul class="sectlevel2">
<li><a href="#_introdução_4">6.1. Introdução</a></li>
<li><a href="#_ordenação_bolha_bubble_sort">6.2. Ordenação Bolha (<em>Bubble Sort</em>)</a></li>
<li><a href="#_ordenação_por_inserção">6.3. Ordenação por Inserção</a></li>
<li><a href="#_ordenação_por_intercalação_mergesort">6.4. Ordenação por Intercalação (<em>Mergesort</em>)</a></li>
<li><a href="#_ordenação_rápida_quicksort">6.5. Ordenação Rápida (<em>Quicksort</em>)</a></li>
</ul>
</li>
</ul>
</div>
</div>
<div id="content">
<div id="preamble">
<div class="sectionbody">
<div style="page-break-after: always;"></div>
</div>
</div>
<div class="sect1">
<h2 id="algoritmos">1. Algoritmos</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Um algoritmo é um processo sistemático para a resolução de um problema. O desenvolvimento de algoritmos é particularmente importante para problemas a serem solucionados em um computador, pela própria natureza do instrumento utilizado.</p>
</div>
<div class="paragraph">
<p>Existem dois aspectos básicos no estudo de algoritmos: a correção e a análise. O primeiro consiste em verificar a exatidão do método empregado, o que é realizado através de uma prova matemática. A análise visa à obtenção de parâmetros que possam avaliar a eficiência do algoritmo em termos de tempo de execução e memória ocupada. A análise é realizada através de um estudo do comportamento do algoritmo.</p>
</div>
<div class="paragraph">
<p>Um algoritmo computa uma saída, o resultado do problema, a partir de uma entrada, as informações inicialmente conhecidas e que permitem encontrar a solução do problema. Durante o processo de computação o algoritmo manipula dados, gerados a partir da sua entrada.</p>
</div>
<div class="paragraph">
<p>Quando os dados são dispostos e manipulados de uma forma homogênea, constituem um tipo abstrato de dados. Este é composto por um modelo matemático acompanhado por um conjunto de operações definido sobre esse modelo. Na representação do modelo matemático emprega-se uma estrutura de dados.</p>
</div>
<div class="paragraph">
<p>O estudo de estruturas de dados não pode ser desvinculado de seus aspectos algorítmicos. A escolha correta da estrutura adequada a cada caso depende diretamente do conhecimento de algoritmos para manipular a estrutura de maneira eficiente.</p>
</div>
<div class="sect2">
<h3 id="apresentacao_algoritmos">1.1. Apresentação dos Algoritmos</h3>
<div class="paragraph">
<p>Ao longo do curso, os algoritmos serão descritos através de uma linguagem de leitura simples. Contudo, para facilitar a sua interpretação será adotado o estilo do livre formato, quando conveniente.</p>
</div>
<div class="paragraph">
<p>As convenções seguintes serão utilizadas com respeito à linguagem:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>O início e o final de cada bloco são determinados por indentação, isto é, pela posição da margem esquerda. Se uma certa linha do algoritmo inicia um bloco, ele se estende até a última linha seguinte, cuja margem esquerda se localiza mais à direita do que a primeira do bloco;</p>
</li>
<li>
<p>A declaração de atribuição é indicada pelo símbolo <code>:=</code>;</p>
</li>
<li>
<p>As declarações seguintes são empregadas com significado semelhante ao usual:</p>
</li>
</ul>
</div>
<div class="listingblock">
<div class="content">
<pre>se... então
se... então... senão
enquanto... faça
para... faça
pare</pre>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p>Variáveis simples, vetores, matrizes e registro são considerados como tradicionalmente em linguagens de programação. Os elementos de vetores e matrizes são identificados por índices entre colchetes. Por exemplo, <code>A[5]</code> e <code>B[i, 3]</code> indicam, respectivamente, o quinto elemento do vetor <code>A</code> e o elemento identificado pelos índices <code>(i, 3)</code> da matriz <code>B</code>. No caso de registros, a notação <code>T.chave</code> indica o campo chave do registro <code>T</code>;</p>
</li>
<li>
<p>A referência a registros pode ser também realizada por meio de ponteiros, que armazenam endereços, com o uso do símbolo \$uarr\$ ou <code><strong></code>. Cada ponteiro é associado a um único tipo de registro. Por essa razão, o nome de registro pode ser omitido. Por exemplo, pt\$uarr\$.info (ou <code>pt</strong>.info</code>) representa o campo info de um registro alocado no endereço contido em <code>pt</code>;</p>
</li>
<li>
<p>São usados procedimentos e funções. A passagem de parâmetros é feita por referência, isto é, o endereço do parâmetro é transmitido para a rotina. Essa forma de transmissão possibilita a alteração do conteúdo da variável utilizada;</p>
</li>
<li>
<p>A sentença imediatamente posterior ao símbolo <code>%</code> deve ser interpretada como comentário.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Como exemplo, seja uma sequência de elementos armazenada no vetor S[i], com \$1 &lt;= i &lt;= n\$. Deseja-se inverter os elementos da sequência no vetor, isto é, considerá-la de trás para frente. Um algoritmo para resolver esse problema é simples. Basta trocar de posição o primeiro com o último elemento, em seguida o segundo com o antepenúltimo, e assim por diante. A formulação seguinte descreve o processo.</p>
</div>
<div id="inv_sequencia" class="listingblock">
<div class="title">Algoritmo 1. Inversão de uma sequência</div>
<div class="content">
<pre>para i := 1, ..., |__n/2__|
    temp := S[i]
    S[i] := S[n - i + 1]
    S[n - i + 1] := temp</pre>
</div>
</div>
<div class="paragraph">
<p>A notação <code>|<em>x</em>|</code>, ou \$|__x__|\$, que aparece no algoritmo, significa <em>piso de x</em> e representa o maior inteiro menor ou igual a <code>x</code>. Analogamente, <code>|<sub>x</sub>|</code> ou \$|~x~|\$ é o <em>teto de x</em> e corresponde ao menor inteiro maior ou igual a x. Assim, \$|__9/2__|=4\$ e \$|~9/2~|=5\$.</p>
</div>
</div>
<div class="sect2">
<h3 id="recursividade">1.2. Recursividade</h3>
<div class="paragraph">
<p>Um tipo especial de procedimento será utilizado, algumas vezes, ao longo do curso. É aquele que contém, em sua descrição, uma ou mais chamadas a si mesmo. Um procedimento dessa natureza é denominado <em>recursivo</em>, e a chamada a si mesmo é dita <em>chamada recursiva</em>. Naturalmente, todo procedimento, recursivo ou não, deve possuir pelo menos uma chamada proveniente de um local exterior a ele. Essa chamada é denominada <em>externa</em>. Um procedimento não recursivo é, pois, aquele em que todas as chamadas são externas.</p>
</div>
<div class="paragraph">
<p>De modo geral, a todo procedimento recursivo corresponde um outro não recursivo que executa, exatamente, a mesma computação. Contudo, a recursividade pode apresentar vantagens concretas. Frequentemente, os procedimentos recursivos são mais concisos do que um não recursivo correspondente. Além disso, muitas vezes é aparente a relação direta entre um procedimento recursivo e uma prova por indução matemática. Nesses casos, a verificação da correção pode se tornar mais simples. Entretanto, muitas vezes há desvantagens no emprego prático da recursividade. Um algoritmo não recursivo equivalente pode ser mais eficiente.</p>
</div>
<div class="paragraph">
<p>O exemplo clássico mais simples de recursividade é o cálculo do fatorial de um inteiro \$n&gt;=0\$. Um algoritmo recursivo para efetuar esse cálculo encontra-se descrito em seguida. A ideia do algoritmo é muito simples. Basta observar que o fatorial de <em>n</em> é <em>n</em> vezes o fatorial de <em>n - 1</em>, para \$n&gt;0\$. Por convenção, sabe-se que \$0!=1\$. No algoritmo a seguir, chamadas recursivas são representadas pela função \$fat\$. A chamada externa é \$fat(n)\$.</p>
</div>
<div id="fat_recursivo" class="listingblock">
<div class="title">Algoritmo 2. Fatorial (recursivo)</div>
<div class="content">
<pre>função fat(i)
    fat(i) := se i &lt;= 1 então 1 senão i * fat(i - 1)</pre>
</div>
</div>
<div class="paragraph">
<p>Para efeito de comparação, o <a href="#fat_nao_recursivo">Algoritmo 3</a> descreve o cálculo do fatorial de <em>n</em> de forma não recursiva. A variável <em>fat</em> representa, agora, um vetor e não mais uma função. O elemento <em>fat[n]</em> contém, no final, o valor do fatorial desejado.</p>
</div>
<div id="fat_nao_recursivo" class="listingblock">
<div class="title">Algoritmo 3. Fatorial (não recursivo)</div>
<div class="content">
<pre>fat[0] := 1
para j := 1, ..., n faça
    fat[j] := j * fat[j - 1]</pre>
</div>
</div>
<div class="paragraph">
<p>Um exemplo conhecido, onde a solução recursiva é natural e intuitiva, é o do <strong>Problema da Torre de Hanói</strong>. Este consiste em três pinos, A, B e C, denominados origem, destino e trabalho, respectivamente, e n discos de diâmetros diferentes. Inicialmente, todos os discos se encontram empilhados no pino-origem, em ordem decrescente de tamanho, de baixo para cima. O objetivo é empilhar todos os discos no pino-destino, atendendo às seguintes restrições: (i) apenas um disco pode ser movido de cada vez, e (ii) qualquer disco não pode ser jamais colocado sobre outro de tamanho menor.</p>
</div>
<div class="paragraph">
<p>A solução do problema é descrita a seguir. Naturalmente, para \$n&gt;1\$, o pino-trabalho deve ser utilizado como área de armazenamento temporário. O raciocínio utilizado para resolver o problema é semelhante ao de uma prova matemática por indução. Suponha que se saiba como resolver o problema até \$n-1\$ discos, \$n&gt;1\$, de forma recursiva. A extensão para <em>n</em> discos pode ser obtida pela realização dos seguintes passos:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Resolver o problema da Torre de Hanói para os \$n-1\$ discos do topo do pino-origem A, supondo que o pino-destino seja C e o trabalho seja B;</p>
</li>
<li>
<p>Mover o n-ésimo pino (maior de todos) de A para B;</p>
</li>
<li>
<p>Resolver o problema da Torre de Hanói para os \$n-1\$ discos localizados no pino C, suposto origem, considerando os pinos A e B como trabalho e destino, respectivamente.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Ao final desses passos, todos os discos se encontram empilhados no pino B e as duas restrições (i) e (ii) foram satisfeitas. O <a href="#torre_hanoi">Algoritmo 4</a> implementa o processo. O procedimento recursivo <code>hanoi</code> é utilizado com quatro parâmetros n, A, B e C, representando, respectivamente, o número de discos, o pino-origem, o destino e o trabalho.</p>
</div>
<div id="torre_hanoi" class="listingblock">
<div class="title">Algoritmo 4. Torre de Hanói</div>
<div class="content">
<pre>procedimento hanoi(n, A, B, C)
se n &gt; 0 então
    hanoi(n - 1, A, C, B)
    mover o disco do topo de A para B
    hanoi(n - 1, C, B, A)</pre>
</div>
</div>
<div class="paragraph">
<p>A <a href="#img_torre_hanoi">Figura 1</a> ilustra os passos efetuados pelo algoritmo. A chamada externa é <code>hanoi(n, A, B, C)</code>.</p>
</div>
<div id="img_torre_hanoi" class="imageblock">
<div class="content">
<img src="img/hanoi.png" alt="hanoi">
</div>
<div class="title">Figura 1. Problema da Torre de Hanói</div>
</div>
</div>
<div class="sect2">
<h3 id="complexidade_algoritmos">1.3. Complexidade de Algoritmos</h3>
<div class="paragraph">
<p>Conforme já mencionado, uma característica muito importante de qualquer algoritmo é o seu tempo de execução. Naturalmente, é possível determiná-lo através de métodos empíricos, isto é, obter o tempo de execução através da execução propriamente dita do algoritmo, considerando-se entradas diversas.</p>
</div>
<div class="paragraph">
<p>Em contrapartida, é possível obter uma ordem de grandeza do tempo de execução através de métodos analíticos. O objetivo desses métodos é determinar uma expressão matemática que traduza o comportamento de tempo de um algoritmo. Ao contrário do método empírico, o analítico visa aferir o tempo de execução de forma independente do computador utilizado, da linguagem e dos compiladores empregados e das condições locais de processamento.</p>
</div>
<div class="paragraph">
<p>As seguintes simplificações serão introduzidas para o modelo proposto:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Suponha que a quantidade de dados a serem manipulados pelo algoritmo seja suficientemente grande. Isto é, algoritmos cujas entradas consistam em uma quantidade reduzida de dados não serão considerados. Somente o comportamento assintótico será avaliado, ou seja, a expressão matemática fornecerá valores de tempo que serão válidos unicamente quando a quantidade de dados correspondente crescer o suficiente.</p>
</li>
<li>
<p>Não serão consideradas constantes aditivas ou multiplicativas na expressão matemática obtida. Isto é, a expressão matemática obtida será válida, a menos de tais constantes.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>É necessário, ainda, definir a variável em relação à qual a expressão matemática avaliará o tempo de execução. O próprio conceito de algoritmo oferece a sugestão. Um algoritmo opera a partir de uma entrada para produzir uma saída, dentro de um tempo que se deseja avaliar. A ideia é exprimir o tempo de execução em função da entrada.</p>
</div>
<div class="paragraph">
<p>O processo de execução de um algoritmo pode ser dividido em etapas elementares, denominadas <em>passos</em>. Cada passo consiste na execução de um número fixo de operações básicas cujos tempos de execução são considerados constantes. A operação básica de maior frequência de execução do algoritmo é denominada <em>operação dominante</em>. Como a expressão do tempo de execução do algoritmo será obtida a menos de constantes aditivas e multiplicativas, o número de passos de um algoritmo pode ser interpretado como sendo o número de execuções da operação dominante.</p>
</div>
<div class="paragraph">
<p>Por exemplo, em diversos algoritmos para ordenar os elementos de uma sequência dada, cada passo corresponde a uma comparação entre dois elementos da sequência. Na realidade, o número de passos de um algoritmo constitui a informação de que se necessita para avaliar o seu comportamento de tempo. Assim, um algoritmo de um único passo possui tempo de execução constante.</p>
</div>
<div class="paragraph">
<p>Portanto, a expressão matemática a ser definida, do tempo de execução de um algoritmo, pode ser apresentada como uma função que fornece o número de passos efetuados pelo algoritmo a partir de uma entrada.</p>
</div>
<div class="paragraph">
<p>Como exemplo, no <a href="#inv_sequencia">Algoritmo 1</a>, de inversão de sequência, cada entrada é uma sequência que se deseja inverter. O algoritmo efetua exatamente as mesmas operações para sequência de mesmo tamanho <em>n</em>. Cada passo corresponde à troca de posição entre dois elementos da sequência. Ou seja, à execução das três instruções de atribuição dentro do bloco <strong>para</strong> do algoritmo. O número de passos é, pois, igual ao número de execuções do bloco <strong>para</strong>, ou \$|__n/2__|\$, \$n&gt;1\$.</p>
</div>
<div class="paragraph">
<p>Como exemplos adicionais, considere os problemas de determinar as matrizes soma C e produto D de duas matrizes dadas, \$A=(a_ij)\$ e \$B=(b_ij)\$, ambas n x n. Nesse caso, C e D também possuem dimensão n x n e seus elementos \$c_ij\$ e \$d_ij\$ podem ser calculados, respectivamente, por:</p>
</div>
<div class="stemblock">
<div class="content">
\$c_ij=a_ij+b_ij\$<br>
\$d_ij=sum_(1&lt;=&lt;=n)(a_ij)*b_kj\$
</div>
</div>
<div class="paragraph">
<p>O <a href="#soma_matrizes">Algoritmo 5</a> descreve a computação da matriz soma de duas matrizes, enquanto o <a href="#produto_matrizes">Algoritmo 6</a> fornece o produto.</p>
</div>
<div id="soma_matrizes" class="listingblock">
<div class="title">Algoritmo 5. Soma de matrizes</div>
<div class="content">
<pre>para i := 1, ..., n faça
    para j := 1, ..., n faça
        C[i][j] := A[i][j] + B[i][j]</pre>
</div>
</div>
<div id="produto_matrizes" class="listingblock">
<div class="title">Algoritmo 6. Produto de matrizes</div>
<div class="content">
<pre>para i:= 1, ..., n faça
    para j := 1, ..., n faça
        C[i][j] := 0
        para k := 1, ..., n faça
            C[i][j] := C[i][j] + A[i][k] * B[k][j]</pre>
</div>
</div>
<div class="paragraph">
<p>Como no caso do <a href="#inv_sequencia">Algoritmo 1</a>, ambos os algoritmos de soma e produto efetuam as mesmas operações, respectivamente, sempre que A, B forem matrizes de mesma dimensão n x n. A variável independente é o parâmetro <em>n</em>. Cada passo do <a href="#soma_matrizes">Algoritmo 5</a> corresponde à execução de uma soma \$a_ij+b_ij\$, enquanto, no <a href="#produto_matrizes">Algoritmo 6</a>, corresponde ao produto \$a_ik*b_kj\$. O número total de passos é, pois, igual ao número total de somas \$a_ij+b_ij\$ e produtos \$a_ik*b_kj\$, respectivamente, para cada caso. Ou seja, o <a href="#soma_matrizes">Algoritmo 5</a> efetua n² passos, enquanto o <a href="#produto_matrizes">Algoritmo 6</a> efetua n³.</p>
</div>
<div class="paragraph">
<p>A noção de complexidade de tempo é descrita a seguir.</p>
</div>
<div class="paragraph">
<p>Seja A um algoritmo, \${E_1, ..., E_m}\$, o conjunto de todas as entradas possíveis de A. Denote por \$t_i\$ o número de passos efetuados por A, quando a entrada for \$E_i\$. Definem-se, com \$p_i\$ sendo a probabilidade de ocorrência da entrada \$E_i\$:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Complexidade do pior caso: \$max_(E_iinE){t_i}\$;</p>
</li>
<li>
<p>Complexidade do melhor caso: \$min_(E_iinE){t_i}\$;</p>
</li>
<li>
<p>Complexidade do caso médio: \$sum_(1&lt;=i&lt;=m)(p_i*t_i)\$.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>De forma análoga, podem ser definidas complexidades de espaço de um algoritmo.</p>
</div>
<div class="paragraph">
<p>As complexidades têm por objetivo avaliar a eficiência de tempo ou espaço. A complexidade de tempo de pior caso corresponde ao número de passos que o algoritmo efetua no seu pior caso de execução, isto é, para a entrada mais desfavorável. De certa forma, a complexidade de pior caso é a mais importante das três mencionadas. Ela fornece um limite superior para o número de passos que o algoritmo pode efetuar, em qualquer caso. Deste modo, o termo <em>complexidade</em> será empregado com o significado de complexidade de pior caso.</p>
</div>
</div>
<div class="sect2">
<h3 id="notacao_o">1.4. A Notação O</h3>
<div class="paragraph">
<p>Observe que as definições de complexidade da seção anterior implicam o atendimento das duas simplificações mencionadas no início do parágrafo. Em consequência, quando se considera o número de passos efetuados por um algoritmo, podem-se desprezar constantes aditivas ou multiplicativas. Por exemplo, um valor de número de passos igual a 3n será aproximado para n. Além disso, como o interesse é restrito a valores assintóticos, termos de menor grau também podem ser desprezados. Assim, um valor de número de passos igual a \$n^2+n\$ será aproximado para \$n^2\$. O valor \$6n^3 + 4n - 9\$ será transformado em \$n^3\$.</p>
</div>
<div class="paragraph">
<p>Torna-se útil, portanto, descrever operadores matemáticos que sejam capazes de representar situações como essas. As notações O, \$Omega\$ e \$Theta\$ serão utilizadas com essa finalidade.</p>
</div>
<div class="paragraph">
<p>Sejam f, h funções reais positivas de variável inteira n. Diz-se que f é \$O(h)\$, escrevendo-se \$f=O(h)\$, quando existir uma constante \$c&gt;0\$ e um valor inteiro \$n_o\$, tal que:</p>
</div>
<div class="stemblock">
<div class="content">
\$n&gt;n_o=&gt;f(n)&lt;=c*h(n)\$
</div>
</div>
<div class="paragraph">
<p>Ou seja, a função h atua como um limite superior para valores assintóticos da função f. Em seguida são apresentados alguns exemplos da notação O.</p>
</div>
<div class="stemblock">
<div class="content">
\$f=n^2-1=&gt;f=O(n^2)\$<br>
\$f=n^3-1=&gt;f=O(n^3)\$<br>
\$f=403=&gt;f=O(1)\$<br>
\$f=5+2logn+3log^2n=&gt;f=O(log^2n)\$
</div>
</div>
<div class="paragraph">
<p>As seguintes propriedades são úteis para manipular expressões em notação O. Elas decorrem diretamente da definição.</p>
</div>
<div class="paragraph">
<p>Sejam g, h funções reais positivas e k uma constante Então:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>\$O(g+h)=O(g)+O(h)\$;</p>
</li>
<li>
<p>\$O(k*g)=k*O(g)=O(g)\$.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Essas duas propriedades foram empregadas, implicitamente, nos exemplos anteriores.</p>
</div>
<div class="paragraph">
<p>A notação O será utilizada, ao longo deste curso, para exprimir complexidades. Por exemplo, seja determinar as complexidades de pior, melhor e caso médio dos algoritmos já apresentados neste capítulo. Todos eles apresentam a proprieda de o número de passos manter-se o mesmo quando aplicados a entradas diferentes do mesmo tamanho. Ou seja, para um mesmo valor de n o número de passos mantém-se constante. Como a variável independente é o valor n, conclui-se que as complexidades de pior, melhor e caso médio são todas iguais entre si para cada algoritmo. O <a href="#inv_sequencia">Algoritmo 1</a> efetua sempre \$|__n/2__|\$ passos. Logo, a complexidade é O(n). No <a href="#fat_nao_recursivo">Algoritmo 3</a>, o número de passos é igual ao número de produtos \$j*fat(j-1)\$, isto é, n. Sua complexidade, portanto, é O(n). Da mesma forma, verifica-se de imediato que as complexidades do <a href="#soma_matrizes">Algoritmo 5</a> e do <a href="#produto_matrizes">Algoritmo 6</a> são iguais a \$O(n^2)\$ e \$O(n^3)\$, respectivamente.</p>
</div>
<div class="paragraph">
<p>Para encontrar a complexidade de procedimentos recursivos, pode-se aplicar a seguinte técnica. Determina-se o número total de chamadas ao procedimento recursivo. Em seguida, calcula-se a complexidade da execução correspondente a uma única chamada, sem que se considerem as chamadas recursivas encontradas. A complexidade total será o produto do número de chamadas pela complexidade da computação de uma chamada isolada. Por exemplo, para calcular o fatorial de \$n&gt;0\$, de forma recursiva, o <a href="#fat_recursivo">Algoritmo 2</a> efetua um total de <em>n</em> chamadas ao procedimento <em>fat</em>. A complexidade da computação correspondente a uma chamada é constante, isto é, \$O(1)\$. De fato, para \$n&gt;1\$, apenas um produto é efetuado e, quando \$n&lt;=1\$, apenas uma atribuição é executada. Logo, a complexidade final do algoritmo é \$O(n)\$. A complexidade do <a href="#torre_hanoi">Algoritmo 4</a>, para resolver o problema da Torre de Hanói, é \$O(2^pi)\$.</p>
</div>
<div class="paragraph">
<p>A notação \$Theta\$, descrita a seguir, é útil para exprimir limites superiores justos. Sejam f, g funções reais positivas da variável inteira n. Diz-se que f é \$Theta(g)\$, escrevendo-se \$f=Theta(g)\$, quando ambas as condições \$f=O(g)\$ e \$g=O(f)\$ forem verificadas. A notação \$Theta\$ exprime o fato de que duas funções possuem a mesma ordem de grandeza assintótica. Por exemplo, se \$f=n^2-1\$, \$g=n^2\$ e \$h=n^3\$, então f é O(g), f é O(h), mas h não é O(f). Consequentemente, f é \$Theta(g)\$, mas f não é \$Theta(h)\$.</p>
</div>
<div class="paragraph">
<p>Assim como a notação O é útil para descrever limites superiores assintóticos, a notação \$Omega\$, definida a seguir, é empregada para limites inferiores assintóticos.</p>
</div>
<div class="paragraph">
<p>Sejam f, h funções reais positivas da variável inteira <em>n</em>. Diz-se que f é \$Omega(h)\$, escrevendo-se \$f=Omega(h)\$ quando existir uma constante \$c&gt;0\$ e um valor inteiro \$n_o\$ tal que:</p>
</div>
<div class="stemblock">
<div class="content">
\$n&gt;n_o=&gt;f(n)&gt;=c*h(n)\$
</div>
</div>
<div class="paragraph">
<p>Por exemplo, se \$f=n^2-1\$, então são válidas as igualdades \$f=Omega(n^2)\$, \$f=Omega(n)\$ e \$f=Omega(1)\$, mas não vale \$f=Omega(n^3)\$.</p>
</div>
</div>
<div class="sect2">
<h3 id="algoritmos_otimos">1.5. Algoritmos Ótimos</h3>
<div class="paragraph">
<p>A noção de complexidade está relacionada a um dado algoritmo. Ela visa determinar o número de passos efetuados por um algoritmo específico, sem levar em consideração a possível existência de outros algoritmos para o mesmo problema. Essa questão mais abrangente será abordada nessa seção.</p>
</div>
<div class="paragraph">
<p>Seja P um problema. Um <em>limite inferior para P</em> é uma função <em>l</em>, tal que a complexidade de pior caso de qualquer algoritmo que resolva P é \$Omega(l)\$. Isto é, todo algoritmo que resolve P efetua, pelo menos, \$Omega(l)\$ passos. Se existir um algoritmo A, cuja complexidade seja O(l), então A é denominado <strong>algoritmo ótimo</strong> para P. Nesse caso, o limite \$Omega(l)\$ é o melhor (maior) possível.</p>
</div>
<div class="paragraph">
<p>Intuitivamente, um algoritmo ótimo é aquele que apresenta a menor complexidade dentre todos os possíveis algoritmos para resolver o mesmo problema. Assim como a notação O é conveniente para exprimir complexidades, a notação \$Omega\$ é utilizada para limites inferiores.</p>
</div>
<div class="paragraph">
<p>Existem limites inferiores naturais, como, por exemplo, o tamanho da entrada. Todo possível algoritmo para o problema considerado deverá, necessariamente, efetuar a leitura da entrada. Assim, por exemplo, a entrada do <a href="#inv_sequencia">Algoritmo 1</a>,  de inversão de sequência, consiste em uma sequência de n elementos. Qualquer possível algoritmo para inverter a sequência deverá efetuar a sua leitura. Isto é, um limite inferior para o problema de inversão de sequência é \$Omega(n)\$. A complexidade do <a href="#inv_sequencia">Algoritmo 1</a> é O(n). Conclui-se, então, que ele é um algoritmo ótimo.</p>
</div>
<div style="page-break-after: always;"></div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="listas_lineares">2. Listas Lineares</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="introducao">2.1. Introdução</h3>
<div class="paragraph">
<p>Dentre as estruturas de dados não primitivas, as listas lineares são as de manipulação mais simples. Neste capítulo, são discutidos seus algoritmos e estruturas de armazenamento.</p>
</div>
<div class="paragraph">
<p>Uma lista linear agrupa informações referentes a um conjunto de elementos que, de alguma forma, se relacionam entre si. Ela pode se constituir, por exemplo, de informações sobre os funcionários de uma empresa, sobre notas de compras, itens de estoque, notas de alunos, etc. Na realidade, são inúmeros os tipos de dados que podem ser descritos por listas lineares.</p>
</div>
<div class="paragraph">
<p>Uma <em>lista linear</em>, ou <em>tabela</em>, é então um conjunto de \$n&gt;=0\$ nós L[1], L[2], &#8230;&#8203;, L[n] tais que suas propriedades estruturais decorrem, unicamente, da posição relativa dos nós dentro da sequência linear. Tem-se:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Se \$n&gt;0\$, L[1] é o primeiro nó;</p>
</li>
<li>
<p>Para \$1&lt;k&lt;=n\$, o nó L[k] é precedido por L[k - 1].</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>As operações mais frequentes em listas são a <em>busca</em>, a <em>inclusão</em> e a <em>remoção</em> de um determinado elemento, o que, aliás, ocorre na maioria das estruturas de dados. Tais operações podem ser consideradas como básicas e, por essa razão, é necessário que os algoritmos que as implementem sejam eficientes. Outras operações, também importantes, podem ser mencionadas: a alteração de um elemento da lista, a combinação de duas ou mais listas lineares em uma única, a ordenação dos nós segundo determinado campo, a determinação do primeiro (ou do último) nó da lista, a determinação da cardinalidade da lista e muitas outras, dependendo do problema em estudo.</p>
</div>
<div class="paragraph">
<p>Casos particulares de listas são de especial interesse. Se as inserções e remoções são permitidas apenas nas extremidades da lista, ela recebe o nome de <strong>deque</strong> (uma abreviatura do inglês <em>double ended queue</em>). Se as inserções e as remoções são realizadas somente em um extremo, a lista é denominada <strong>pilha</strong>, sendo denominada <strong>fila</strong> no caso em que as inserções são realizadas em um extremo e remoções em outro. Operações referentes a esses casos particulares serão analisadas individualmente.</p>
</div>
<div class="paragraph">
<p>O tipo de armazenamento de uma lista linear pode ser classificado de acordo com a posição relativa (sempre contígua ou não) na memória de dois nós consecutivos na lista. O primeiro caso corresponde à <em>alocação sequencial de memória</em>, enquanto o segundo é conhecido como <em>alocação encadeada</em>. A escolha de um ou outro tipo depende essencialmente das operações que serão executadas sobre a lista, do número de listas envolvidas na operação, bem como das características particulares dessas listas. Nas seções que se seguem, tais alocações e suas características serão discutidas.</p>
</div>
</div>
<div class="sect2">
<h3 id="alocacao_sequencial">2.2. Alocação Sequencial</h3>
<div class="paragraph">
<p>A maneira mais simples de se manter uma lista linear na memória do computador é colocar seus nós em posições contíguas. Nesse caso, o endereço real do (j + 1)-ésimo nó da lista se encontra \$c\$ unidades adiante daquele correspondente ao j-ésimo. A constante \$c\$ é o número de palavras de memória que cada nó ocupa. A correspondência entre o índice da tabela e o endereço real é feita automaticamente pela linguagem de programação quando da tradução do programa.</p>
</div>
<div class="paragraph">
<p>Como a implementação da alocação sequencial em linguagens de alto nível é geralmente realizada com a reserva prévia de memória para cada estrutura utilizada, a inserção e a remoção de nós não ocorrem de fato. Em vez disso utiliza-se algum tipo de simulação para essas operações (por exemplo, variáveis indicando os limites da memória realmente utilizada). Por essa razão, pode-se considerar tal alocação como uma <em>alocação estática</em>.</p>
</div>
<div class="paragraph">
<p>O armazenamento sequencial é particularmente atraente no caso de filas e pilhas porque, nessas estruturas, as operações básicas podem ser implementadas de forma bastante eficiente. Esse tratamento pode, contudo, se tornar oneroso em termos de memória quando se empregam diversas estruturas simultaneamente. Nesse caso, a utilização ou não do armazenamento sequencial dependeria de um estudo cuidadoso das opções existentes.</p>
</div>
<div class="paragraph">
<p>De início serão apresentadas as operações para listas genéricas.</p>
</div>
</div>
<div class="sect2">
<h3 id="listas_aloc_seq">2.3. Listas Lineares em Alocação Sequencial</h3>
<div class="paragraph">
<p>Seja uma lista linear. Cada nó é formado por <em>campos</em>, que armazenam as características distintas dos elementos da lista. Além disso, cada nó da lista possui, geralmente, um identificador, denominado <em>chave</em>. A chave, quando presente, se constitui em um dos campos do nó. Os nós podem se encontrar ordenados, ou não, segundo os valores de suas chaves. No primeiro caso a lista é denominada <em>ordenada</em>, e <em>não ordenada</em> no caso contrário.</p>
</div>
<div class="paragraph">
<p>Suponha uma lista linear, de nome <strong>L</strong>, que possui \$n\$ elementos. Um exemplo da constituição dessa tabela é apresentado na <a href="#exemplo_no">Figura 2</a>.</p>
</div>
<div id="exemplo_no" class="imageblock">
<div class="content">
<img src="img/exemplo_no.png" alt="exemplo no">
</div>
<div class="title">Figura 2. Exemplo de um nó</div>
</div>
<div class="paragraph">
<p>O <a href="#busca_elem_lista">Algoritmo 7</a> apresenta a busca de um nó na lista L, conhecendo-se sua chave. A variável \$x\$ corresponde à chave do nó procurado. A função <code>busca1</code> informa, ao final, o índice do nó que se deseja buscar; se este não for encontrado, o índice é nulo.</p>
</div>
<div id="busca_elem_lista" class="listingblock">
<div class="title">Algoritmo 7. Busca de um elemento na lista L</div>
<div class="content">
<pre>função busca1(x)
    i := 1
    busca1 := 0
    enquanto i &lt;= n faça
        se L[i].chave = x então
            % chave encontrada
            busca1 := i
            i := n + 1
        senão
            % pesquisa prossegue
            i:= i + 1</pre>
</div>
</div>
<div class="paragraph">
<p>Observe que, para cada elemento da tabela referenciado na busca, o algoritmo realiza dois testes: <code>i &#8656; n</code> e <code>L[i].chave = x</code>. Muitas vezes um pequeno artifício pode contribuir para a melhoria do processo. Por exemplo, o <a href="#busca_elem_lista2">Algoritmo 8</a> se propõe a efetuar a mesma busca que o <a href="#busca_elem_lista">Algoritmo 7</a>. A diferença entre os dois é a criação de um novo nó, que possui o valor procurado no campo chave, na posição <code>n + 1</code>. Dessa forma, o algoritmo sempre encontra um nó da tabela com as características desejadas, evitando o teste de fim de tabela.</p>
</div>
<div id="busca_elem_lista2" class="listingblock">
<div class="title">Algoritmo 8. Busca de um elemento na lista L</div>
<div class="content">
<pre>função busca(x)
    L[n + 1].chave := x
    i := 1
    enquanto L[i].chave != x faça
        i := i + 1
    se i != n + 1 então
        % elemento encontrado
        busca := i
    senão
        % elemento não encontrado
        busca := 0</pre>
</div>
</div>
<div class="paragraph">
<p>A complexidade de pior caso do <a href="#busca_elem_lista">Algoritmo 7</a> e do <a href="#busca_elem_lista2">Algoritmo 8</a> é \$O(n)\$. Entretanto, o segundo é de execução mais rápida, pois a cada iteração correspondem dois testes no <a href="#busca_elem_lista">Algoritmo 7</a> e apenas um no <a href="#busca_elem_lista2">Algoritmo 8</a>.</p>
</div>
<div class="paragraph">
<p>Quando a lista está ordenada, pode-se tirar proveito desse fato. Se o número procurado não pertence à lista, não há necessidade de percorrê-la até o final. A exemplo do <a href="#busca_elem_lista2">Algoritmo 8</a>, a dupla comparação no bloco principal do algoritmo também pode ser evitada por meio da criação de um novo nó. O <a href="#busca_elem_lista_ord">Algoritmo 9</a> mostra essa busca.</p>
</div>
<div id="busca_elem_lista_ord" class="listingblock">
<div class="title">Algoritmo 9. Busca de um elemento na lista L, ordenada</div>
<div class="content">
<pre>função busca-ord(x)
    L[n + 1].chave := x
    i := 1
    enquanto L[i].chave &lt; x faça
        i := i + 1
    se i = n + 1 ou L[i].chave != x então
        busca-ord := 0
    senão
        busca-ord := i</pre>
</div>
</div>
<div class="paragraph">
<p>Ainda no caso das listas ordenadas, um algoritmo diverso e bem mais eficiente pode ser apresentado: a <em>busca binária</em>. Em tabelas, o primeiro nó pesquisado é o que se encontra no meio; se a comparação não é positiva, metade da tabela pode ser abandonada na busca, uma vez que o valor procurado se encontra ou na metade inferior (se for menor), ou na metade superior (se for maior). Esse procedimento, aplicado recursivamente, esgota a tabela. O <a href="#busca_binaria">Algoritmo 10</a> apresenta a busca.</p>
</div>
<div id="busca_binaria" class="listingblock">
<div class="title">Algoritmo 10. Busca binária</div>
<div class="content">
<pre>função busca-bin(x)
    inf := 1
    sup := n
    busca-bin := 0
    enquanto inf &lt;= sup faça
        % índice a ser buscado
        meio := |__(inf + sup) / 2__|
        se L[meio].chave = x então
            % elemento encontrado
            busca-bin := meio
            inf := sup + 1
        senão se L[meio].chave &lt; x então
            inf := meio + 1
        senão
            sup := meio - 1</pre>
</div>
</div>
<div class="paragraph">
<p>A complexidade do algoritmo pode ser avaliada da seguinte forma. O pior caso ocorre quando o elemento procurado é o último a ser encontrado, ou mesmo não é encontrado. Na primeira iteração, a dimensão da tabela é <code>n</code>, e algumas operações são realizadas para situar o valor procurado. Na segunda, a dimensão se reduz a \$|__n/2__|\$, e assim sucessivamente. Ora, ao final, a dimensão da tabela é 1 (observe o teste <code>inf &#8656; sup</code>). Então, no pior caso:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>1ª iteração: a dimensão da tabela é <code>n</code>;</p>
</li>
<li>
<p>2ª iteração: a dimensão da tabela é <code>|<em>n / 2</em>|</code>;</p>
</li>
<li>
<p>3ª iteração: a dimensão da tabela é <code>|<em>(|</em>n / 2<em>|) / 2</em>|</code>;
&#8230;&#8203;</p>
</li>
<li>
<p>mª iteração: a dimensão da tabela é 1.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Ou seja, o número de iterações é, no máximo, \$1+|__log_2n__|\$. O tempo consumido pelas operações em cada iteração é constante. Logo, a complexidade da busca binária é \$O(logn)\$.</p>
</div>
<div class="paragraph">
<p>Ambas as operações de inserção e remoção utilizam o procedimento de busca. No primeiro caso, o objetivo é evitar chaves repetidas e, no segundo, a necessidade de localizar o elemento a ser removido. A construção desses algoritmos implica tarefas complementares, uma vez que a ação de um é o inverso da ação do outro. A implementação dessas operações deve, naturalmente, respeitar tal fato.</p>
</div>
<div class="paragraph">
<p>O <a href="#insercao_no">Algoritmo 11</a> apresenta a inserção de um nó contido na variável <code>novo</code> de chave <code>x</code>. O <a href="#remocao_no">Algoritmo 12</a> efetua a remoção de um nó sendo conhecido um de seus campos, no caso a chave <code>x</code>. Ambos os algoritmos consideram tabelas não ordenadas. A memória pressuposta disponível tem <code>M</code> posições (na realidade <code>M + 1</code>, porque é necessária uma posição extra para o procedimento de busca). Devem-se levar em conta as hipóteses de se tentar fazer inserções numa lista que já ocupa <code>M</code> posições (situação conhecida como <em>overflow</em>), bem como a tentativa de remoção de um elemento de uma lista vazia (<em>underflow</em>). A atitude a ser tomada em cada um desses casos depende do problema tratado. Por essa razão, os procedimentos de <em>overflow</em> e <em>underflow</em> são apenas indicados.</p>
</div>
<div class="paragraph">
<p>Como pode ser observado, o procedimento de inserção propriamente dito é bem simples, porém depende da busca que tem complexidade de \$O(n)\$. O algoritmo de remoção, além da busca, em geral efetua movimentação de nós, o que o torna ainda mais lento, se bem que também de complexidade \$O(n)\$.</p>
</div>
<div id="insercao_no" class="listingblock">
<div class="title">Algoritmo 11. Inserção de um nó na lista L</div>
<div class="content">
<pre>se n &lt; M então
    se busca(x) = 0 então
        L[n + 1] := novo-valor
        n := n + 1
    senão
        "elemento já existe na tabela"
senão
    "overflow"</pre>
</div>
</div>
<div id="remocao_no" class="listingblock">
<div class="title">Algoritmo 12. Remoção de um nó na lista L</div>
<div class="content">
<pre>se n != 0 então
    indice := busca(x)
    se indice != 0 então
        valor-recuperado := L[indice]
        para i := indice, n - 1 faça
            L[i] := L[i + 1]
        n := n - 1
    senão "elemento não se encontra na tabela"
senão
    "underflow"</pre>
</div>
</div>
<div class="paragraph">
<p>No caso de tabelas ordenadas, o algoritmo de remoção não se modifica. O algoritmo de inserção, entretanto, precisa ser refeito, uma vez que, nesse caso, a posição do nó se torna relevante. Isso implica movimentar parte da tabela, para permitir a inserção na posição correta, de maneira análoga à efetuada na remoção em listas não ordenadas (<a href="#remocao_no">Algoritmo 12</a>). A complexidade de ambos os algoritmos (inserção e remoção) é, então, O(n).</p>
</div>
<div class="paragraph">
<p>Observe que a utilização da busca binária diminui a complexidade da busca, mas não a da inserção ou da remoção. A complexidade dessas últimas operações é determinada pela movimentação dos nós.</p>
</div>
</div>
<div class="sect2">
<h3 id="pilhas_filas">2.4. Pilhas e Filas</h3>
<div class="paragraph">
<p>Em geral, o armazenamento sequencial de listas é empregado quando as estruturas, ao longo do tempo, sofrem poucas remoções e inserções. Em caso particulares de listas, esse armazenamento também é empregado. Nesse caso, a situação favorável é aquela em que inserções e remoções não acarretam movimentação de nós, o que ocorre se os elementos a serem inseridos e removidos estão em posições especiais, como a primeira ou a última posição. Deques, pilhas e filas satisfazem tais condições.</p>
</div>
<div class="paragraph">
<p>Na alocação sequencial de listas genéricas, considera-se sempre a primeira posição da lista no endereço 1 da memória disponível. Uma alternativa a essa estratégia consiste na utilização de indicadores especiais, denominados <em>ponteiros</em>, para o acesso a posições selecionadas. No caso da pilha, apenas um ponteiro precisa ser considerado, o ponteiro <em>topo</em>, pois as inserções e remoções são executadas na mesma estremidade da lista. A <a href="#operacoes_pilha">Figura 3</a> mostra uma sequência de operações realizadas numa pilha e o resultado de tais operações no ponteiro <em>topo</em>. Em seguida, o <a href="#insercao_pilha">Algoritmo 13</a> e o <a href="#remocao_pilha">Algoritmo 14</a> implementam a inserção e a remoção em uma pilha P, considerando-se a memória disponível de <code>M</code> posições. Os algoritmos levam em consideração as hipóteses de <em>overflow</em> e <em>underflow</em>. A pilha vazia tem <em>topo</em> nulo.</p>
</div>
<div id="operacoes_pilha" class="imageblock">
<div class="content">
<img src="img/operacoes_pilha.png" alt="operacoes pilha">
</div>
<div class="title">Figura 3. Operações em uma pilha</div>
</div>
<div id="insercao_pilha" class="listingblock">
<div class="title">Algoritmo 13. Inserção na pilha P</div>
<div class="content">
<pre>se topo != M então
    topo := topo + 1
    P[topo] := novo-valor
senão
    "overflow"</pre>
</div>
</div>
<div id="remocao_pilha" class="listingblock">
<div class="title">Algoritmo 14. Remoção da pilha P</div>
<div class="content">
<pre>Se topo != 0 então
    valor-recuperado := P[topo]
    topo := topo - 1
senão
    "underflow"</pre>
</div>
</div>
<div class="paragraph">
<p>A complexidade das operações apresentadas é constante, \$O(1)\$.</p>
</div>
<div class="paragraph">
<p>As filas exigem uma implementação um pouco mais elaborada. São necessários dois ponteiros:início de fila (<code>f</code>) e retaguarda (<code>r</code>). Para a adição de um elemento, move-se o ponteiro <code>r</code>; para a retirada, move-se o ponteiro <code>f</code>. A situação da fila vazia é representada por <code>f = r = 0</code>. Observe, na <a href="#operacoes_fila">Figura 4</a>, algumas operações realizadas em uma fila F.</p>
</div>
<div class="paragraph">
<p>Note que, após qualquer operação, deve-se sempre ter o ponteiro <code>f</code> indicando o início da fila, e <code>r</code>, a retaguarda. Isso implica, como já foi dito, movimentar o ponteiro <code>r</code> quando de uma inserção e o ponteiro <code>f</code> quando de uma remoção. Ora, pode-se observar na <a href="#operacoes_fila">Figura 4</a> que, à medida que os ponteiros são incrementados na memória disponível, a fila "se move", o que pode dar origem à false impressão de memória esgotada. Para eliminar esse problema, consideram-se os <code>M</code> nós alocados como se estivessem em círculo, onde <code>F[1]</code> segue <code>F[M]</code>. No algoritmo de inserção, a variável <code>prov</code> armazena provisoriamente a posição de memória calculada de forma a respeitar a circularidade, só sendo movimentado o ponteiro <code>r</code> se a operação for possível. A inicialização dos ponteiros <code>f</code> e <code>r</code> é <code>f = r = 0</code>.</p>
</div>
<div id="operacoes_fila" class="imageblock">
<div class="content">
<img src="img/operacoes_fila.png" alt="operacoes fila">
</div>
<div class="title">Figura 4. Operações em uma fila</div>
</div>
<div id="insercao_fila" class="listingblock">
<div class="title">Algoritmo 15. Inserção na fila F</div>
<div class="content">
<pre>prov := r mod M + 1
se prov != f então
    r := prov
    F[r] := novo-valor
    se f = 0 então
        f := 1
senão
    "overflow"</pre>
</div>
</div>
<div id="remocao_fila" class="listingblock">
<div class="title">Algoritmo 16. Remoção da fila F</div>
<div class="content">
<pre>se f != 0 então
    valor-recuperado := F[f]
    se f = r então
        f := 0
        r := 0
    senão
        f := f mod M + 1
senão
    "underflow"</pre>
</div>
</div>
<div class="paragraph">
<p>Também nesse caso a complexidade das operações é constante.</p>
</div>
</div>
<div class="sect2">
<h3 id="alocacao_encadeada">2.5. Alocação encadeada</h3>
<div class="paragraph">
<p>Já foi observado que o desempenho dos algoritmos que implementam operações realizadas em listas com alocação sequencial, mesmo sendo estes muito simples, pode ser bastante fraco. E mais, quando está prevista a utilização concomitante de mais de duas listas a gerência de memória se torna mais complexa. Nesses casos se justifica a utilização da alocação encadeada, também conhecida por alocação dinâmica, uma vez que posições de memórias são alocadas (ou desalocadas) na medida em que são necessárias (ou dispensadas). Os nós de uma lista encontram-se então aleatoriamente dispostos na memória e são interligados por ponteiros, que indicam a posição do próximo elemento da tabela. É necessário o acréscimo de um campo a cada nó, justamente o que indica o endereço do próximo nó da lista. A <a href="#aloc_seq_enc">Figura 5</a> apresenta uma lista linear em suas representações sequencial e encadeada.</p>
</div>
<div id="aloc_seq_enc" class="imageblock">
<div class="content">
<img src="img/aloc_seq_enc.png" alt="aloc seq enc">
</div>
<div class="title">Figura 5. Alocação sequencial e alocação encadeada</div>
</div>
<div class="paragraph">
<p>Há vantagens e desvantagens associadas a cada tipo de alocação. Estas, entretanto, só podem ser precisamente medidas ao se conhecerem as operações envolvidas na aplicação desejada. De maneira geral pode-se afirmar que a alocação encadeada, a despeito de um gasto de memória maior em virtude da necessidade de um novo campo no nó (o campo do ponteiro), é mais conveniente quando o problema inclui o tratamento de mais de uma lista. Isso se aplica tanto à gerência do armazenamento quanto às operações propriamente ditas envolvidas, como juntar listas, separar listas em sublistas, etc. Por outro lado, o acesso ao k-ésimo elemento da lista é imediato na alocação sequencial, enquanto na alocação encadeada obriga ao percurso na lista até o elemento desejado.</p>
</div>
<div class="paragraph">
<p>Como já foi visto, na alocação encadeada os nós de uma lista se encontram em posições não obrigatoriamente contíguas de memória. Se nessa lista são feitas inserções e remoções, há necessidade de encontrar novas posições de memória para armazenamento e liberar outras que possam ser reutilizadas posteriormente. Um algoritmo para gerenciar as posições de memória disponíveis é então imprescindível. Para tal é criada uma lista especial, chamada <strong>Lista de Espaço Disponível (LED)</strong>, que contém posições de memória ainda não utilizadas ou dispensadas após sua utilização. Note que a organização dessas posições disponíveis independe completamente da estrutura empregada na solução do problema em estudo. Entretanto, deve-se observar que a LED e as estruturas estão compartilhando a memória disponível.</p>
</div>
<div class="paragraph">
<p>As linguagens de progrmação geralmente possuem um módulo de gerência de memória disponível ao usuário, bastanto apenas que este se refira às rotinas internas de ocupação e devolução de nós da lista de espaço disponível. Em Pascal, por exemplo, as rotinas <code>new(pt)</code> e <code>dispose(pt)</code> executam essa tarefa. Nesse caso, uma notação diferente é utilizada nos algoritmos. Obviamente o nó na memória é o mesmo considerado até agora; a indicação do endereço desse nó, feita por um ponteiro, é que será representada pelo símbolo \$uarr\$ ou <code>*</code>. Cada ponteiro utilizado é associado a um único tipo de nó. Assim, por exemplo, <code>pt*.info</code> representa o campo <code>info</code> do nó apontado por <code>pt</code>. Um conjunto de nós encadeados forma uma tabela. A associação do ponteiro <code>pt</code> ao tipo de nó é definida previamente na declaração das variáveis.</p>
</div>
</div>
<div class="sect2">
<h3 id="listas_lin_aloc_enc">2.6. Listas Lineares em Alocação Encadeada</h3>
<div class="sect3">
<h4 id="listas_sim_enc">2.6.1. Listas simplesmente encadeadas</h4>
<div class="paragraph">
<p>Qualquer estrutura, inclusive listas, que seja armazenada em alocação encadeada requer o uso de um ponteiro que indique o endereço de seu primeiro nó. O percurso de uma lista é feito então a partir desse ponteiro. A ideia consiste em seguir consecutivamente pelos endereços existentes no campo que indica o próximo nó, da mesma forma que na alocação sequencial se acrescentava uma unidade ao índice do percurso. O <a href="#imp_lista">Algoritmo 17</a> apresenta o percurso para impressão do campo <code>info</code> de uma lista, sendo <code>ptlista</code> o ponteiro para o primeiro nó.</p>
</div>
<div id="imp_lista" class="listingblock">
<div class="title">Algoritmo 17. Impressão da lista apontada por ptlista</div>
<div class="content">
<pre>pont := ptlista
enquanto pont != lambda faça
    imprimir(pont*.info)
    pont := pont*.prox</pre>
</div>
</div>
<div class="paragraph">
<p>Como já foi mencionado na seção <a href="#listas_aloc_seq">Section 2.3</a>, o algoritmo de busca, por ser utilizado em inserções, remoções e outras operações, deve ser muito eficiente. Na alocação encadeada, essa necessidade persiste. E mais, surgem novos problemas: por exemplo, a existência de um ponteiro indicando o primeiro nó da lista obriga os algoritmos de inserção e remoção a apresentarem testes especiais para verificar se o nó desejado é o primeiro da lista. Isto pode ser resolvido por uma pequena variação na estrutura de armazenamento: a criação de um nó especial, chamado <em>nó-cabeça</em>, nunca removido, que passa a ser o nó indicado pelo ponteiro de início de lista. Esse nó especial não deve conter informações relacionadas à tabela propriamente dita. Algumas vezes, entretanto, pode ser aproveitado para conter dados pertinentes ao algoritmo implementado. A <a href="#no_cabeca">Figura 6</a> mostra a representação gráfica da lista encadeada com nó-cabeça, em sua situação inicial (vazia), e depois de algumas inserções.</p>
</div>
<div id="no_cabeca" class="imageblock">
<div class="content">
<img src="img/lista_enc_no_cabeca.png" alt="lista enc no cabeca">
</div>
<div class="title">Figura 6. Lista encadeada com nó cabeça</div>
</div>
<div class="paragraph">
<p>O <a href="#busca_enc">Algoritmo 18</a> implementa a busca em uma tabela ordenada, em alocação encadeada, de maneira simples. No caso aqui considerado, o nó-cabeça da tabela é apontado por <code>ptlista</code>. O parâmetro <code>x</code> fornece a chave procurada. O parâmetro <code>pont</code> retorna apontando para o elemento procurado, e <code>ant</code> para o elemento anterior ao procurado. Caso este não seja encontrado, <code>pont</code> aponta para <code>lambda</code> e <code>ant</code> indica ainda o elemento anterior ao último pesquisado. Deve-se notar que o parâmetro <code>ant</code>, apesar de aparentemente inútil, é importante para os algoritmos de inserção e remoção, que serão vistos a seguir. Como o algoritmo estabelece um percurso pela tabela, sua complexidade é \$O(n)\$, sendo <code>n</code> o número de nós da lista.</p>
</div>
<div id="busca_enc" class="listingblock">
<div class="title">Algoritmo 18. Busca em uma lista ordenada</div>
<div class="content">
<pre>procedimento busca-enc(x, ant, pont)
    ant := ptlista
    pont := lambda
    % ponteiro de percurso
    ptr := ptlista*.prox
    enquanto ptr != lambda faça
        se ptr*.chave &lt; x então
            % atualiza ant e ptr
            ant := ptr
            ptr := ptr*.prox
        senão se ptr*.chave = x então
            % chave encontrada
            pont := ptr
            ptr := lambda</pre>
</div>
</div>
<div class="paragraph">
<p>Após a realização da busca, as operações de inserção e remoção em uma lista encadeada são triviais. Há três fases a serem cumpridas: a comunicação com a LED, o acesso ao campo de informações do nó e o acerto de estrutura. As operações de inserção e remoção realizam essas fases em ordem inversa. A <a href="#insercao_enc">Figura 7</a> e o <a href="#insercao_enc_alg">Algoritmo 19</a> mostram a inserção do nó contido na variável <code>novo</code>, após o nó apontado por <code>ant</code>. No algoritmo, as três fases se encontram assinaladas pelos comentários.</p>
</div>
<div id="insercao_enc" class="imageblock">
<div class="content">
<img src="img/insercao_enc.png" alt="insercao enc">
</div>
<div class="title">Figura 7. Inserção de um nó</div>
</div>
<div id="insercao_enc_alg" class="listingblock">
<div class="title">Algoritmo 19. Inserção de um nó após o nó apontado por busca-enc(x, ant, pont)</div>
<div class="content">
<pre>se pont = lambda então
    % solicitar nó
    ocupar(pt)
    % inicializar nó
    pt*.info := novo-valor
    % acertar lista
    pt*.chave := x
    pt*.prox := ant*.prox
    ant*.prox := pt
senão
    "elemento já está na tabela"</pre>
</div>
</div>
<div class="paragraph">
<p>A remoção do nó apontado por <code>pont</code> é apresentado na <a href="#remocao_enc">Figura 8</a> e no <a href="#remocao_enc_alg">Algoritmo 20</a>. Observe as fases mencionadas nos comentários do algoritmo. A complexidade dessas operações é, em virtude da busca, \$O(n)\$.</p>
</div>
<div id="remocao_enc" class="imageblock">
<div class="content">
<img src="img/remocao_enc.png" alt="remocao enc">
</div>
<div class="title">Figura 8. Remoção de um nó</div>
</div>
<div id="remocao_enc_alg" class="listingblock">
<div class="title">Algoritmo 20. Remoção do nó apontado por pont na lista</div>
<div class="content">
<pre>busca-enc(x, ant, pont)
se pont != lambda então
    % acertar lista
    ant*.prox := pont*.prox
    % utilizar nó
    valor-recuperado := pont*.info
    % devolver nó
    desocupar(pont)
senão
    "nó não se encontra na tabela"</pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="pilhas_filas_aloc_enc">2.6.2. Pilhas e Filas</h4>
<div class="paragraph">
<p>Como casos particulares, algumas modificações são necessárias para implementar operações eficientes em pilhas e filas. No caso de pilhas, as operações são muito simples. Considerando-se listas simplesmente encadeadas (sem nó-cabeça), o topo da pilha é o primeiro nó da lista, apontado por uma variável ponteiro <code>topo</code>. Se a pilha estiver vazia então <code>topo = lambda</code>. Filas exigem duas variáveis do tipo ponteiro: <code>inicio</code>, que aponta para o primeiro nó da lista, e <code>fim</code>, que aponta para o último. Na fila vazia, ambos apontam para \$lambda\$. Os algoritmos que se seguem implementam essas operações.</p>
</div>
<div id="insercao_pilha_enc" class="listingblock">
<div class="title">Algoritmo 21. Inserção na pilha</div>
<div class="content">
<pre>% solicitar nó
ocupar(pt)
% inicializar nó
pt*.info := novo-valor
pt*.prox := topo
% acertar pilha
topo := pt</pre>
</div>
</div>
<div id="remocao_pilha_enc" class="listingblock">
<div class="title">Algoritmo 22. Remoção da pilha</div>
<div class="content">
<pre>se topo != lambda então
    % acertar pilha
    pt := topo
    topo := topo*.prox
    % utilizar nó
    valor-recuperado := pt*.info
    % devolver nó
    desocupar(pt)
senão
    "underflow"</pre>
</div>
</div>
<div id="insercao_fila_enc" class="listingblock">
<div class="title">Algoritmo 23. Inserção na fila</div>
<div class="content">
<pre>% solicitar nó
ocupar(pt)
% inicializar nó
pt*.info := novo-valor
pt*.prox := lambda
% acertar fila
se fim != lambda então
    fim*.prox := pt
senão inicio := pt
fim := pt</pre>
</div>
</div>
<div id="remocao_fila_enc" class="listingblock">
<div class="title">Algoritmo 24. Remoção da fila</div>
<div class="content">
<pre>se inicio != lambda então
    pt := inicio
    % acertar fila
    inicio := inicio*.prox
    se inicio = lambda então
        fim := lambda
    % utilizar nó
    valor-recuperado := pt*.info
    % devolver nó
    desocupar(pt)
senão
    "underflow"</pre>
</div>
</div>
<div class="paragraph">
<p>As complexidades dos algoritmos de manipulação de filas e pilhas são constantes, ou seja, \$O(1)\$, uma vez que buscas não são empregadas.</p>
</div>
<div style="page-break-after: always;"></div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="arvores">3. Árvores</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_introdução">3.1. Introdução</h3>
<div class="paragraph">
<p>Em diversas aplicações necessita-se de estruturas mais complexas do que as puramente sequenciais, examinadas no capítulo anterior. Entre essas, destacam-se as árvores, por existirem inúmeros problemas práticos que podem ser modelados através delas. Além disso, as árvores, em geral, admitem um tratamento computacional simples e eficiente. Isso não pode ser dito de estruturas mais gerais do que as árvores, como os grafos, por exemplo.</p>
</div>
<div class="paragraph">
<p>Neste capítulo são apresentados os conceitos iniciais relativos às árvores, bem como os algoritmos para sua manipulação computacional básica.</p>
</div>
</div>
<div class="sect2">
<h3 id="_definições_e_representações_básicas">3.2. Definições e representações básicas</h3>
<div class="paragraph">
<p>Uma <strong>árvore enraizada T</strong>, ou simplesmente <strong>árvore</strong>, é um conjunto finito de elementos denominados <em>nós</em> ou <em>vértices</em> tais que:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>\$T=O/\$, e a árvore é dita <em>vazia</em>; ou</p>
</li>
<li>
<p>Existe um nó especial chamado <em>raiz</em> de \$T(r(T))\$; os restantes constituem um único conjunto vazio ou são divididos em \$m&gt;=1\$ conjuntos disjuntos não vazios, as subárvores de \$r(T)\$, ou simplesmente <strong>subárvores</strong>, cada qual, por sua vez, uma árvore.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Uma floresta é um conjunto de árvores. Se <em>v</em> é um nó de <em>T</em>, a notação \$T(v)\$ indica a subárvore de <em>T</em> com raiz <em>v</em>.</p>
</div>
<div class="paragraph">
<p>Para visualizar esse conceito, pode-se representá-lo graficamente. Há formas diferentes de representações gráficas de uma árvore. Em todas elas cada nó poderá ser associado a um identificador, denominado <em>rótulo</em>. Observa-se, contudo, que o estudo das árvores pode prescindir do uso desse identificador e basear-se unicamente na posição relativa de seus nós na estrutura.</p>
</div>
<div class="paragraph">
<p>A representação mais próxima da definição é o diagrama de inclusão, apresentado na <a href="#diagrama_inclusao">Figura 9</a>, representação tradicionalmente utilizada para conjuntos. Na figura, a raiz de T é o nó A, o qual possui duas subárvores: a formada pelo único nó B e aquela cuja raiz é C e que contém todos os demais nós, e assim por diante. Os rótulos dos nós são A, B, &#8230;&#8203;, H, respectivamente.</p>
</div>
<div id="diagrama_inclusao" class="imageblock">
<div class="content">
<img src="img/diagrama_inclusao.png" alt="diagrama inclusao">
</div>
<div class="title">Figura 9. Diagrama de inclusão</div>
</div>
<div class="paragraph">
<p>A forma mais comum de representar graficamente uma árvore é através de sua representação hierárquica, semelhante à utilizada para descrever organogramas de uma empresa. A <a href="#representacoes_hierárquicas">[representacoes_hierárquicas]</a>, figura (a), ilustra uma tal representação que descreve a mesma árvore da <a href="#diagrama_inclusao">Figura 9</a>. Nessa representação existe uma linha unindo cada nó às raízes de suas subárvores, quando não vazias, as quais se encontram sempre abaixo (acima) desse nó. Conforme a escolha dessa posição, abaixo ou acima, tem-se as representações da <a href="#representacoes_hierarquicas">Figura 10</a>. A representação herárquica é, de longe, a mais utilizada para visualizar uma árvore, pela forma clara como exibe as relações existentes entre os nós da estrutura. Além disso, do ponto de vista computacional, essa representação já sugere uma forma adequada de dispor os dados no computador, como se verá mais adiante.</p>
</div>
<div id="representacoes_hierarquicas" class="imageblock">
<div class="content">
<img src="img/representacoes_hierarquicas.png" alt="representacoes hierarquicas">
</div>
<div class="title">Figura 10. Representações hierárquicas</div>
</div>
<div class="paragraph">
<p>Seja v o nó raiz da subárvore T(v) de T. Os nós raízes w1, w2, &#8230;&#8203;, wj das subárvores de T(v) são chamados filhos de v; v é chamado pai de w1, w2, &#8230;&#8203;, wj. Os nós w1, w2, &#8230;&#8203;, wj são irmãos. Se z é filho de w1, então w2 é tio de z e v é avô de z. O número de filhos de um nó é chamado de grau de saída desse nó. Se x pertence à subárvore T(v), x é descendente de v, e v é ancestral de x. Nesse caso, sendo x diferente de v, x é descendente próprio de v, e v é ancestral próprio de x.</p>
</div>
<div class="paragraph">
<p>Um nó que não possui descendentes próprios é chamado de folha. Toda árvore com \$n&gt;1\$ nós possui no mínimo 1 e no máximo \$n-1\$ folhas. Um nó não folha é dito interior.</p>
</div>
<div class="paragraph">
<p>Uma sequência de nós distintos v1, v2, &#8230;&#8203;, vk, tal que existe sempre entre nós consecutivos (v1 e v2, v2 e v3, &#8230;&#8203;, vk-1 e vk) a relação "é filho de" ou "é pai de", é denominada caminho da árvore. Diz-se que v1 alcança vk e vice-versa. Um caminho de k vértices é obtido pela sequência de \$k-1\$ pares da relação. O valor \$k-1\$ é o comprimento do caminho. Nível de um nó v é o número de nós do caminho da raiz até o nó v. O nível da raiz é, portanto, igual a 1. A altura de um nó v é o número de nós do maior caminho de v até um de seus descendentes. As folhas têm altura 1. A altura da árvore T é igual ao nível máximo de seus nós. Representa-se a altura de T por h(T), enquanto h(v) é a altura da subárvore de raiz v.</p>
</div>
<div class="paragraph">
<p>Uma árvore ordenada é aquela na qual os filhos de cada nó estão ordenados. Assume-se que tal ordenação se desenvolva da esquerda para a direita. Assim, as árvores da figura <a href="#isomorfismo">Figura 11</a> são distintas se consideradas como ordenadas. Contudo, elas podem se tornar coincidentes mediante uma reordenação de nós irmãos.</p>
</div>
<div id="isomorfismo" class="imageblock">
<div class="content">
<img src="img/isomorfismo.png" alt="isomorfismo">
</div>
<div class="title">Figura 11. Exemplo de isomorfismo</div>
</div>
<div class="paragraph">
<p>De modo geral, duas árvores não ordenadas são isomorfas quando puderem se tornar coincidentes através de uma permutação na ordem das subárvores de seus nós. As árvores da <a href="#isomorfismo">Figura 11</a> são, então, isomorfas. Por outro lado, duas árvores ordenadas são isomorfas quando forem coincidentes, segundo a ordenação existente entre os seus nós.</p>
</div>
</div>
<div class="sect2">
<h3 id="_árvores_binárias">3.3. Árvores binárias</h3>
<div class="paragraph">
<p>Conforme já mencionado, as árvores constituem as estruturas não sequenciais com maior aplicação em computação. Dentre as árvores, as binárias são, sem dúvida, as mais comuns.</p>
</div>
<div class="paragraph">
<p>Uma <em>árvore binária T</em> é um conjunto finito de elementos denominados nós ou vértices, tal que:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>\$T=O/\$, e a árvore é dita <em>vazia</em>; ou</p>
</li>
<li>
<p>Existe um nó especial chamado <em>raiz</em> de \$T(r(T))\$; e os restantes podem ser divididos em dois subconjuntos disjuntos, \$T_E(r(T))\$ e \$T_D(r(T))\$, a subárvore esquerda e a direita da raiz, respectivamente, as quais são também árvores binárias.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>A raiz da subárvore esquerda (direita) de um nó v, se existir, é denominada filho esquerdo (direito) de v. Naturalmente, o esquerdo pode existir sem o direito e vice-versa. Analogamente à seção anterior, a notação T(v) indica a (sub) árvore binária, cuja raiz é v e cujas subárvores esquerda e direita de T são \$T_E(v)\$ e \$T_D(v)\$, respectivamente.</p>
</div>
<div class="paragraph">
<p>A <a href="#arvore_binaria_a">Figura 12</a> ilustra um exemplo de árvore binária T. O nó A é raiz de T, enquanto \$T_E(A)\$ e \$T_D(A)\$ são as árvores binárias de T com raízes em B e C, respectivamente. O filho esquerdo de A é o nó B e o direito é C. O nó B possui D como filho esquerdo, mas não possui filho direito.</p>
</div>
<div id="arvore_binaria_a" class="imageblock">
<div class="content">
<img src="img/arvore_binaria_a.png" alt="arvore binaria a">
</div>
<div class="title">Figura 12. Árvore binária</div>
</div>
<div id="arvore_binaria_b" class="imageblock">
<div class="content">
<img src="img/arvore_binaria_b.png" alt="arvore binaria b">
</div>
<div class="title">Figura 13. Árvore binária</div>
</div>
<div class="paragraph">
<p>Observando atentamente as definições apresentadas, verifica-se que a árvore binária não obedece rigidamente à definição de árvore. Por exemplo, uma árvore binária pode ter duas subárvores vazias (a esquerda e a direita), enquando o mesmo não ocorre com árvores gerais. Devem-se, portanto, considerar árvores binárias como uma extensão do caso geral. Observe as figuras anteriores. As estruturas são idênticas (isomorfas) se consideradas como árvores, mesmo se forem ordenadas, porém são distintas como árvores binárias.</p>
</div>
<div class="paragraph">
<p>Toda árvore binária com n nós possui exatamente \$n+1\$ subárvores vazias entre suas subárvores esquerdas e direitas. Por exemplo, a árvore da <a href="#arvore_binaria_a">Figura 12</a> possui 9 nós e 10 subárvores vazias: as subárvores esquerda e direita dos nós F, G, H, I e as subárvores direitas de B e D.</p>
</div>
<div class="paragraph">
<p>Em seguida, são introduzidos alguns tipos especiais de árvores binárias, bastante utilizadas, e que serão mencionadas nos próximos capítulos.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Uma <em>árvore estritamente binária</em> é uma árvore binária em que cada nó possui 0 ou 2 filhos;</p>
</li>
<li>
<p>Uma <em>árvore binária completa</em> é aquela que apresenta a seguinte propriedade: se v é um nó tal que alguma subárvore de v é vazia, então v se localiza ou no último (maior) ou no penúltimo nível da árvore;</p>
</li>
<li>
<p>Uma <em>árvore binária cheia</em> é aquela em que, se v é um nó com alguma de suas subárvores vazias, então v se localiza no último nível. Segue-se que toda árvore binária cheia é completa e estritamente binária.</p>
</li>
</ul>
</div>
<div id="exemplos_arvores" class="imageblock">
<div class="content">
<img src="img/exemplos_arvores.png" alt="exemplos arvores">
</div>
<div class="title">Figura 14. Árvores estritamente binária (esq.), binária completa (meio) e cheia</div>
</div>
<div class="paragraph">
<p>A relação entre a altura de uma árvore binária e o seu número de nós é um dado importante para várias aplicações. Para um valor fixo de n, indagar-se-ia quais são as árvore binárias que possuem altura h máxima e mínima. A resposta ao primeiro problema é imediata. A árvore binária que possui altura máxima é aquela cujos nós interiores possuem exatamente uma subárvore vazia. Essas árvores são denominadas <em>zigue-zague</em> e encontram-se ilustradas na <a href="#zigue-zague">Figura 15</a>. Naturalmente, a altura de uma árvore zigue-zague é igual a n. Por outro lado, uma árvore completa sempre apresenta altura mínima, conforme é visto a seguir.</p>
</div>
<div id="zigue-zague" class="imageblock">
<div class="content">
<img src="img/zigue-zague.png" alt="zigue zague">
</div>
<div class="title">Figura 15. Árvores zigue-zague</div>
</div>
<div class="sect3">
<h4 id="_altura_de_árvores_binárias_completas">3.3.1. Altura de árvores binárias completas</h4>
<div class="paragraph">
<p>Seja T uma árvore binária completa com \$n&gt;0\$ nós. Então T possui altura h mínima. Além disso, \$h=1+|__logn__|\$.</p>
</div>
<div class="paragraph">
<p><strong>Demonstração:</strong> Seja T' uma árvore binária de alturma mínima com n nós. Se T' é também completa, então T e T' possuem a mesma altura, isto é, T possui altura mínima. Se T' não é completa, efetua-se a seguinte operação: retirar uma folha w de seu último nível e tornar w o filho de algum nó v que possui alguma de suas subárvores vazias, localizado em algum nível acima do penúltimo. Repete-se a operação até que não seja mais possível realizá-la, isto é, até que a árvore T'', resultante da transformação, seja completa. T'' não pode ter altura inferior a T', pois T' é mínima. T'' não pode ter altura superior a T', pois nenhum nó foi movido para baixo. Então as alturas de T' e T'' são iguais. Como T' é completa, conclui-se que as alturas de T e T'' também coincidem. Isto é, T possui altura mínima.</p>
</div>
<div class="paragraph">
<p>Para mostrar que \$h=1+|__logn__|\$, recorre-se à indução. Se \$n=1\$, então \$h=1+|__logn__| = 1\$, correto. Quando \$n&gt;1\$, suponha o resultado verdadeiro para todas as árvores binárias completas com até \$n-1\$ nós. Seja T' a árvore obtida de T pela remoção de todos os nós, em número de k, do último nível. Logo, T' é uma árvore cheia com \$n'=n-k\$ nós. Pela hipótese de indução, \$h(T')=1+|__logn'__|\$. Como T' é cheia, \$n'=2^m-1\$, para algum inteiro \$m&gt;0\$. Isto é, \$h(T') = m\$. Além disso, \$1&lt;=k&lt;=n'+1\$. Assim:</p>
</div>
<div class="stemblock">
<div class="content">
\$h(T)=1+h(T')=1+m=1+log(n'+1)=1+|__log(n'+k)__|=1+|__logn__|\$
</div>
</div>
</div>
<div class="sect3">
<h4 id="_subárvore_e_subárvore_parcial">3.3.2. Subárvore e subárvore parcial</h4>
<div class="paragraph">
<p>Seja T uma árvore (ou uma árvore binária) e v um nó de T. Seja T(v) a subárvore de T de raiz v, e S um conjunto de nós T(v) tal que T(v) - S é uma árvore. A árvore T' = T(v) - S é chamada <em>subárvore parcial</em> de raiz v. Observe, por exemplo, a árvore T da <a href="#subarvore">Figura 16</a>, à esquerda. A árvore da imagem, ao centro, é subárvore de T de raiz E, enquanto a árvore à direita é uma subárvore parcial de T de raiz E, porém não é subárvore de T. Observe que a diferença entre uma subárvore de raiz v e uma subárvore parcial de raiz v é que a primeira contém obrigatoriamente todos os descendentes de v, enquanto a segunda, não necessariamente.</p>
</div>
<div id="subarvore" class="imageblock">
<div class="content">
<img src="img/subarvore.png" alt="subarvore">
</div>
<div class="title">Figura 16. Subárvore e subárvore parcial</div>
</div>
</div>
<div class="sect3">
<h4 id="_árvore_m_ária">3.3.3. Árvore m-ária</h4>
<div class="paragraph">
<p>Uma <em>árvore m-ária T</em>, \$m&gt;=2\$, é um conjunto finito de elementos, denominados nós ou vértices, tais que:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>\$T=O/\$, e a árvore é dita <em>vazia</em>; ou</p>
</li>
<li>
<p>Existe um nó especial chamado <em>raiz</em> de \$T(r(T))\$; e os restantes podem ser divididos em m subconjuntos disjuntos, as <em>i-ésimas</em> subárvores de r(T), \$1&lt;=i&lt;=m\$, as quais são também árvores m-árias.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>A raiz da i-ésima subárvore de um nó v de T, se existir, é denominada i-ésimo filho de v. Naturalmente, a árvore m-ária é uma generalização da árvore binária em que cada nó possui m subárvores. A árvore m-ária possui uma ordenação implícita nas subárvores de cada nó, mesmo que algumas ou todas essas subárvores sejam vazias.</p>
</div>
<div class="paragraph">
<p>Analogamente ao caso binário, podem-se definir <em>árvore estritamente m-ária</em>, <em>árvore m-ária completa</em> e <em>cheia</em>.</p>
</div>
<div class="paragraph">
<p>A importância das árvores m-árias de um modo geral e, em especial, da árvore binária decorre do número constante de subárvores de cada nó e de sua ordenação implícita. Quando surge o problema de como representar uma árvore internamente no computador, observa-se o fato de que este estabelece, necessariamente, uma ordem implícita nos dados, por características de construção. Assim sendo, pode-se aproveitar a compatibilidade entre essas duas ordenações e eleger a árvore m-ária para representá-la na memória de um computador. Além disso, o número constante de subárvores de cada nó em muito simplifica a representação. Os detalhes são apresentados a seguir.</p>
</div>
</div>
<div class="sect3">
<h4 id="_armazenamento_de_árvores">3.3.4. Armazenamento de árvores</h4>
<div class="paragraph">
<p>O armazenamento de árvores pode utilizar alocação sequencial ou encadeada. As vantagens e desvantagens de uma e outra já foram mencionadas no capítulo anterior. Sendo a árvore uma estrutura mais complexa do que listas lineares, as vantagens na utilização da alocação encadeada prevalecem.</p>
</div>
<div class="paragraph">
<p>Não é difícil observar que a estrutura de armazenamento para árvores deve conter, em cada nó, ponteiros para seus filhos. A disposição mais econômica consiste em limitar o número de filhos a dois, exatamente o caso de árvores binárias. Note que o número de subárvores vazias cresce com o aumento do parâmetro m das árvores m-árias. Para um dado valor de n, a árvore binária é aquela que minimiza o número de ponteiros necessários.</p>
</div>
<div class="paragraph">
<p>O armazenamento de uma árvore binária surge naturalmente de sua definição. Cada nó deve possuir dois campos de ponteiros, <em>esq</em> e <em>dir</em>, que apontam para as suas subárvores esquerda e direita, respectivamente. O ponteiro <em>ptraiz</em> indica a raiz da árvore. Da mesma forma que na alocação encadeada de listas lineares, a memória é inicialmente considerada uma lista de espaço disponível. Os campos do nó da árvore que contém as informações pertinentes ao problema serão aqui representados como um só campo de nome <em>info</em>. Excetuando-se este último, necessita-se, então de \$2n+1\$ unidades de memória para representar uma árvore binária com n nós.</p>
</div>
<div class="paragraph">
<p>A <a href="#arm_arv_binaria">Figura 17</a> ilustra a estrutura de ponteiros usada no armazenamento de uma árvore binária.</p>
</div>
<div id="arm_arv_binaria" class="imageblock">
<div class="content">
<img src="img/armazenamento_arv_binaria.png" alt="armazenamento arv binaria">
</div>
<div class="title">Figura 17. Armazenamento de uma árvore binária</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_percurso_em_árvores_binárias">3.4. Percurso em árvores binárias</h3>
<div class="paragraph">
<p>Nesta seção são apresentados algoritmos para efetuar um <em>percurso</em> em uma árvore binária. Por percurso entende-se uma visita sistemática a cada um de seus nós; esta é uma das operações básicas relativas à manipulação de árvores. Uma árvore é, essencialmente, uma estrutura não sequencial. Por isso mesmo, ela pode ser utilizada em aplicações que demandem acesso direto. Contudo, mesmo nesse tipo de aplicação é imprescindível conhecer métodos eficientes para percorrer toda a estrutura. Por exemplo, para listar o conteúdo de um arquivo é necessário utilizar algoritmos para percurso.</p>
</div>
<div class="paragraph">
<p>Para percorrer uma árvore deve-se, então, visitar cada um de seus nós. O conceito de visita, nesse caso, possui um caráter bem específico. Visitar um nó significa operar, de alguma forma, com a informação a ele relativa. Por exemplo, imprimir, atualizar suas informações, etc. Em geral, percorrer uma árvore significa visitar seus nós exatamente uma vez. Contudo, no processo de percorrer a árvore pode ser necessário passar várias vezes por alguns de seus nós sem visitá-los. A seguir são discutidas as ideias principais nas quais se baseiam alguns dos algoritmos de percurso em árvore.</p>
</div>
<div class="paragraph">
<p>Um dos passos de qualquer algoritmo de percurso é visitar a raiz v de cada subárvore da árvore T. Além disso, pode-se assumir que o algoritmo opere de tal forma que o percurso de T seja uma composição de percursos de suas subárvores. Nesse caso, poder-se-iam se identificar, no percurso de T, os percursos de suas subárvores em forma contígua. Esses percursos correspondem, no algoritmo, às operações de <em>percorrer subárvores esquerda</em> e <em>direita</em> de v, para cada nó v de T. Essas três operações (visitar e percorrer subárvores esquerda e direita) compõem um algoritmo. Resta definir em que ordem essas operações serão realizadas em cada caso. Por exemplo, pode-se pressupor que as ordens serão as mesmas para todos os nós. Ainda assim, obtêm-se percursos diferentes, dependendo da ordem relativa dessas operações. Cada um desses percursos pode ser mais ou menos adequado a um problema de aplicação dado. São apresentados a seguir três percursos diversos.</p>
</div>
<div class="paragraph">
<p>O <em>percurso em pré-ordem</em> segue recursivamente os seguintes passos, para cada subárvore da árvore:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Visitar a raiz;</p>
</li>
<li>
<p>Percorrer sua subárvore esquerda, em pré-ordem;</p>
</li>
<li>
<p>Percorrer sua subárvore direita, em pré-ordem.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Para a árvore da <a href="#arm_arv_binaria">Figura 17</a>, o percurso em pré-ordem para impressão de nós fornece a seguinte saída: A B D G C E H I F.</p>
</div>
<div class="paragraph">
<p>O <a href="#percurso_pre-ordem">Algoritmo 25</a>, um algoritmo recursivo para o percurso em pré-ordem, é muito simples. A variável <em>pt</em>, parâmetro do procedimento, é um ponteiro que indica a raiz da subárvore que está sendo considerada na chamada ativa. Em cada chamada, somente esse nó é analisado. Após a visita a esse nó, a existência de subárvore esquerda é testada. Caso a resposta seja afirmativa, a chamada recursiva fará com que se percorra toda essa subárvore antes que a subárvore direita seja analisada.</p>
</div>
<div class="paragraph">
<p>A versão não recursiva deve então manter sempre atualizados os caminhos percorridos a partir da raiz da árvore. Uma forma conveniente para se implementar tal procedimento consiste na utilização de uma pilha. O nó é visitado ao ser colocado na pilha, enquanto a retirada da pilha indica o final da visita à subárvore cuja raiz é o nó considerado. Além do caminho percorrido na árvore, deve ser armazenada a direção do percurso, isto é, se o caminho tomado a partir de cada nó é referente à sua subárvore esquerda ou direita. Isto ocorre porque o nó só é retirado da pilha após ambos os percursos serem realizados. Essa versão, um pouco mais trabalhosa do que a apresentada aqui, é deixada ao leitor.</p>
</div>
<div id="percurso_pre-ordem" class="listingblock">
<div class="title">Algoritmo 25. Percurso em pré-ordem</div>
<div class="content">
<pre>procedimento pre(pt)
    visita(pt)
    se pt*.esq != lambda então pre(pt*.esq)
    se pt*.dir != lambda então pre(pt*.dir)

se prtaiz != lambda então pre(ptraiz)</pre>
</div>
</div>
<div class="paragraph">
<p>O <em>percurso em ordem simétrica</em> é muito utilizado para árvores binárias de busca, um dos assuntos do próximo capítulo. Os passos que o compõem são os seguintes, para cada uma de suas subárvores:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Percorrer sua subárvore esquerda, em ordem simétrica;</p>
</li>
<li>
<p>Visitar a raiz;</p>
</li>
<li>
<p>Percorrer sua subárvore direita, em ordem simétrica.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>O <a href="#percurso_simetrica">Algoritmo 26</a>, que mostra o procedimento recursivo que implementa esse percurso, é semelhante ao <a href="#percurso_pre-ordem">Algoritmo 25</a>. A única diferença decorre da própria definição, uma vez que a visita ao nó apontado por <em>pt</em> é feita após a chamada recursiva que estabelece o percurso da subárvore esquerda.</p>
</div>
<div id="percurso_simetrica" class="listingblock">
<div class="title">Algoritmo 26. Percurso em ordem simétrica</div>
<div class="content">
<pre>procedimento simet(pt)
    se pt*.esq != lambda então simet(pt*.esq)
    visita(pt)
    se pt*.dir != lambda então simet(pt*.dir)

se prtaiz != lambda então simet(ptraiz)</pre>
</div>
</div>
<div class="paragraph">
<p>O <a href="#percurso_simetrica">Algoritmo 26</a>, aplicado à árvore da <a href="#arm_arv_binaria">Figura 17</a> para impressão de seus nós, fornece o seguinte resultado: D G B A H E I C F.</p>
</div>
<div class="paragraph">
<p>Finalmente, de uma terceira alternativa de percurso, o <em>percurso em pós-ordem</em>, constam os seguintes passos:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Percorrer sua subárvore esquerda, em pós-ordem;</p>
</li>
<li>
<p>Percorrer sua subárvore direita, em pós-ordem;</p>
</li>
<li>
<p>Visitar a raiz.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>A implementação recursiva do percurso em pós-ordem, apresentada no <a href="#percurso_pos-ordem">Algoritmo 27</a>, introduz poucas variações em relação aos algoritmos anteriores. A implementação não recursiva é também deixada ao leitor.</p>
</div>
<div id="percurso_pos-ordem" class="listingblock">
<div class="title">Algoritmo 27. Percurso em pós-ordem</div>
<div class="content">
<pre>procedimento pos(pt)
    se pt*.esq != lambda então pos(pt*.esq)
    se pt*.dir != lambda então pos(pt*.dir)
    visita(pt)

se prtaiz != lambda então pos(ptraiz)</pre>
</div>
</div>
<div class="paragraph">
<p>O percurso em pós-ordem na árvore da <a href="#arm_arv_binaria">Figura 17</a> fornece o resultado G D B H I E F C A.</p>
</div>
<div class="paragraph">
<p>Em qualquer um dos três percursos apresentados, o procedimento correspondente é chamado recursivamente tantas vezes quantos são os nós da árvore.</p>
</div>
<div class="paragraph">
<p>Sendo n esse valor, a complexidade dos percursos, considerando-se o procedimento <em>visita</em> de complexidade constante, é \$O(n)\$.</p>
</div>
<div class="paragraph">
<p>O cálculo da altura de todos os nós de uma árvore binária é uma aplicação do percurso em pós-ordem. A altura das folhas, pela própria definição, é um. Para os outros nós, por exemplo v, é necessário conhecer o comprimento do maior caminho de v até um de seus descendentes. Isto equivale dizer que a altura de v deve ser calculada após a visita a seus descendentes. O <a href="#altura_binaria">Algoritmo 28</a> mostra a implementação do procedimento <em>visita(pt)</em>, que executa a tarefa de determinar a altura do nó apontado por <em>pt</em>. Considera-se <em>altura</em> um campo do nó da árvore. As variáveis auxiliares <em>alt1</em> e <em>alt2</em> armazenam, respectivamente, as alturas das subárvores esquerda e direita do nó em questão. A altura desejada corresponderá à maior altura dentre as de suas duas subárvores incrementada de um.</p>
</div>
<div id="altura_binaria" class="listingblock">
<div class="title">Algoritmo 28. Cálculo da altura de um nó da árvore binária</div>
<div class="content">
<pre>procedimento visita(pt)
    se pt*.esq != lambda então
        alt1 := (pt*.esq)*.altura
    senão alt1 := 0

    se pt*.dir != lambda então
        alt2 := (pt*.dir)*.altura
    senão alt2 := 0

    se alt1 &gt; alt2 então
        pt*.altura := alt1 + 1
    senão pt*.altura := alt2 + 1</pre>
</div>
</div>
<div class="paragraph">
<p>Existem outras formas de percorrer uma árvore binária além das três aqui estudadas. Por exemplo, o <em>percurso em nível</em> é aquele em que os nós são dispostos em ordem não decrescente de seus níveis. Esse percurso é único quando se define a ordem em que os nós do mesmo nível são visitados, por exemplo, da esquerda para a direita. O percurso em nível, segundo esse critério, para a árvore da <a href="#arm_arv_binaria">Figura 17</a> fornece a sequência A B C D E F G H I.</p>
</div>
<div class="paragraph">
<p>Observe que um percurso em nível difere, em sua essência, dos percursos em pré-ordem, ordem simétrica e pós-ordem. Enquanto nesses últimos o percurso da árvore pode ser decomposto em percursos (contíguos) de suas subárvores, o mesmo não acontece com o percurso em nível. Por esse motivo, o percurso em nível é de caráter não recursivo, isto é, um algoritmo para obter um percurso em nível não deve ser recursivo. De forma equivalente, o algoritmo não deve usar a pilha como estrutura de dados auxiliar. Na realidade, tal algoritmo pode ser facilmente descrito através do uso de uma fila.</p>
</div>
<div class="paragraph">
<p>Até o presente momento, considerou-se unicamente o percurso em árvores binárias. Não há dificuldade em generalizar esse conceito para árvores. Basta considerar que cada nó possui, agora, um número qualquer de subárvores e realizar o percurso em cada uma dessas subárvores.</p>
</div>
<div class="paragraph">
<p>Dessa forma, pode-se definir o percurso em pré-ordem de uma árvore qualquer da seguinte maneira. Para cada uma de suas subárvores, é preciso efetuar, recursivamente, os passos:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Visitar a raiz;</p>
</li>
<li>
<p>Percorrer a primeira subárvore em pré-ordem;</p>
</li>
<li>
<p>Percorrer a segunda subárvore em pré-ordem;</p>
</li>
<li>
<p>&#8230;&#8203;</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Por exemplo, o percurso em pré-ordem da árvore à direita da <a href="#isomorfismo">Figura 11</a> é A C D G H F I E B. Observe que a definição assume, implicitamente, uma ordenação das subárvores.</p>
</div>
<div class="paragraph">
<p>De maneira análoga, pode-se definir o percurso em pós-ordem de uma árvore qualquer. A definição de percurso em nível é igual e abrange também árvores não binárias.</p>
</div>
<div class="paragraph">
<p>Os algoritmos para percorrer árvores quaisquer devem supor, de início, a árvore representada internamente no computador de alguma forma. Esse assunto será abordado na próxima seção.</p>
</div>
<div style="page-break-after: always;"></div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="arvores_bin_busca">4. Árvores Binárias de Busca</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_introdução_2">4.1. Introdução</h3>
<div class="paragraph">
<p>Neste capítulo são descritas estruturas de dados adequadas à solução de problemas de busca. Dado um conjunto de elementos, onde cada um é identificado por uma chave, o objetivo é localizar nesse conjunto o elemento correspondente a uma chave específica procurada. Em capítulos anteriores, foram examinados métodos diferentes para resolver esse problema, como busca linear e linear ordenada. No presente capítulo será visto um método de solução que emprega a árvore binária como estrutura na qual se processa a busca. Ou seja, os elementos do conjunto são previamente distribuídos pelos nós de uma árvore de forma conveniente. A localização da chave desejada é então obtida através de um caminhamento apropriado na árvore.</p>
</div>
<div class="paragraph">
<p>É importante ressaltar, mais uma vez, a relevância desse problema na área de computação, em especial nas aplicações não numéricas. Sem dúvida, a operação de busca é uma das mais frequentemente realizadas. Vários métodos de solução empregam árvores como estruturas de armazenamento das chaves. Neste capítulo será examinado um desses métodos: a árvore binária de busca.</p>
</div>
</div>
<div class="sect2">
<h3 id="_conceitos_básicos">4.2. Conceitos básicos</h3>
<div class="paragraph">
<p>Seja \$S={s_1, ..., s_n}\$ o conjunto de chaves satisfazendo \$s_1&lt;...&lt;s_n\$. Seja \$x\$ um valor dado. O objetivo é verificar se \$x in S\$ ou não. Em caso positivo, localizar <em>x</em> em <em>S</em>, isto é, determinar o índice <em>j</em> tal que \$x=s_j\$.</p>
</div>
<div class="paragraph">
<p>Para resolver esse problema, emprega-se uma árvore binária rotulada <em>T</em>, com as seguintes características:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p><em>T</em> possui <em>n</em> nós. Cada nó <em>v</em> corresponde a uma chave distinta \$s_j in S\$ e possui como rótulo o valor \$rt(v)=s_j\$;</p>
</li>
<li>
<p>Seja um nó <em>v</em> de <em>T</em>. Seja também \$v_1\$, pertencente à subárvore esquerda de <em>v</em>. Então</p>
</li>
</ol>
</div>
<div class="stemblock">
<div class="content">
\$rt(v_1) &lt; rt(v)\$
</div>
</div>
<div class="paragraph">
<p>Analogamente, se \$v_2\$ pertence à subárvore direita de <em>v</em>,</p>
</div>
<div class="stemblock">
<div class="content">
\$rt(v_2) &gt; rt(v)\$
</div>
</div>
<div class="paragraph">
<p>A árvore <em>T</em> denomina-se <em>árvore binária de busca</em> para <em>S</em>. Naturalmente, se \$|S|&gt;1\$, existem várias árvores de busca para <em>S</em>. A <a href="#arv_bin_busca">Figura 18</a> ilustra duas dessas árvores para o conjunto <em>{1, 2, 3, 4, 5, 6, 7}</em>.</p>
</div>
<div id="arv_bin_busca" class="imageblock">
<div class="content">
<img src="img/arv_bin_busca.png" alt="arv bin busca">
</div>
<div class="title">Figura 18. Árvores binárias de busca</div>
</div>
</div>
<div class="sect2">
<h3 id="_busca">4.3. Busca</h3>
<div class="paragraph">
<p>Essa definição sugere como utilizar a árvore binária para resolver o problema de busca. Para determinar o índice <em>j</em> tal que \$s_j\$ seja igual à chave desejada <em>x</em>, deve-se percorrer o caminho em <em>T</em> desde a sua raiz até \$s_j\$. Para determinar esse caminho, o passo inicial consiste em considerar a raiz de <em>T</em>. No passo geral, seja <em>v</em> o nó considerado. Se \$x=rt(v)\$, a busca termina, pois a chave desejada foi encontrada. Caso contrário, o novo nó a considerar será o filho esquerdo \$w_1\$ ou o direito \$w_2\$ de <em>v</em>, conforme, respectivamente, \$x&lt;=&gt;rt(v)\$ ou \$x&gt;rt(v)\$. Caso não exista o nó que deveria ser considerado, \$w_1\$ ou \$w_2\$, a busca termina. Nessa última hipótese, <em>S</em> não contém a chave procurada <em>x</em>.</p>
</div>
<div class="paragraph">
<p>O algoritmo seguinte implementa a ideia. Suponha que a árvore esteja armazenada da forma habitual, isto é, para cada nó <em>v</em>, <em>esq</em> e <em>dir</em> designam os campos que armazenam ponteiros para os filhos esquerdo e direito de <em>v</em>, respectivamente. A raiz da árvore é apontada por <em>ptraiz</em>. A variável <em>f</em> designa a natureza final da busca. Tem-se, então:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>\$f=0\$, se a árvore é vazia;</p>
</li>
<li>
<p>\$f=1\$, se \$x in S\$. Nesse caso, <em>pt</em> aponta para o nó procurado;</p>
</li>
<li>
<p>\$f&gt;1\$, se \$x !in S\$.</p>
</li>
</ul>
</div>
<div id="busca_arv_bin_busca" class="listingblock">
<div class="title">Algoritmo 29. Busca em árvore binária de busca</div>
<div class="content">
<pre>procedimento busca-arvore(x, pt, f)
    se pt = lambda então f := 0
    senão se x = pt*.chave então f := 1
    senão se x &lt; pt*.chave então
        se pt*.esq = lambda então f:= 2
        senão
            pt := pt*.esq
            busca-arvore(x, pt, f)
    senão
        se pt*.dir = lambda então f := 3
        senão
            pt := pt*.dir
            busca-arvore(x, pt, f)

pt := ptraiz
busca-arvore(x, pt, f)</pre>
</div>
</div>
<div class="paragraph">
<p>Para determinar a complexidade desse algoritmo, basta observar que, em cada passo, isto é, em cada chamada do procedimento <em>busca-arvore</em>, é efetuado um número constante de operações. Assim sendo, a complexidade é igual ao número total de chamadas ocorridas no processo. Esse número é também igual ao númeto de nós existentes no caminho desde a raiz de <em>T</em> até o nó <em>v</em> onde o processo termina. Em um pior caso, <em>v</em> pode se encontrar a uma distância <em>O(n)</em> da raiz de <em>T</em>. Assim sendo, este valor <em>O(n)</em> constitui a complexidade da busca para uma árvore <em>T</em> genérica.</p>
</div>
<div class="paragraph">
<p>Da observação anterior, conclui-se que a complexidade da busca, para uma árvore <em>T</em>, é igual (no pior caso) à sua altura. Assim sendo, a eficiência do pior caso do algoritmo será tão maior quanto menor for a altura de <em>T</em>. Portanto, é conveniente tentar uma construção da árvore <em>T</em>, de modo a obtê-la com altura mínima. A árvore que possui essa propriedade, para um conjunto de <em>n</em> chaves, é precisamente a completa, conforme demonstrado no capítulo anterior. Nesse caso, a complexidade do algoritmo é igual a <em>O(log n)</em>.</p>
</div>
</div>
<div class="sect2">
<h3 id="_inserção">4.4. Inserção</h3>
<div class="paragraph">
<p>Para resolver o problema de inserção de nós na árvore de busca <em>T</em>, utiliza-se também o procedimento <em>busca-arvore</em> do <a href="#busca_arv_bin_busca">Algoritmo 29</a>. Seja <em>x</em> o valor da chave que se deseja inserir em <em>T</em> e <em>novo-valor</em> a informação associada a <em>x</em>. A ideia inicial é verificar se \$x in S\$. Em caso positivo, trata-se de uma chave duplicata e a inserção não pode ser realizada. Se \$x !in S\$, a chave de valor <em>x</em> será o rótulo de algum novo nó <em>w</em>, situado à esquerda ou à direita de <em>v</em>, para \$f=2\$ ou \$f=3\$, respectivamente, de acordo com o procedimento <em>busca-arvore</em>. O algoritmo abaixo descreve o processo.</p>
</div>
<div id="insercao_arv_bin_busca" class="listingblock">
<div class="title">Algoritmo 30. Inserção em árvore binária de busca</div>
<div class="content">
<pre>pt := ptraiz
busca-arvore(x, pt, f)
se f = 1 então
    "inserção inválida"
senão
    ocupar(pt1)
    pt1*.chave := x
    pt1*.info := novo-valor
    pt1*.esq := lambda
    pt1*.dir := lambda
    se f = 0 então
        ptraiz := pt1
    senão se f = 2 então
        pt*.esq := pt1
    senão pt*.dir := pt1</pre>
</div>
</div>
<div class="paragraph">
<p>A complexidade desse processo é igual à do procedimento de busca <em>busca-arvore</em>. O problema da construção de uma árvore binária de busca é examinado a seguir.</p>
</div>
<div class="paragraph">
<p>Para construir uma árvore binária de busca, pode-se utilizar o <a href="#insercao_arv_bin_busca">Algoritmo 30</a>, uma vez para cada nó. Seja \${s_1,...,s_n}\$ o conjunto de chaves, não necessariamente ordenado, para o qual se deseja construir a árvore <em>T</em>. Um possível algoritmo pode consistir no seguinte procedimento. No passo inicial, seja <em>T(1)</em> a árvore formada por um só nó, rotulado \$s_1\$. Em seguida, para \$j=2,...,n\$, utilizando o <a href="#insercao_arv_bin_busca">Algoritmo 30</a>, inserir em <em>T(j-1)</em> um novo nó, cujo rótulo é \$s_j\$, e denotar por <em>T(j)</em> a árvore assim obtida. Ao final, <em>T(n)</em> é uma árvore binária de busca para \${s_1,...,s_n}\$. Contudo, a árvore <em>T(n)</em> pode não ser muito adequada para a operação de busca, pois, dependendo do conjunto <em>S</em>, pode possuir altura <em>n</em>. A complexidade dessa construção alcança o valor <em>O(n²)</em>. Uma árvore zigue-zague é um exemplo desse caso.</p>
</div>
<div class="paragraph">
<p>Observa-se que a árvore obtida depende, na realizada, da ordem em que os nós foram considerados. Para construir uma árvore de busca completa, basta aplicar a construção anterior ao conjunto de chaves convenientemente reordenado. Sejam \$s_o\$ e \$s_(n+1)\$ duas chaves fictícias e definidas como <em>já inseridas</em> na árvore final <em>T</em>. A ideia consiste em, a cada passo, inserir em <em>T</em> alguma nova chave que seja de índice médio entre duas chaves \$s_i\$ e \$s_j\$, já inseridas em <em>T</em>, e tais que nenhuma outra chave tenha sido ainda inserida entre essas duas. Essa nova chave torna-se <em>já inserida</em>, e repete-se o processo. Além de obter uma árvore completa, ou seja, mais conveniente para a operação de busca, essa construção é também mais eficiente que a anterior. Sua complexidade é <em>O(n log n)</em>.</p>
</div>
<div class="paragraph">
<p>A árvore completa é ótima para o problema da busca no caso em que as frequências de acesso aos diferentes nós são todas idênticas. Em um caso real, contudo, essas frequências podem ser diferentes. Por exemplo, se cada nó representar um registro em um banco de dados, para diversas aplicações existirão casos de registros mais requisitados do que outros. Assim sendo, há interesse em contruir a árvore binária que seja a melhor possível, no que diz respeito à busca, para um dado conjunto de chaves com frequências de acesso conhecidas. É precisamente este o problema que é tratado na próxima seção.</p>
</div>
<div class="paragraph">
<p>A busca binária descrita no capítulo 2 corresponde, na realidade, a uma busca efetuada em uma árvore completa. A raiz <em>r</em> da árvore corresponde à chave que ocupa a posição central da sequência <em>S</em> de chaves da tabela. As raízes das subárvores esquerda e direita de <em>r</em>, respectivamente, são os elementos centrais das subsequências de <em>S</em>, à esquerda e à direita de <em>r</em>, e assim por diante.</p>
</div>
<div style="page-break-after: always;"></div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="arvores_balanceadas">5. Árvores Balanceadas</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_introdução_3">5.1. Introdução</h3>
<div class="paragraph">
<p>Um aspecto fundamental do estudo de árvores de busca é, naturalmente, o custo de acesso a uma chave desejada. Com o intuito de minimizar esse custo, foram desenvolvidas as árvores binárias de busca e de partilha ótimas. Ambas, porém, se restringem a aplicações estáticas. Isto é, após um certo número de inserções e remoções as árvores deixam de ser ótimas. Além disso, a complexidade da árvore de partilha ótima é muito elevada.</p>
</div>
<div class="paragraph">
<p>Para estrutura em que as probabilidades de acesso são idênticas entre si, há uma alternativa, considerada no presente capítulo. A ideia é manter o custo de acesso na mesma ordem de grandeza de uma árvore ótima, ou seja, \$O(logn)\$. Esse custo deve se manter ao longo de toda utilização da estrutura, inclusive após inclusões e remoções. Para alcançar essa finalidade, a estrutura deve ser alterada, periodicamente, de forma a se moldar aos novos dados. O custo dessas alterações, contudo, se mantém em \$O(logn)\$. Uma estrutura que opera com essas características é denominada <em>balanceada</em>.</p>
</div>
</div>
<div class="sect2">
<h3 id="_o_conceito_de_balanceamento">5.2. O Conceito de Balanceamento</h3>
<div class="paragraph">
<p>Conforme já foi observado, as árvores completas são aquelas que minimizam o número de comparações efetuadas no pior caso para uma busca com chaves de probabilidades de ocorrência idênticas.</p>
</div>
<div class="paragraph">
<p>Do ponto de vista das aplicações dinâmicas, contudo, o uso de árvores completas é, em geral, desaconselhável. Após um certo número de inclusões ou exclusões a árvore pode assumir uma forma pouco recomendável para o problema de busca. Em um caso extremo, ela pode inclusive degenerar-se em uma lista.</p>
</div>
<div class="paragraph">
<p>Para contornar esse problema, uma ideia seria aplicar um algoritmo que tornasse a árvore novamente completa, tão logo tal característica fosse perdida após uma inclusão ou exclusão. A dificuldade reside em como efetuar essa operação de forma ótima.</p>
</div>
<div class="paragraph">
<p>Por exemplo, considere uma árvore completa cujo último nível contenha todos os possíveis nós, exceto aquele que seria o mais à direita de todos. Nessa árvore só há uma possibilidade de inclusão sem aumento de altura. É a inclusão de uma chave maior do que todas as demais conforme indica a <a href="#exemplo_ruim_restab_arv_comp">Figura 19</a>(a). Se nessa árvore, ao contrário, for incluído um nó de chave menor que todas as outras, ela deixaria de ser completa, transformando-se na <a href="#exemplo_ruim_restab_arv_comp">Figura 19</a>(b). Para transformar essa última em uma árvore completa, observe que é necessário alterar a posição na estrutura de todos os seus nós. A <a href="#exemplo_ruim_restab_arv_comp">Figura 19</a>(c) descreve a árvore completa restabelecida após a inclusão do nó <em>0</em>.</p>
</div>
<div id="exemplo_ruim_restab_arv_comp" class="imageblock">
<div class="content">
<img src="img/exemplo_ruim_restab_arv_comp.png" alt="exemplo ruim restab arv comp">
</div>
<div class="title">Figura 19. Um exemplo ruim para o restabelecimento de árvores completas</div>
</div>
<div class="paragraph">
<p>Para efetuar essas transformações usuais de árvores binárias é necessário percorrer todos os nós da árvore. Isso implica que o algoritmo de restabelecimento da estrutura requer, pelo menos, \$O(n)\$ passos.</p>
</div>
<div class="paragraph">
<p>Naturalmente, este custo é considerado excessivo, considerando que operações como inserção ou remoção seriam efetuadas em \$O(logn)\$ passos. Por esse motivo, as árvores completas (e a busca binária) não são recomendadas para aplicações que requeiram estruturas dinâmicas.</p>
</div>
<div class="paragraph">
<p>Uma alternativa para esse último caso consiste em utilizar um determinado tipo de árvore binária cujo pior caso para a busca não seja necessariamente tão pequeno quanto o mínimo \$1+|__log_2 n__|\$ passos alcançado pela árvore completa. A ideia é exigir, porém, que a altura dessa nova árvore seja da mesma ordem de grandeza que a de uma ompleta com o mesmo número de nós. Isto é, que possua altura igual a \$O(logn)\$.</p>
</div>
<div class="paragraph">
<p>Além disso, é desejável que esta propriedade se estenda a todas as subárvores: cada subárvore que contém <em>m</em> nós deve possuir altura igual a \$O(logm)\$. Uma árvore que satisfaça essa condição é denominada balanceada.</p>
</div>
</div>
<div class="sect2">
<h3 id="_árvores_avl">5.3. Árvores AVL</h3>
<div class="paragraph">
<p>Nesta seção examina-se um tipo de árvores balanceadas, as árvores AVL. O nome dessa estrutura deriva dos seus criadores, Adelson Velsky e Landis. Uma árvore binária <em>T</em> é denominada AVL quando, para qualquer nó de <em>T</em>, as alturas de suas duas subárvores, esquerda e direita, diferem em módulo de até uma unidade. Nesse caso, <em>v</em> é um nó <em>regulado</em>. Em contrapartida, um nó que não satisfaça essa condição de altura é denominado <em>desregulado</em>, e uma árvore que contenha um nó nessas condições é também chamada <em>desregulada</em>. Naturalmente, toda árvore completa é AVL, mas não necessariamente vale a recíproca.</p>
</div>
<div id="arvores_avl" class="imageblock">
<div class="content">
<img src="img/arvores_avl.png" alt="arvores avl">
</div>
<div class="title">Figura 20. Árvores AVL (à esquerda) e não AVL</div>
</div>
<div class="sect3">
<h4 id="_inclusão_em_árvores_avl">5.3.1. Inclusão em Árvores AVL</h4>
<div class="paragraph">
<p>Seja <em>T</em> uma árvore AVL, na qual serão efetuadas inclusões de nós. Para que <em>T</em> se mantenha como árvore AVL após as inclusões (e, consequentemente, permaneçam válidos os resultados descritos, relativos ao seu balanceamento) é preciso efetuar operações de restabelecimento da regulagem de seus nós, quando necessário.</p>
</div>
<div class="paragraph">
<p>A ideia consiste em verificar, após cada inclusão, se algum nó <em>p</em> se encontra desregulado, isto é, se a diferença de altura entre duas subárvores de <em>p</em> tornou-se maior do que um. Em caso positivo, aplicar transformações apropriadas para regulá-lo.</p>
</div>
<div class="paragraph">
<p>Serão utilizadas as quatro transformações indicadas na <a href="#rot_arv_bin_busca">Figura 21</a>, denominadas, respectivamente, <em>rotação direita</em>, <em>rotação esqueda</em>, <em>rotação dupla direita</em> e <em>rotação dupla esquerda</em>. As subárvores \$T_1\$, \$T_2\$, \$T_3\$ e \$T_4\$ que aparecem na figura podem ser vazias ou não. O nó <em>p</em> é chamado <em>raiz</em> da transformação.</p>
</div>
<div id="rot_arv_bin_busca" class="imageblock">
<div class="content">
<img src="img/rot_arv_bin_busca.png" alt="rot arv bin busca">
</div>
<div class="title">Figura 21. Rotações em árvores binárias de busca</div>
</div>
<div class="paragraph">
<p>Por exemplo, a <a href="#reg_arv_avl">Figura 22</a>(c) representa o efeito de uma rotação direita da raiz <em>e</em>, efetuada na árvore da <a href="#reg_arv_avl">Figura 22</a>(b). Observe que essas transformações preservam a natureza da árvore como sendo binária de busca. Isto é, se o valor da chave de um nó <em>v</em> for inferior ao da correspondente ao nó <em>w</em>, então acontece uma dentre as seguintes possibilidades: <em>v</em> pertence à subárvore esquerda de <em>w</em>, ou <em>w</em> pertence à subárvore direita de <em>v</em>.</p>
</div>
<div id="reg_arv_avl" class="imageblock">
<div class="content">
<img src="img/reg_arv_avl.png" alt="reg arv avl">
</div>
<div class="title">Figura 22. Regulagem de árvores AVL</div>
</div>
</div>
<div class="sect3">
<h4 id="_implementação_da_inclusão">5.3.2. Implementação da Inclusão</h4>
<div class="paragraph">
<p>Seja <em>T</em> uma árvore AVL e <em>x</em> a chave a ser incluída em algum novo nó <em>q</em>. O processo completo de inclusão pode ser dividido do seguinte modo. Inicialmente, efetua-se uma busca em <em>T</em> para verificar se <em>x</em> já se encontra em <em>T</em>. Em caso positivo, o processo deve ser encerrado, pois se trata de uma chave duplicata.</p>
</div>
<div class="paragraph">
<p>Caso contrário, a busca encontra o local correto do novo nó. Segue-se, então, a inclusão propriamente dita. Deve-se verificar, em seguida, se essa operação tornou algum nó desregulado. Em caso negativo, o processo termina, pois <em>T</em> permanece AVL. Caso contrário, a regulagem de <em>T</em> deve ser efetuada. De acordo com a última seção, essa regulagem consiste na execução de uma das operações de rotação da <a href="#rot_arv_bin_busca">Figura 21</a>. A última etapa, pois, consiste no reconhecimento da operação de rotação indicada ao cado e em sua posterior execução. Isto devolve a <em>T</em> a condição de árvore AVL.</p>
</div>
<div class="paragraph">
<p>Em seguida, serão discutidos alguns aspectos do procedimento anterior. O primeiro problema ainda não detalhado é o de verificar se algum nó <em>v</em> de <em>T</em> se tornou deregulado após a inclusão. Há uma solução direta bastante simples para resolver essa questão. Basta determinar as alturas de suas duas subárvores e subtrair uma da outra. Essa operação pode ser realizada, sem dificuldades, percorrendo-se a subárvore de raiz <em>v</em> em <em>T</em>. Mas isto consome tempo (<em>O(n)</em>). Além disso, em princípio, qualquer nó do caminho de <em>q</em> até a raiz de árvore pode ter se tornado desregulado. Então, a aplicação direta desse procedimento conduz a um algoritmo de complexidade \$O(n logn)\$, o que o torna fora de cogitação. Essa complexidade pode ser facilmente reduzida para <em>O(n)</em>, percorrendo-se <em>T</em> de baixo para cima e armazenando-se o valor da altura de cada subárvore.</p>
</div>
<div class="paragraph">
<p>Naturalmente, \$h(v)=1+max{h_E (v), h_D (v)}\$. Entretanto, para alcançar a meta de efetuar a inclusão em tempo \$O(log n)\$, utiliza-se um processo diferente. Define-se o rótulo <em>balanço(v)</em>, para cada nó <em>v</em> de <em>T</em> como \$balanço(v)=h_D (v) - h_E (v)\$.</p>
</div>
<div class="paragraph">
<p>Observa-se que <em>v</em> está regulado se e somente se \$-1&lt;=balanço(v)&lt;=1\$. O problema é como atualizar \$balanço(v)\$ de forma eficiente, tendo em vista a inclusão de <em>q</em>. A ideia consiste em determinar o efeito dessa inclusão nos valores de <em>balanço(v)</em>. Se <em>q</em> pertencer à subárvore esquerda de <em>v</em> e essa inclusão ocasionar um aumento na altura dessa subárvore, então subtrai-se uma unidade de <em>balanço(v)</em>. Se esse valor descrescer para -2, indica que <em>v</em> se tornará desregulado.</p>
</div>
<div class="paragraph">
<p>Analogamente, se <em>q</em> pertencer à subárvore direita de <em>v</em> e provocar um aumento de sua altura, adiciona-se uma unidade a <em>balanço(v)</em>. O nó <em>v</em> ficará desregulado, nesse caso, se <em>balanço(v)</em> aumentar para 2.</p>
</div>
<div class="paragraph">
<p>Para completar o processo, resta ainda determinar em que casos a inclusão de <em>q</em> provoca um acréscimo na altura <em>h(v)</em> da subárvore <em>T(v)</em>. Para resolver essa questão, é interessante que se obtenha um método simples e eficiente, isto é, que possa ser resolvido em tempo constante. De início, observa-se que a inserção do nó <em>q</em> acarreta obrigatoriamente um alteração na altura da subárvore esquerda ou direita (de acordo com a nova chave) de seu nó pai <em>w</em>. A situação do campo <em>balanço</em> permite avaliar se essa alteração pode, ou não, se propagar aos outros nós <em>v</em> do caminho de <em>w</em> até a raiz da árvore.</p>
</div>
<div class="paragraph">
<p>Suponha que o nó <em>q</em> é inserido na subárvore esquerda de <em>v</em>. A análise de inicia com \$v=w\$ e prossegue em seus nós ancestrais, de forma recursiva. O processo se encerra quando da constatação de que a altura de <em>T(v)</em> nao foi modificada, ou de que <em>v</em> se tornou regulado. Três casos distintos podem ocorrer:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><strong>Caso 1:</strong> <em>balanço(v) = 1</em> antes da inclusão. Neste caso, <em>balanço(v)</em> se torna 0 e a altura da subárvore da raiz <em>v</em> não foi modificada. Consequentemente, as alturas dos nós restantes do caminho até a raiz da árvore não se alteram.</p>
</li>
<li>
<p><strong>Caso 2:</strong> <em>balanço(v) = 0</em> antes da inclusão. Neste caso, <em>balanço(v)</em> se torna -1 e a altura da subárvore da raiz <em>v</em> foi modificada. Consequentemente, os nós restantes do caminho até a raiz também podem ter suas alturas modificadas e devem ser analisados. Se <em>v</em> é a raiz de <em>T</em>, a análise se encerra, pois nenhum nó se tornou desregulado. Caso contrário, repetir o processo com <em>v</em> substituído por seu pai.</p>
</li>
<li>
<p><strong>Caso 3:</strong> <em>balanço(v) = -1</em> antes da inclusão. Neste caso, <em>balanço(v)</em> se torna -2 e o nó está desregulado. A rotação correta deve ser empregada. Qualquer rotação implica que a subárvore resultante tenha a mesma altura da subárvore antes da inclusão. As alturas dos ancestrais de <em>v</em> não mais necessitam de avaliação.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Para uma inserção na subárvore direita de <em>v</em>, casos simétricos devem ser considerados.</p>
</div>
<div class="paragraph">
<p>Após a regulagem da árvore, completa-se o processo. O algoritmo visto a seguir busca e insere, se possível, uma nova chave <em>x</em> numa árvore AVL. Observe que um só algoritmo foi considerado para as duas tarefas, ao contrário do que já foi visto em capítulos anteriores. Tal enfoque se deve à necessidade de conhecer todo o caminho da raiz até o nó inserido ao se regular a árvore. O procedimento recursivo <em>ins-AVL</em> cumpre essa tarefa.</p>
</div>
<div class="paragraph">
<p>De início, a posição de inserção é procurada determinando-se, na pilha de recursão, o caminho da raiz até o novo nó. O procedimento <em>inicio-no</em> aloca o novo nó. Após a inserção, o procedimento percorre o caminho inverso na árvore, acertanto o campo <em>bal</em> que implementa o rótulo <em>balanço</em>, já mencionado. Por meio deste pode-se conferir a regulagem de cada nó, determinando-se então o nó <em>p</em> apontado por <em>pt</em>.</p>
</div>
<div class="paragraph">
<p>A operação de rotação conveniente é efetuada imediatamente. O parâmetro lógico <em>h</em> retorna se houve ou não alteração na altura da subárvore do nó em questão, induzindo então à atualização do campo <em>bal</em>. A variável <em>ptraiz</em> é um ponteiro para a raiz da árvore. A chamada externa é <em>ins-AVL(x, ptraiz, h)</em>.</p>
</div>
<div id="insercao_arv_avl" class="listingblock">
<div class="title">Algoritmo 31. Busca e inserção em árvore AVL</div>
<div class="content">
<pre>procedimento inicio-no(pt)
    ocupar(pt)
    pt*.esq := lambda
    pt*.dir := lambda
    pt*.chave := x
    pt*.bal := 0

    retorna pt

procedimento caso1(pt)
    ptu := pt*.esq
    se ptu*.bal = -1 então
        ptv = ptu*.dir
        ptu*.dir := ptv*.esq
        pt*.esq := ptv*.dir
        ptv*.dir := pt
        ptv*.esq := ptu

        pt*.bal := 0
        pt := ptv
    senão
        pt*.esq := ptu*.dir
        ptu*.dir := pt

        pt*.bal := 0
        pt := ptu

    ptu*.bal := 0
    retorna pt, Falso

procedimento caso2(pt)
    ptu := pt*.dir
    se ptu*.bal = 1 então
        ptv = ptu*.esq
        ptu*.esq = ptv*.dir
        pt*.dir = ptv*.esq
        ptv*.esq = pt
        ptv*.dir = ptu

        pt*.bal = 0
        pt = ptv
    senão:
        pt*.dir = ptu*.esq
        ptu*.esq = pt

        pt*.bal = 0
        pt = ptu

    ptu*.bal := 0
    retorna pt, Falso

procedimento ins-AVL(x, pt)
    se pt = lambda então
        retorna inicio-no(pt), Verdadeiro
    senão se x = pt*.chave então
        escreva "chave já inserida"
        retorna pt, Nulo
    se x &lt; pt*.chave então
        pt*.esq, alterou_altura := ins-AVL(x, pt*.esq)
        se alterou_altura = Verdadeiro então
            se pt*.bal = -1 então
                pt*.bal := 0
                alterou_altura := Falso
            senão se pt*.bal = 0 então
                pt*.bal := 1
            senão se pt*.bal = 1 então
                pt, alterou_altura := caso1(pt)  % rebalanceamento
    senão
        pt*.dir, alterou_altura := ins-AVL(x, pt*.dir)
        se alterou_altura = Verdadeiro então
            se pt*.bal = 1 então
                pt*.bal := 0
                alterou_altura := Falso
            senão se pt*.bal = 0 então
                pt*.bal := -1
            senão se pt*.bal = -1 então
                pt, alterou_altura := caso2(pt) % rebalanceamento

    retorna pt, alterou_altura</pre>
</div>
</div>
<div class="paragraph">
<p>É imediato verificar que apenas uma operação de rotação, simples ou dupla, foi realizada. Além disso, o procedimento <em>ins-AVL</em> produz o efeito de percorrer a árvore desde a sua raiz até o nó <em>q</em> incluído. Portanto, o número de passos realizados é \$O(logn)\$.</p>
</div>
<div class="paragraph">
<p>A operação de exclusão de nós em árvores AVL também pode ser efetuada em \$O(logn)\$ passos. Basicamente, após a exclusão do nó desejado, a ideia consiste em verificar se a árvore se tornou desregulada. Analogamente ao caso das inclusões, a computação pode se restringir ao exame dos nós no caminho da raiz até alguma folha. Contudo, ao contrário do caso anterior, não basta necessariamente uma única rotação para regular a árvore. De fato, o número de operações de rotação necessárias pode atingir \$O(logn)\$. Por exemplo, a <a href="#rem_arv_avl">Figura 23</a>(a) representa uma árvore AVL, da qual se deseja excluir o nó <em>d</em>. Após a exclusão, o nó <em>c</em> deve ser regulado. Aplica-se uma rotação dupla direita (<a href="#rem_arv_avl">Figura 23</a>(b)), o que tornará, por sua vez, o nó <em>e</em> desregulado. É necessária, então, uma rotação adicional, e o processo se encerra. O resultado final é visto na <a href="#rem_arv_avl">Figura 23</a>(c).</p>
</div>
<div id="rem_arv_avl" class="imageblock">
<div class="content">
<img src="img/rem_arv_avl.png" alt="rem arv avl">
</div>
<div class="title">Figura 23. Remoção de nó em árvore AVL</div>
</div>
<div style="page-break-after: always;"></div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="alg_ordenacao">6. Algoritmos de Ordenação</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_introdução_4">6.1. Introdução</h3>
<div class="paragraph">
<p>Os capítulos anteriores trataram, em geral, de estruturas genéricas, adequadas à representação de quaisquer massas de dados. Neste capítulo serão descritas técnicas distintas para solucionar um problema que aparece como pré-processamento em muitas aplicações que envolvam o uso de tabelas - a obtenção de uma tabela ordenada.</p>
</div>
<div class="paragraph">
<p>O problema da ordenação foi um dos primeiros a gerar discussões sobre implementações eficientes ou não. É razoavelmente fácil comparar dois algoritmos quando aplicados a uma mesma massa de dados. Entretanto, massas de dados modelam situações e, muitas vezes, devido a particularidades das mesmas, alguns métodos se comportam melhor que outros, independentemente de sua avaliação em testes genéricos. O melhor exemplo disso são os métodos mais simples, como a ordenação bolha e a ordenação por inserção. Apesar de a complexidade de pior caso ser ruim, ambos são bastante utilizados em razão de sua extrema simplicidade de implementação. Também não pode ser esquecido que esses métodos podem ser convenientes quando a tabela é pequena ou está quase ordenada.</p>
</div>
<div class="paragraph">
<p>O objetivo deste capítulo é o estudo de algoritmos de ordenação, a avaliação de suas complexidades e implementações mais eficientes.</p>
</div>
</div>
<div class="sect2">
<h3 id="_ordenação_bolha_bubble_sort">6.2. Ordenação Bolha (<em>Bubble Sort</em>)</h3>
<div class="paragraph">
<p>O método de ordenação bolha é bastante simples, e talvez seja o método de ordenação mais difundido. Uma iteração do mesmo se limita a percorrer a tabela do início ao fim, sem interrupção, trocando de posição dois elementos consecutivos sempre que estes se apresentarem fora de ordem. Intuitivamente percebe-se que a intenção do método é mover os elementos maiores em direção ao fim da tabela. Ao terminar a primeira iteração pode-se garantir que as trocas realizadas posicionam o maior elemento na última posição. Na segunda iteração, o segundo maior elemento é posicionado, e assim sucessivamente. O processamente é repetido então \$n-1\$ vezes. O algoritmo que se segue implementa este método. A tabela se encontra armazenada na estrutura <em>L</em>. O algoritmo ordena <em>L</em> segundo valores não decrescentes do campo <em>chave</em>.</p>
</div>
<div id="bubble_sort" class="listingblock">
<div class="title">Algoritmo 32. Ordenação bolha de uma tabela com n elementos</div>
<div class="content">
<pre>para i = 1, ..., n faça
    para j = 1, ..., n - 1 faça
        se L[j].chave &gt; L[j + 1].chave então
            trocar(L[j], L[j + 1])</pre>
</div>
</div>
<div class="paragraph">
<p>O <a href="#bubble_sort">Algoritmo 32</a> é claramente ruim. Sua complexidade de pior caso é igual à de melhor caso, <em>O(n²)</em>, devido aos percursos estibulados para as variáveis <em>i</em> e <em>j</em>. Pode-se, entretanto, pensar em alguns critérios de parada que levariam em consideração comparações desnecessárias, isto é, comparações executadas em partes da tabela sabidamente já ordenadas.</p>
</div>
<div class="paragraph">
<p>O primeiro critério de parada resulta do fato de que, se a tabela está ordenada, o algoritmo é executado em toda sua extensão desnecessariamente. Uma variável lógica <em>mudou</em> é então introduzida com a finalidade de sinalizar se pelo menos uma troca foi realizada. Caso isso não ocorra, o algoritmo pode ser encerrado. Essa simples alteração afeta a complexidade de melhors caso do algoritmo, que passa a ser <em>O(n)</em>, uma vez que, se a tabela já está ordenada, apenas um percurso é realizado.</p>
</div>
<div class="paragraph">
<p>A segunda modificação decorre do próprio método: como, a cada passo, um elemento é garantidamente transportado para o fim da tabela, o número de elementos da mesma pode ser diminuído. Na realidade, a posição da última troca (armazenada, no algoritmo,  na variável <em>guarda</em>) indica que todos os elementos posteriores já estão ordenados. O algoritmo pode então utilizar, esta posição para atualizar o limite superior da tabela, que inicialmente é o próprio número de elementos.</p>
</div>
<div id="bubble_sort_parada" class="listingblock">
<div class="title">Algoritmo 33. Ordenação bolha com critério de parada</div>
<div class="content">
<pre>mudou := Verdadeiro
n' := n - 1
guarda := n - 1
enquanto mudou faça
    j := 0
    mudou := Falso
    enquando j &lt; n' faça
        se L[j].chave &gt; L[j + 1].chave então
            trocar(L[j], L[j + 1])
            mudou := Verdadeiro
            guarda := j
        j := j + 1
    n' := guarda</pre>
</div>
</div>
<div class="paragraph">
<p>A <a href="#ex_bubble_sort">Figura 24</a> apresenta um exemplo de aplicação do algoritmo anterior, sendo quatro iterações suficientes para a ordenação desejada. A última coluna indica o número de trocas realizadas durante a iteração considerada.</p>
</div>
<div id="ex_bubble_sort" class="imageblock">
<div class="content">
<img src="img/ex_bubble_sort.png" alt="ex bubble sort">
</div>
<div class="title">Figura 24. Um exemplo de ordenação bolha</div>
</div>
<div class="paragraph">
<p>O <a href="#bubble_sort_parada">Algoritmo 33</a> é bem mais eficiente; sua complexidade de pior caso, entretanto, permanece <em>O(n²)</em>. A entrada que justifica esse resultado é a tabela ordenada em ordem inversa.</p>
</div>
</div>
<div class="sect2">
<h3 id="_ordenação_por_inserção">6.3. Ordenação por Inserção</h3>
<div class="paragraph">
<p>O método de ordenação por inserção é também bastante simples, sendo sua complexidade equivalente à da ordenação bolha. Imagine uma tabela já ordenada até o <em>i</em>-ésimo elemento. A ordenação da tabela pode ser estendida até o \$(i+1)\$-ésimo elemento por meio de comparações sucessivas deste com os elementos anteriores, isto é, com o <em>i</em>-ésimo elemento, com o \$(i+1)\$-ésimo elemento etc., procurando sua posição correta na parte da tabela que já está ordenada. Pode-se então deduzir um algoritmo para implementar o método: considera-se sucessivamente todos os elementos, a partir do segundo deles, em relação à parte da tabela formada pelos elementos anteriores ao elemento considerado em cada iteração.</p>
</div>
<div id="ex_insert_sort" class="imageblock">
<div class="content">
<img src="img/ex_insert_sort.png" alt="ex insert sort">
</div>
<div class="title">Figura 25. Um exemplo de ordenação por inserção</div>
</div>
<div class="paragraph">
<p>A <a href="#ex_insert_sort">Figura 25</a> mostra um exemplo da execução do algoritmo. A tabela é reapresentada após a execução do posicionamento de cada elemento, a partir do segundo.</p>
</div>
<div class="paragraph">
<p>O algoritmo abaixo apresenta a ordenação por inserção da tabela <em>L</em>, de <em>n</em> elementos, segundo o seu campo <em>chave</em>. Para evitar erros de implementação, a tabela dee ser acrescida de uma posição <em>L[0]</em>, que pode receber em seu campo <em>chave</em> qualquer valor. Esse valor será testado no caso em que a posição definitiva do elemento que está sendo analisado seja a primeira. Essa comparação, entretanto, não tem efeito, uma vez que, nesse caso, \$j&lt;1\$ e o teste resulta falso.</p>
</div>
<div id="insert_sort" class="listingblock">
<div class="title">Algoritmo 34. Ordenação por inserção de uma tabela com n elementos</div>
<div class="content">
<pre>para i = 1, ..., n - 1 faça
    aux := L[i]
    valor := L[i].chave
    j := i - 1
    enquanto j &gt;= 0 e valor &lt; L[j].chave faça
        L[j + 1] := L[j]
        j := j - 1
    L[j + 1] := aux</pre>
</div>
</div>
<div class="paragraph">
<p>A complexidade deste algoritmo, assim como na ordenação bolha, é <em>O(n²)</em>.</p>
</div>
</div>
<div class="sect2">
<h3 id="_ordenação_por_intercalação_mergesort">6.4. Ordenação por Intercalação (<em>Mergesort</em>)</h3>
<div class="paragraph">
<p>O método apresentado nesta seção tem uma característica interessante, pois tem como procedimento básico o procedimento de intercalação de listas.</p>
</div>
<div class="paragraph">
<p>A ideia básica do método é intercalar as duas metades da lista desejada quando estas já se encontram ordenadas. Na realidade, deseja-se então ordenar primeiramente as duas metades, o que pode ser feito utilizando recursivamente o mesmo conceito.</p>
</div>
<div class="paragraph">
<p>Primeiramente, o processo de intercalação será revisto. Sejam duas listas <em>A</em> e <em>B</em>, ordenadas, com respectivamente <em>n</em> e <em>m</em> elementos. As duas listas são percorridas por ponteiros <em>ptA</em> e <em>ptB</em>, armazenando o resultado da intercalação na lista <em>C</em>, apontada pelo ponteiro <em>ptC</em>. O primeiro elemento de <em>A</em> é comparado com o primeiro elemento de <em>B</em>; o menor valor é colocado em <em>C</em>. O ponteiro da lista onde se encontra o menor valor é incrementado, assim como o ponteiro da lista resultado; o processo se repete até que uma das listas seja esgotada. Neste ponto, os elementos restantes da outra lista são copiados na lista resultado. A <a href="#ex_mergesort">Figura 26</a> ilustra o processo, e o algoritmo seguinte apresenta uma implementação do método, de complexidade de pior caso \$nlogn\$. O procedimento <em>COPIA(L)</em> retorna uma cópia de <em>L</em>.</p>
</div>
<div id="ex_mergesort" class="imageblock">
<div class="content">
<img src="img/ex_mergesort.png" alt="ex mergesort">
</div>
<div class="title">Figura 26. O processo de intercalação</div>
</div>
<div id="mergesort" class="listingblock">
<div class="title">Algoritmo 35. Ordenação por intercalação de uma tabela com n elementos</div>
<div class="content">
<pre>procedimento mergesort(esq, dir)
    se esq &lt; dir então
        centro := |__(esq + dir) / 2__|
        mergesort(esq, centro)
        mergesort(centro + 1, dir)
        intercalar(esq, centro + 1, dir)

procedimento intercalar(L, ini1, ini2, fim2)
    fim1 := ini2 - 1
    ind := ini1
    tmp = COPIA(L)
    enquanto (ini1 &lt;= fim1) e (ini2 &lt;= fim2) faça
        se L[ini1].chave &lt;= L[ini2].chave então
            tmp[ind] := L[ini1]
            ini1 := ini1 + 1
        senão
            tmp[ind] := L[ini2]
            ini2 := ini2 + 1
        ind := ind + 1
    enquanto ini1 &lt;= fim1 faça
        tmp[ind] := L[ini1]
        ini1 := ini1 + 1
        ind := ind + 1
    enquanto ini2 &lt;= fim2 faça
        tmp[ind] := L[ini2]
        ini2 := ini2 + 1
        ind := ind + 1
    para i := 0, ..., fim2 faça
        L[i] := tmp[i]

mergesort(1, n)</pre>
</div>
</div>
<div class="paragraph">
<p>Mesmo tendo complexidade de pior caso de \$O(nlogn)\$, a ordenação por intercalação não é um dos métodos de ordenação mais empregados. Sua eficiência depende da cuidadosa implementação da tabela temporária. A primeira providência necessária já foi tomada: utilizada somente uma área de trabalho ao longo de todo o processo. A segunda seria evitar a cópia executada após cada intercalação, o que pode ser feito alternando-se as tabelas <em>L</em> e <em>tmp</em> em níveis distintos da recursão.</p>
</div>
</div>
<div class="sect2">
<h3 id="_ordenação_rápida_quicksort">6.5. Ordenação Rápida (<em>Quicksort</em>)</h3>
<div class="paragraph">
<p>O nome <em>quicksort</em> (ordenação rápida) já indica o que se deve esperar do método, que é, na realidade, um dos mais eficientes dentre os conhecidos. Dada uma tabela <em>L</em> com <em>n</em> elementos, o procedimento recursivo para ordenar <em>L</em> consiste nos seguintes passos:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Se \$n=0\$ ou \$n=1\$ então a tabela está ordenada;</p>
</li>
<li>
<p>Escolha qualquer elemento <em>x</em> em <em>L</em> - este elemento é chamado <strong>pivô</strong>;</p>
</li>
<li>
<p>Separe \$L-{x}\$ em dois conjuntos de elementos disjuntos: \$S_1={w\inL-{x}|w&lt;x}\$ e \$S_2={w\inL-{x}|w&gt;=x}\$;</p>
</li>
<li>
<p>O procedimento de ordenação é chamado recursivamente para \$S_1\$ e \$S_2\$;</p>
</li>
<li>
<p><em>L</em> recebe a concatenação de \$S_1\$, seguido de <em>x</em>, seguido de \$S_2\$.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Dois pnotos são decisivos para o bom desempenho do algoritmo: a escolha do pivô e o particionamento da tabela. Esses pontos são analisados a seguir.</p>
</div>
<div class="paragraph">
<p>A escolha do pivô mais utilizada é tomar o primeiro elemento como tal. Isto é aceitável se a tabela é reconhecidamente aleatória. Se, entretanto, a tabela está ordenada na ordem inversa à desejada, esta escolha provoca o pior desempenho do algoritmo. A partição obtida nesse caso separa a tabela de tal forma que o conjunto \$S_1\$ contém \$n-1\$ elementos e o  conjunto \$S_2\$ é vazio. Sendo assim, o primeiro elemento não é uma boa escolha para pivô.</p>
</div>
<div class="paragraph">
<p>Uma estratégia alternativa é a escolha aleatória do pivô, mas a geração de números aleatórios poderia pesar no tempo de execução. A situação ideal seria a escolha de um pivô tal que proporcionasse a partição da tabela em dois subconnjuntos de dimensão equivalente. Para isso, a mediana da tabela deveria ser o elemento selecionado, lembrando que a mediana de um conjunto de <em>n</em> elementos é o \$n/2\$-ésimo maior número. Infelizmente, o cálculo desse elemento também seria muito custoso. Uma solução utilizada com bons resultados é a escolha da mediana dentre três elementos: o primeiro, o último e o central.</p>
</div>
<div class="paragraph">
<p>Solucionada a escolha do pivô, passa-se ao particionamento. Na descrição do algoritmo, os elementos iguais ao pivô foram colocados no conjunto \$S_2\$. Mas essa decisão, geralmente, depende da implementação. Antes disso, porém, observe o funcionamento do algoritmo considerando todos os elementos distintos.</p>
</div>
<div class="paragraph">
<p>Primeiramente, o pivô é afastado da tabela a ser percorrida; isto pode ser feito colocando-o na última posição e considerando somente o restante da tabela. Em seguida, dois ponteiros são utilizados. O primeiro, <em>i</em>, é inicializado apontando para o primeiro elemento da tabela, percorrendo-a enquanto os valores apontados são menores do que o pivô. O segundo, <em>j</em>, é inicializado na penúltima posição, efetuando a tarefa inversa. Os percursos são interrompidos quando <em>i</em> aponta para um elemento maior do que o pivô e <em>j</em> aponta para um elemento menor do que o pivô.</p>
</div>
<div class="paragraph">
<p>Duas situações podem ocorrer. Se \$i&lt;j\$, os elementos da tabela devem ser trocados e o procedimento deve prosseguir. Se \$i&gt;j\$, a partição já está determinada. O pivô, que se encontra na última posição da tabela, deve ser trocado com o elemento de índice <em>i</em>. Após a troca, os elementos de índice menor do que <em>i</em> formam o conjunto de elementos maiores do que o pivô. Note que o elemento de índice <em>i</em> foi trocado com o elemento que está na última posição da tabela (cuja chave é o pivô), ficando então na parte correta.</p>
</div>
<div class="paragraph">
<p>A <a href="#ex_quicksort">Figura 27</a> mostra uma passagem da execução do algoritmo no exemplo já utilizado anteriormente. Primeiramente o pivô é escolhido entre os valores 40, 42 e 27. O pivô determinado, 40, é trocado com a última posição e o percurso sobre a tabela com os índices <em>i</em> e <em>j</em> é iniciado. No momento em que esse percuro não pode mais prosseguir, <em>i</em> aponta para 95 e <em>j</em>, para 23. Como \$i&lt;j\$, os dois elementos são trocados, o percurso é reiniciado e para novamente quando <em>i</em> aponta para 42 e <em>j</em>, para 23. Agora, entretanto, \$i&gt;j\$ e a posição do pivô está decidida. O último elemento ocupa sua posição definitiva (a posição apontada por <em>i</em>), e os dois subconjuntos estão determinados: o de elementos menores do que o pivô, {27, 37, 23}, e o de maiores, {95, 51, 42}. O algoritmo prossegue, sendo aplicado a cada um dos subconjuntos.</p>
</div>
<div id="ex_quicksort" class="imageblock">
<div class="content">
<img src="img/ex_quicksort.png" alt="ex quicksort">
</div>
<div class="title">Figura 27. Ordenação rápida</div>
</div>
<div class="paragraph">
<p>Agora analisa-se a questão das chaves repetidas. Observe que, se elas acontecem na tabela <em>L</em>, o particionamento será afetado pelo teste executado no percurso dos ponteiros. A escolha do teste mais conveniente pode ser feita utilizando-se como exemplo uma taebal em que todas as chaves são iguais. Se os dois testes executados quando do percurso dos índices <em>i</em> e <em>j</em> ignoram chaves iguais ao pivô, haverá necessidade do acréscimo de um critério de parada e, mais, o pivô será colocado na extremidade da tabela, o que constitui o pior particionamento possível. Por outro lado, se nos dois testes o percurso for suspenso quando a chave é igual ao pivô, trocas desnecessárias serão feitas, mas o particionamento da tabela ocorrerá de forma mais equilibrada.</p>
</div>
<div class="paragraph">
<p>O <a href="#quicksort">Algoritmo 36</a> apresenta a ordenação rápida da tabela <em>L</em>, de <em>n</em> elementos, segundo o seu campo <em>chave</em>. As variáveis <em>ini</em> e <em>sup</em>, parâmetros do procedimento, são índices que indicam o primeiro e o último elemento da parte da tabela que está sendo processada na chamada. O procedimento PIVO, chamado no descorrer da ordenação, escolhe a mediana de três elementos.</p>
</div>
<div id="quicksort" class="listingblock">
<div class="title">Algoritmo 36. Ordenação rápida de uma tabela com n elementos</div>
<div class="content">
<pre>procedimento quicksort(ini, fim)
    se fim - ini &lt; 2 então
        se fim - ini = 1 então
            se L[ini].chave &gt; L[fim].chave então
                trocar(L[ini], L[fim])
    senão
        PIVO(ini, fim, mediana)
        trocar(L[mediana], L[fim])
        i := ini
        j := fim - 1
        chave := L[fim].chave
        enquanto j &gt;= i faça
            enquanto L[i].chave &lt; chave faça
                i := i + 1
            enquanto L[j].chave &gt; chave faça
                j := j - 1
            se j &gt;= i então
                trocar(L[i], L[j])
                i := i + 1
                j := j - 1
        trocar(L[i], L[fim])
        quicksort(ini, i - 1)
        quicksort(i + 1, fim)

quicksort(1, n)</pre>
</div>
</div>
<div class="paragraph">
<p>Uma observação deve ser feita a respeito da implementação do método. Um único critério de parada é utilizado, o teste \$j&gt;=i\$, independente, portanto, do tamanho da tabela. Isto é possível porqui, após cada troca, o índice <em>i</em> é incrementado e <em>j</em> é decrementado.</p>
</div>
<div class="paragraph">
<p>Para este algoritmo, tem-se que a complexidade de pior caso é dada por \$O(nlogn)\$.</p>
</div>
</div>
</div>
</div>
</div>
<div id="footer">
<div id="footer-text">
Last updated 2020-11-02 20:16:12 -0300
</div>
</div>
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  messageStyle: "none",
  tex2jax: {
    inlineMath: [["\\(", "\\)"]],
    displayMath: [["\\[", "\\]"]],
    ignoreClass: "nostem|nolatexmath"
  },
  asciimath2jax: {
    delimiters: [["\\$", "\\$"]],
    ignoreClass: "nostem|noasciimath"
  },
  TeX: { equationNumbers: { autoNumber: "none" } }
})
MathJax.Hub.Register.StartupHook("AsciiMath Jax Ready", function () {
  MathJax.InputJax.AsciiMath.postfilterHooks.Add(function (data, node) {
    if ((node = data.script.parentNode) && (node = node.parentNode) && node.classList.contains('stemblock')) {
      data.math.root.display = "block"
    }
    return data
  })
})
</script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_HTMLorMML"></script>
</body>
</html>